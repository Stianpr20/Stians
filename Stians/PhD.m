(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["Stians`SpecificTheme`"];


(* ::Input::Initialization:: *)
(* Import usage messages from file *)


(* ::Input::Initialization:: *)
<< "Stians/Messages/StiansSpecificTheme.txt"


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
AlignUB::ambiguous="`1` possible matrices found. Use a smaller tolerance.";
AlignUB::none="No matrices found.";
AlignUB::notfound="The `1` data file was not found.";
AlignUB::invalid="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid input.";
AlignUB::delta="Invalid setting for \[Delta].";

Options@AlignUB={
"Delta"->"Auto",
"ReturnDelta"->False,
"ReturnMatrices"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
AlignUB[input_String]:=Module[{input2,temp1,temp2,temp3,temp4,temp5},
(* Import if input is a file *)
If[FileExistsQ@input,
input2=StringJoin@Riffle[ToString/@Import[input][[1]]," "],
input2=input];

temp1=StringCases[input2,{"-",DigitCharacter}~~__];
temp2=First@StringSplit[temp1," "];
temp3=StringReplace[temp2,"E"->"*10^"];
temp4=ToExpression/@temp3;
temp5=Partition[temp4,3]
]


(* ::Input::Initialization:: *)
AlignUB[class_String,ref_,input_,OptionsPattern@AlignUB]:=Module[{
M,m,ubref,ubinput,delta,
temp,temp1,temp2,temp3,temp4,temp5,temp6,temp7,
tempA,tempB,tempC,tempD,tempE,tempF,tempG},

(*--- Preparing input ---*)
	(* Reference and input matrices *)
	M={};
	Do[
	Which[
	(* Import .dat file *)
	TrueQ[FileFormat[M]=="Table"],
		temp=Check[Import[M],
		Message[AlignUB::notfound,"reference"];
		Abort[]];
		m=Partition[temp[[1,3;;11]],3],

	(* Matrix given as string *)
	StringQ@m,m=AlignUB@m,

	(* Matrix given directly *)
	MatrixQ@m,Null,

	(* None of the above *)
	True,Message[AlignUB::invalid,m];Abort[]
	];
	AppendTo[M,m],
	{m,{ref,input}}
	];

	{ubref,ubinput}=M;


(*--- Finding correct matrix ---*)
	(* Multiplying input matrix by all symmetry operations *)
	temp1=Check[
	SymmetryOperations[class],
	Goto["End"]];
	temp2=Transpose/@temp1;
	temp3=Dot[ubinput,#]&/@temp2;

	(*-- Determining the value of 'delta' --*)
	delta=OptionValue["Delta"];
	Which[
	(* Automatic method *)
	TrueQ[delta==="Auto"],
		(* Subtracting reference matrix with
		every Laue equivalent *)
			tempA=Subtract[ubref,#]&/@temp3;
		(* Find the matrix with the smallest
		total squared deviation *)
			tempB=Total/@(Flatten/@tempA^2);
		(* Find the largest element of that matrix *)
			tempC=First@TakeSmallest[tempB,1];
			tempD=Position[tempB,tempC][[1,1]];
			tempE=First@TakeLargestBy[
			Flatten@tempA[[tempD]],Abs,1];
			tempF=RealDigits@tempE;
			tempG=Length@Select[First@tempF,#>0&]-Last@tempF;
			delta=Abs[tempE]+10^(-tempG);
			(* Optional: Return the found value *)
			If[OptionValue["ReturnDelta"],Return@delta],

	(* Use value set by user -- check if numeric *)
	NumericQ@delta,Null,
	
	(* None of the above *)
	True,Message[AlignUB::delta];Abort[]
	];

	(* Finding matrices within threshold *)
	temp4=Select[temp3,
	Chop[#-ubref,delta]==ConstantArray[0,{3,3}]&];
	temp5=Flatten[Position[temp3,#]&/@temp4];
		(* Abort if there are more than one possibility *)
		If[Length@temp5>1,
			(* Option *)
				If[OptionValue["ReturnMatrices"],Return@temp4];
		Message[AlignUB::ambiguous,Length@temp5];
		Goto["End"]];
		(* Warning if no matrices were found *)
		If[temp5=={},
		Message[AlignUB::none];
		Goto["End"]];

(*--- Formatting output ---*)
	temp6=temp1[[First@temp5]];
	temp7=StringDelete[ToString@temp6,{"{","}",","}];
	Return["um crec "<>temp7];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options[ErrorPropagation]={
"RoundSignificantFigures"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ErrorPropagation[function_,values__List,
OptionsPattern@ErrorPropagation]:=
Module[{n,X,\[Delta]X,f,\[Delta]f,u,x,pd,calc}, 

(*---* Preparations *---*)
	n=Length@{values};
	{X,\[Delta]X}=Transpose@{values};
	f=function@@X;

(*---* Partial derivatives *---*)
	(* Dummy variables *)
	u=IntegerString[Range[1,n],10,2];
	x=ToExpression@Map[StringJoin["x",#]&,u];

	(* Partial derivatives for each variable *)
	pd={};
	Do[
	AppendTo[pd,D[function@@x,x[[i]]]*\[Delta]X[[i]]],
	{i,n}];

(*---* Inserting values *---*)
	calc=ReplaceAll[pd,Thread[x->X]];
	\[Delta]f=Sqrt@Total[calc^2];

	(* Optional: 'RoundSignificantFigures' *)
	If[OptionValue["RoundSignificantFigures"],
	RoundSignificantFigures[{f,\[Delta]f}],
	{f,\[Delta]f}
	]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options@ExportCrystalData={
"IncludeSymmetryOperations"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExportCrystalData[crystal_String,output_String,OptionsPattern@ExportCrystalData]:=Module[{
data,compound,c,ltc,sg,csmatrix,
cell,atoms,siteM,type,flag,X,
$f0,sccoeff,asf,fp,fpp,write,end,endTab,
temp},

(* Input check *)
InputCheck[crystal,"CrystalQ"];

(*---* Preparing data *---*)
	(* Input *)
	data=$CrystalData[crystal];

	(* Compounds *)
	compound=crystal;

	(* Centring vectors *)
	c=SymmetryData[crystal,"Centring"];
	ltc=Which[
	c=="P",{{0,0,0}},
	c=="A",{{0,0,0},{0,1/2,1/2}},
	c=="B",{{0,0,0},{1/2,0,1/2}},
	c=="C",{{0,0,0},{1/2,1/2,0}},
	c=="I",{{0,0,0},{1/2,1/2,1/2}},
	c=="F",{{0,0,0},{1/2,1/2,0},
				{0,1/2,1/2},{1/2,0,1/2}},
	c=="R",{{0,0,0},{2/3,1/3,1/3},{1/3,2/3,2/3}}
	];

	(* Space group *)
	sg=SymmetryData[crystal,"HermannMauguinShort"];

	(* Symmetry operations *)
	If[OptionValue["IncludeSymmetryOperations"],
	csmatrix=SymmetryOperations[crystal];
	csmatrix=ToString[#,InputForm]&/@csmatrix,

	csmatrix={{{{1,0,0},{0,1,0},{0,0,1}},{0,0,0}}}
	];

	(* Lattice parameters *)
	cell=N@LatticeParameters[crystal,"Units"->False];

	(* Atom data *)
	atoms=Table[data["AtomData"][[i,#]]&/@
	{"Element","OccupationFactor","FractionalCoordinates",
	"DisplacementParameters"},
	{i,Length@$CrystalData[crystal,"AtomData"]}];

	Do[atoms[[i,-1]]=Flatten[{atoms[[i,-1]]}],{i,Length@atoms}];

	atoms[[All,1]]=StringDelete[
	atoms[[All,1]],{DigitCharacter,"+","-"}];	

	(* Multiplicity *)
	r=atoms[[All,3]];
	siteM=Table[N@Length@
	SymmetryEquivalentPositions[
	crystal,r[[a]]],{a,Length@r}]
	/Length@SymmetryOperations@crystal;

	atoms[[All,2]]=atoms[[All,2]]*siteM;

	(* ToString *)
	atoms=atoms/.x_String:>"\""<>x<>"\"";
	atoms=atoms/.x_?NumericQ:>ToString[x,InputForm];

	(* Flag (ADP type) *)
	type=data[["AtomData",1,"Type"]];
	flag=If[type=="Biso",{"B","B"},{"U","U"}];

	(* Scattering coefficients *)
	X=DeleteDuplicates@data[["AtomData",All,"Element"]];
	X=StringDelete[X,{DigitCharacter,"+","-"}];
	$f0=Import@FileNameJoin[{
	$XrayPath,"Core","Data",
	"AtomicScatteringFactor","WaasmaierKirfel.m"}];
	temp=Flatten[{$f0/@X}];
	temp=Values@temp[[All,
{"a1","a2","a3","a4","a5",
"b1","b2","b3","b4","b5",
"c"}]];
	sccoeff=Append[Partition[#,5],Last@#]&/@temp;
	Do[PrependTo[sccoeff[[i]],X[[i]]],{i,Length@X}];

	sccoeff=sccoeff/.x_String:>"\""<>x<>"\"";

	(* Anomalous corrections *)
	asf=
<|"H"->"{0.,0.}","He"->"{0.,0.}","Li"->"{0.,0.}","Be"->"{fpBe[Global`lambda],fppBe[Global`lambda]}","B"->"{fpB[Global`lambda],fppB[Global`lambda]}","C"->"{fpC[Global`lambda],fppC[Global`lambda]}","N"->"{fpN[Global`lambda],fppN[Global`lambda]}","O"->"{fpO[Global`lambda],fppO[Global`lambda]}","F"->"{fpF[Global`lambda],fppF[Global`lambda]}","Ne"->"{fpNe[Global`lambda],fppNe[Global`lambda]}","Na"->"{fpNa[Global`lambda],fppNa[Global`lambda]}","Mg"->"{fpMg[Global`lambda],fppMg[Global`lambda]}","Al"->"{fpAl[Global`lambda],fppAl[Global`lambda]}","Si"->"{fpSi[Global`lambda],fppSi[Global`lambda]}","P"->"{fpP[Global`lambda],fppP[Global`lambda]}","S"->"{fpS[Global`lambda],fppS[Global`lambda]}","Cl"->"{fpCl[Global`lambda],fppCl[Global`lambda]}","Ar"->"{fpAr[Global`lambda],fppAr[Global`lambda]}","K"->"{fpK[Global`lambda],fppK[Global`lambda]}","Ca"->"{fpCa[Global`lambda],fppCa[Global`lambda]}","Sc"->"{fpSc[Global`lambda],fppSc[Global`lambda]}","Ti"->"{fpTi[Global`lambda],fppTi[Global`lambda]}","V"->"{fpV[Global`lambda],fppV[Global`lambda]}","Cr"->"{fpCr[Global`lambda],fppCr[Global`lambda]}","Mn"->"\nIf[Global`lambda<=1.895,{fpMn1[Global`lambda],fppMn1[Global`lambda]},\n                   {fpMn2[Global`lambda],fppMn2[Global`lambda]}]","Fe"->"\nIf[Global`lambda<=1.743,{fpFe1[Global`lambda],fppFe1[Global`lambda]},\n                   {fpFe2[Global`lambda],fppFe2[Global`lambda]}]","Co"->"\nIf[Global`lambda<=1.608,{fpCo1[Global`lambda],fppCo1[Global`lambda]},\n                   {fpCo2[Global`lambda],fppCo2[Global`lambda]}]","Ni"->"\nIf[Global`lambda<=1.487,{fpNi1[Global`lambda],fppNi1[Global`lambda]},\n                   {fpNi2[Global`lambda],fppNi2[Global`lambda]}]","Cu"->"\nIf[Global`lambda<=1.380,{fpCu1[Global`lambda],fppCu1[Global`lambda]},\n                   {fpCu2[Global`lambda],fppCu2[Global`lambda]}]","Zn"->"\nIf[Global`lambda<=1.283,{fpZn1[Global`lambda],fppZn1[Global`lambda]},\n                   {fpZn2[Global`lambda],fppZn2[Global`lambda]}]","Ga"->"\nIf[Global`lambda<=1.195,{fpGa1[Global`lambda],fppGa1[Global`lambda]},\n                   {fpGa2[Global`lambda],fppGa2[Global`lambda]}]","Ge"->"\nIf[Global`lambda<=1.11659,{fpGe1[Global`lambda],fppGe1[Global`lambda]},\n                          {fpGe2[Global`lambda],fppGe2[Global`lambda]}]","As"->"\nIf[Global`lambda<=1.044,{fpAs1[Global`lambda],fppAs1[Global`lambda]},\n                   {fpAs2[Global`lambda],fppAs2[Global`lambda]}]","Se"->"\nIf[Global`lambda<=0.979,{fpSe1[Global`lambda],fppSe1[Global`lambda]},\n                   {fpSe2[Global`lambda],fppSe2[Global`lambda]}]","Br"->"\nIf[Global`lambda<=0.920,{fpBr1[Global`lambda],fppBr1[Global`lambda]},\n                   {fpBr2[Global`lambda],fppBr2[Global`lambda]}]","Kr"->"\nIf[Global`lambda<=0.865,{fpKr1[Global`lambda],fppKr1[Global`lambda]},\n                   {fpKr2[Global`lambda],fppKr2[Global`lambda]}]","Rb"->"\nIf[Global`lambda<=0.815,{fpRb1[Global`lambda],fppRb1[Global`lambda]},\n                   {fpRb2[Global`lambda],fppRb2[Global`lambda]}]","Sr"->"\nIf[Global`lambda<=0.769,{fpSr1[Global`lambda],fppSr1[Global`lambda]},\n                   {fpSr2[Global`lambda],fppSr2[Global`lambda]}]","Y"->"\nIf[Global`lambda<=0.727,{fpY1[Global`lambda],fppY1[Global`lambda]},\n                   {fpY2[Global`lambda],fppY2[Global`lambda]}]","Zr"->"\nIf[Global`lambda<=0.688,{fpZr1[Global`lambda],fppZr1[Global`lambda]},\n                   {fpZr2[Global`lambda],fppZr2[Global`lambda]}]","Nb"->"\nIf[Global`lambda<=0.653,{fpNb1[Global`lambda],fppNb1[Global`lambda]},\n                   {fpNb2[Global`lambda],fppNb2[Global`lambda]}]","Mo"->"\nIf[Global`lambda<=0.619,{fpMo1[Global`lambda],fppMo1[Global`lambda]},\n                   {fpMo2[Global`lambda],fppMo2[Global`lambda]}]","Tc"->"\nIf[Global`lambda<=0.589,{fpTc1[Global`lambda],fppTc1[Global`lambda]},\n                   {fpTc2[Global`lambda],fppTc2[Global`lambda]}]","Ru"->"\nIf[Global`lambda<=0.560,{fpRu1[Global`lambda],fppRu1[Global`lambda]},\n                   {fpRu2[Global`lambda],fppRu2[Global`lambda]}]","Rh"->"\nIf[Global`lambda<=0.533,{fpRh1[Global`lambda],fppRh1[Global`lambda]},\n                   {fpRh2[Global`lambda],fppRh2[Global`lambda]}]","Pd"->"\nIf[Global`lambda<=0.509,{fpPd1[Global`lambda],fppPd1[Global`lambda]},\n                   {fpPd2[Global`lambda],fppPd2[Global`lambda]}]","Ag"->"\nIf[Global`lambda<=0.485,{fpAg1[Global`lambda],fppAg1[Global`lambda]},\n                   {fpAg2[Global`lambda],fppAg2[Global`lambda]}]","Cd"->"\nIf[Global`lambda<=0.464,{fpCd1[Global`lambda],fppCd1[Global`lambda]},\n                   {fpCd2[Global`lambda],fppCd2[Global`lambda]}]","In"->"\nIf[Global`lambda<=0.443,{fpIn1[Global`lambda],fppIn1[Global`lambda]},\n                   {fpIn2[Global`lambda],fppIn2[Global`lambda]}]","Sn"->"\nIf[Global`lambda<=0.424,{fpSn1[Global`lambda],fppSn1[Global`lambda]},\n                   {fpSn2[Global`lambda],fppSn2[Global`lambda]}]","Sb"->"\nIf[Global`lambda<=0.406,{fpSb1[Global`lambda],fppSb1[Global`lambda]},\n                   {fpSb2[Global`lambda],fppSb2[Global`lambda]}]","Te"->"\nIf[Global`lambda<=0.389,{fpTe1[Global`lambda],fppTe1[Global`lambda]},\n                   {fpTe2[Global`lambda],fppTe2[Global`lambda]}]","I"->"\nIf[Global`lambda<=0.373,{fpI1[Global`lambda],fppI1[Global`lambda]},\n                   {fpI2[Global`lambda],fppI2[Global`lambda]}]","Xe"->"\nIf[Global`lambda<=0.358,{fpXe1[Global`lambda],fppXe1[Global`lambda]},\n                   {fpXe2[Global`lambda],fppXe2[Global`lambda]}]","Cs"->"\nIf[Global`lambda<=0.344,{fpCs1[Global`lambda],fppCs1[Global`lambda]},\n                   {fpCs2[Global`lambda],fppCs2[Global`lambda]}]","Ba"->"\nIf[Global`lambda<=0.331,{fpBa1[Global`lambda],fppBa1[Global`lambda]},\n                   {fpBa2[Global`lambda],fppBa2[Global`lambda]}]","La"->"\nLahich[Global`lambda<=0.318,{fpLa1[Global`lambda],fppLa1[Global`lambda]},\n      0.319<=Global`lambda<=1.978,{fpLa2[Global`lambda],fppLa2[Global`lambda]},\n      Global`lambda>=1.979,{fpLa3[Global`lambda],fppLa3[Global`lambda]}]","Ce"->"\nCehich[Global`lambda<=0.306,{fpCe1[Global`lambda],fppCe1[Global`lambda]},\n      0.307<=Global`lambda<=1.893,{fpCe2[Global`lambda],fppCe2[Global`lambda]},\n      Global`lambda>=1.894,{fpCe3[Global`lambda],fppCe3[Global`lambda]}]","Pr"->"\nPrhich[Global`lambda<=0.295,{fpPr1[Global`lambda],fppPr1[Global`lambda]},\n      0.296<=Global`lambda<=1.813,{fpPr2[Global`lambda],fppPr2[Global`lambda]},\n      1.814<=Global`lambda<=1.924,{fpPr3[Global`lambda],fppPr3[Global`lambda]},\n      Global`lambda>=1.925,{fpPr4[Global`lambda],fppPr4[Global`lambda]}]","Nd"->"\nNdhich[Global`lambda<=0.284,{fpNd1[Global`lambda],fppNd1[Global`lambda]},\n      0.285<=Global`lambda<=1.739,{fpNd2[Global`lambda],fppNd2[Global`lambda]},\n      1.740<=Global`lambda<=1.844,{fpNd3[Global`lambda],fppNd3[Global`lambda]},\n      1.845<=Global`lambda<=1.997,{fpNd4[Global`lambda],fppNd4[Global`lambda]},\n      Global`lambda>=1.998,{fpNd5[Global`lambda],fppNd5[Global`lambda]}]","Sm"->"\nSmhich[Global`lambda<=0.264,{fpSm1[Global`lambda],fppSm1[Global`lambda]},\n      0.265<=Global`lambda<=1.602,{fpSm2[Global`lambda],fppSm2[Global`lambda]},\n      1.603<=Global`lambda<=1.695,{fpSm3[Global`lambda],fppSm3[Global`lambda]},\n      1.696<=Global`lambda<=1.845,{fpSm4[Global`lambda],fppSm4[Global`lambda]},\n      Global`lambda>=1.846,{fpSm5[Global`lambda],fppSm5[Global`lambda]}]","Eu"->"\nEuhich[Global`lambda<=0.255,{fpEu1[Global`lambda],fppEu1[Global`lambda]},\n      0.256<=Global`lambda<=1.539,{fpEu2[Global`lambda],fppEu2[Global`lambda]},\n      1.540<=Global`lambda<=1.627,{fpEu3[Global`lambda],fppEu3[Global`lambda]},\n      1.628<=Global`lambda<=1.776,{fpEu4[Global`lambda],fppEu4[Global`lambda]},\n      Global`lambda>=1.777,{fpEu5[Global`lambda],fppEu5[Global`lambda]}]","Gd"->"\nGdhich[Global`lambda<=0.246,{fpGd1[Global`lambda],fppGd1[Global`lambda]},\n      0.247<=Global`lambda<=1.480,{fpGd2[Global`lambda],fppGd2[Global`lambda]},\n      1.481<=Global`lambda<=1.563,{fpGd3[Global`lambda],fppGd3[Global`lambda]},\n      1.564<=Global`lambda<=1.711,{fpGd4[Global`lambda],fppGd4[Global`lambda]},\n      Global`lambda>=1.712,{fpGd5[Global`lambda],fppGd5[Global`lambda]}]","Tb"->"\nTbhich[Global`lambda<=0.238,{fpTb1[Global`lambda],fppTb1[Global`lambda]},\n      0.239<=Global`lambda<=1.423,{fpTb2[Global`lambda],fppTb2[Global`lambda]},\n      1.424<=Global`lambda<=1.502,{fpTb3[Global`lambda],fppTb3[Global`lambda]},\n      1.503<=Global`lambda<=1.649,{fpTb4[Global`lambda],fppTb4[Global`lambda]},\n      Global`lambda>=1.650,{fpTb5[Global`lambda],fppTb5[Global`lambda]}]","Yb"->"\nYbhich[Global`lambda<=0.202,{fpYb1[Global`lambda],fppYb1[Global`lambda]},\n      0.203<=Global`lambda<=1.182,{fpYb2[Global`lambda],fppYb2[Global`lambda]},\n      1.183<=Global`lambda<=1.242,{fpYb3[Global`lambda],fppYb3[Global`lambda]},\n      1.243<=Global`lambda<=1.386,{fpYb4[Global`lambda],fppYb4[Global`lambda]},\n      Global`lambda>=1.387,{fpYb5[Global`lambda],fppYb5[Global`lambda]}]","Lu"->"\nLuhich[Global`lambda<=0.195,{fpLu1[Global`lambda],fppLu1[Global`lambda]},\n      0.196<=Global`lambda<=1.140,{fpLu2[Global`lambda],fppLu2[Global`lambda]},\n      1.141<=Global`lambda<=1.198,{fpLu3[Global`lambda],fppLu3[Global`lambda]},\n      1.199<=Global`lambda<=1.341,{fpLu4[Global`lambda],fppLu4[Global`lambda]},\n      Global`lambda>=1.342,{fpLu5[Global`lambda],fppLu5[Global`lambda]}]","Hf"->"\nHfhich[Global`lambda<=0.189,{fpHf1[Global`lambda],fppHf1[Global`lambda]},\n      0.190<=Global`lambda<=1.099,{fpHf2[Global`lambda],fppHf2[Global`lambda]},\n      1.100<=Global`lambda<=1.154,{fpHf3[Global`lambda],fppHf3[Global`lambda]},\n      1.155<=Global`lambda<=1.296,{fpHf4[Global`lambda],fppHf4[Global`lambda]},\n      Global`lambda>=1.297,{fpHf5[Global`lambda],fppHf5[Global`lambda]}]","Ta"->"\nTahich[Global`lambda<=0.183,{fpTa1[Global`lambda],fppTa1[Global`lambda]},\n      0.184<=Global`lambda<=1.061,{fpTa2[Global`lambda],fppTa2[Global`lambda]},\n      1.062<=Global`lambda<=1.113,{fpTa3[Global`lambda],fppTa3[Global`lambda]},\n      1.114<=Global`lambda<=1.254,{fpTa4[Global`lambda],fppTa4[Global`lambda]},\n      Global`lambda>=1.255,{fpTa5[Global`lambda],fppTa5[Global`lambda]}]","W"->"\nWhich[Global`lambda<=0.178,{fpW1[Global`lambda],fppW1[Global`lambda]},\n      0.179<=Global`lambda<=1.024,{fpW2[Global`lambda],fppW2[Global`lambda]},\n      1.025<=Global`lambda<=1.073,{fpW3[Global`lambda],fppW3[Global`lambda]},\n      1.074<=Global`lambda<=1.214,{fpW4[Global`lambda],fppW4[Global`lambda]},\n      Global`lambda>=1.215,{fpW5[Global`lambda],fppW5[Global`lambda]}]","Re"->"\nRehich[Global`lambda<=0.172,{fpRe1[Global`lambda],fppRe1[Global`lambda]},\n      0.173<=Global`lambda<=0.989,{fpRe2[Global`lambda],fppRe2[Global`lambda]},\n      0.990<=Global`lambda<=1.036,{fpRe3[Global`lambda],fppRe3[Global`lambda]},\n      1.037<=Global`lambda<=1.176,{fpRe4[Global`lambda],fppRe4[Global`lambda]},\n      Global`lambda>=1.177,{fpRe5[Global`lambda],fppRe5[Global`lambda]}]","Os"->"\nOshich[Global`lambda<=0.167,{fpOs1[Global`lambda],fppOs1[Global`lambda]},\n      0.168<=Global`lambda<=0.956,{fpOs2[Global`lambda],fppOs2[Global`lambda]},\n      0.957<=Global`lambda<=1.001,{fpOs3[Global`lambda],fppOs3[Global`lambda]},\n      1.002<=Global`lambda<=1.140,{fpOs4[Global`lambda],fppOs4[Global`lambda]},\n      Global`lambda>=1.141,{fpOs5[Global`lambda],fppOs5[Global`lambda]}]","Ir"->"\nIrhich[Global`lambda<=0.162,{fpIr1[Global`lambda],fppIr1[Global`lambda]},\n      0.163<=Global`lambda<=0.923,{fpIr2[Global`lambda],fppIr2[Global`lambda]},\n      0.924<=Global`lambda<=0.966,{fpIr3[Global`lambda],fppIr3[Global`lambda]},\n      0.967<=Global`lambda<=1.105,{fpIr4[Global`lambda],fppIr4[Global`lambda]},\n      Global`lambda>=1.106,{fpIr5[Global`lambda],fppIr5[Global`lambda]}]","Pt"->"\nPthich[Global`lambda<=0.158,{fpPt1[Global`lambda],fppPt1[Global`lambda]},\n      0.159<=Global`lambda<=0.893,{fpPt2[Global`lambda],fppPt2[Global`lambda]},\n      0.894<=Global`lambda<=0.934,{fpPt3[Global`lambda],fppPt3[Global`lambda]},\n      0.935<=Global`lambda<=1.072,{fpPt4[Global`lambda],fppPt4[Global`lambda]},\n      Global`lambda>=1.073,{fpPt5[Global`lambda],fppPt5[Global`lambda]}]","Au"->"\nAuhich[Global`lambda<=0.153,{-0.9007,fppAu1[Global`lambda]},\n      0.154<=Global`lambda<=0.863,{fpAu2[Global`lambda],fppAu2[Global`lambda]},\n      0.864<=Global`lambda<=0.902,{fpAu3[Global`lambda],fppAu3[Global`lambda]},\n      0.903<=Global`lambda<=1.040,{fpAu4[Global`lambda],fppAu4[Global`lambda]},\n      Global`lambda>=1.041,{fpAu5[Global`lambda],fppAu5[Global`lambda]}]","Hg"->"\nHghich[Global`lambda<=0.149,{-0.9287,fppHg1[Global`lambda]},\n      0.150<=Global`lambda<=0.835,{fpHg2[Global`lambda],fppHg2[Global`lambda]},\n      0.836<=Global`lambda<=0.872,{fpHg3[Global`lambda],fppHg3[Global`lambda]},\n      0.873<=Global`lambda<=1.009,{fpHg4[Global`lambda],fppHg4[Global`lambda]},\n      Global`lambda>=1.010,{fpHg5[Global`lambda],fppHg5[Global`lambda]}]","Tl"->"\nTlhich[Global`lambda<=0.144,{-0.9566,fppTl1[Global`lambda]},\n      0.145<=Global`lambda<=0.807,{fpTl2[Global`lambda],fppTl2[Global`lambda]},\n      0.808<=Global`lambda<=0.843,{fpTl3[Global`lambda],fppTl3[Global`lambda]},\n      0.844<=Global`lambda<=0.979,{fpTl4[Global`lambda],fppTl4[Global`lambda]},\n      Global`lambda>=0.980,{fpTl5[Global`lambda],fppTl5[Global`lambda]}]","Pb"->"\nPbhich[Global`lambda<=0.140,{-0.9856,fppPb1[Global`lambda]},\n      0.141<=Global`lambda<=0.781,{fpPb2[Global`lambda],fppPb2[Global`lambda]},\n      0.782<=Global`lambda<=0.815,{fpPb3[Global`lambda],fppPb3[Global`lambda]},\n      0.816<=Global`lambda<=0.951,{fpPb4[Global`lambda],fppPb4[Global`lambda]},\n      Global`lambda>=0.952,{fpPb5[Global`lambda],fppPb5[Global`lambda]}]","Bi"->"\nBihich[Global`lambda<=0.136,{-1.015,fppBi1[Global`lambda]},\n      0.137<=Global`lambda<=0.756,{fpBi2[Global`lambda],fppBi2[Global`lambda]},\n      0.757<=Global`lambda<=0.789,{fpBi3[Global`lambda],fppBi3[Global`lambda]},\n      0.790<=Global`lambda<=0.923,{fpBi4[Global`lambda],fppBi4[Global`lambda]},\n      Global`lambda>=0.924,{fpBi5[Global`lambda],fppBi5[Global`lambda]}]","Po"->"\nPohich[Global`lambda<=0.133,{-1.045,fppPo1[Global`lambda]},\n      0.134<=Global`lambda<=0.731,{fpPo2[Global`lambda],fppPo2[Global`lambda]},\n      0.732<=Global`lambda<=0.763,{fpPo3[Global`lambda],fppPo3[Global`lambda]},\n      0.764<=Global`lambda<=0.897,{fpPo4[Global`lambda],fppPo4[Global`lambda]},\n      Global`lambda>=0.898,{fpPo5[Global`lambda],fppPo5[Global`lambda]}]","At"->"\nAthich[Global`lambda<=0.129,{-1.076,fppAt1[Global`lambda]},\n      0.130<=Global`lambda<=0.708,{fpAt2[Global`lambda],fppAt2[Global`lambda]},\n      0.709<=Global`lambda<=0.738,{fpAt3[Global`lambda],fppAt3[Global`lambda]},\n      0.739<=Global`lambda<=0.872,{fpAt4[Global`lambda],fppAt4[Global`lambda]},\n      Global`lambda>=0.873,{fpAt5[Global`lambda],fppAt5[Global`lambda]}]","Rn"->"\nRnhich[Global`lambda<=0.125,{-1.107,fppRn1[Global`lambda]},\n      0.126<=Global`lambda<=0.686,{fpRn2[Global`lambda],fppRn2[Global`lambda]},\n      0.687<=Global`lambda<=0.715,{fpRn3[Global`lambda],fppRn3[Global`lambda]},\n      0.716<=Global`lambda<=0.848,{fpRn4[Global`lambda],fppRn4[Global`lambda]},\n      Global`lambda>=0.849,{fpRn5[Global`lambda],fppRn5[Global`lambda]}]","Fr"->"\nFrhich[Global`lambda<=0.122,{-1.138,fppFr1[Global`lambda]},\n      0.123<=Global`lambda<=0.665,{fpFr2[Global`lambda],fppFr2[Global`lambda]},\n      0.666<=Global`lambda<=0.692,{fpFr3[Global`lambda],fppFr3[Global`lambda]},\n      0.693<=Global`lambda<=0.824,{fpFr4[Global`lambda],fppFr4[Global`lambda]},\n      Global`lambda>=0.825,{fpFr5[Global`lambda],fppFr5[Global`lambda]}]","Ra"->"\nRahich[Global`lambda<=0.119,{-1.170,fppRa1[Global`lambda]},\n      0.120<=Global`lambda<=0.644,{fpRa2[Global`lambda],fppRa2[Global`lambda]},\n      0.645<=Global`lambda<=0.670,{fpRa3[Global`lambda],fppRa3[Global`lambda]},\n      0.671<=Global`lambda<=0.802,{fpRa4[Global`lambda],fppRa4[Global`lambda]},\n      Global`lambda>=0.803,{fpRa5[Global`lambda],fppRa5[Global`lambda]}]","Ac"->"\nAchich[Global`lambda<=0.116,{-1.203,fppAc1[Global`lambda]},\n      0.117<=Global`lambda<=0.624,{fpAc2[Global`lambda],fppAc2[Global`lambda]},\n      0.625<=Global`lambda<=0.649,{fpAc3[Global`lambda],fppAc3[Global`lambda]},\n      0.650<=Global`lambda<=0.781,{fpAc4[Global`lambda],fppAc4[Global`lambda]},\n      Global`lambda>=0.782,{fpAc5[Global`lambda],fppAc5[Global`lambda]}]","Th"->"\nThhich[Global`lambda<=0.113,{-1.237,fppTh1[Global`lambda]},\n      0.114<=Global`lambda<=0.605,{fpTh2[Global`lambda],fppTh2[Global`lambda]},\n      0.606<=Global`lambda<=0.629,{fpTh3[Global`lambda],fppTh3[Global`lambda]},\n      0.630<=Global`lambda<=0.760,{fpTh4[Global`lambda],fppTh4[Global`lambda]},\n      Global`lambda>=0.761,{fpTh5[Global`lambda],fppTh5[Global`lambda]}]","Pa"->"\nPahich[Global`lambda<=0.110,{-1.271,fppPa1[Global`lambda]},\n      0.111<=Global`lambda<=0.587,{fpPa2[Global`lambda],fppPa2[Global`lambda]},\n      0.588<=Global`lambda<=0.610,{fpPa3[Global`lambda],fppPa3[Global`lambda]},\n      0.611<=Global`lambda<=0.740,{fpPa4[Global`lambda],fppPa4[Global`lambda]},\n      Global`lambda>=0.741,{fpPa5[Global`lambda],fppPa5[Global`lambda]}]","U"->"\nUhich[Global`lambda<=0.107,{-1.305,fppU1[Global`lambda]},\n      0.108<=Global`lambda<=0.569,{fpU2[Global`lambda],fppU2[Global`lambda]},\n      0.570<=Global`lambda<=0.591,{fpU3[Global`lambda],fppU3[Global`lambda]},\n      0.592<=Global`lambda<=0.722,{fpU4[Global`lambda],fppU4[Global`lambda]},\n      Global`lambda>=0.723,{fpU5[Global`lambda],fppU5[Global`lambda]}]","Np"->"\nNphich[Global`lambda<=0.104,{-1.341,fppNp1[Global`lambda]},\n      0.105<=Global`lambda<=0.552,{fpNp2[Global`lambda],fppNp2[Global`lambda]},\n      0.553<=Global`lambda<=0.573,{fpNp3[Global`lambda],fppNp3[Global`lambda]},\n      0.574<=Global`lambda<=0.704,{fpNp4[Global`lambda],fppNp4[Global`lambda]},\n      Global`lambda>=0.705,{fpNp5[Global`lambda],fppNp5[Global`lambda]}]","Pu"->"\nPuhich[Global`lambda<=0.101,{-1.377,fppPu1[Global`lambda]},\n      0.102<=Global`lambda<=0.539,{fpPu2[Global`lambda],fppPu2[Global`lambda]},\n      0.540<=Global`lambda<=0.559,{fpPu3[Global`lambda],fppPu3[Global`lambda]},\n      0.560<=Global`lambda<=0.692,{fpPu4[Global`lambda],fppPu4[Global`lambda]},\n      Global`lambda>=0.693,{fpPu5[Global`lambda],fppPu5[Global`lambda]}]","Am"->"\nAmhich[Global`lambda<=0.099,{-1.414,fppAm1[Global`lambda]},\n      0.100<=Global`lambda<=0.521,{fpAm2[Global`lambda],fppAm2[Global`lambda]},\n      0.522<=Global`lambda<=0.540,{fpAm3[Global`lambda],fppAm3[Global`lambda]},\n      0.541<=Global`lambda<=0.669,{fpAm4[Global`lambda],fppAm4[Global`lambda]},\n      Global`lambda>=0.670,{fpAm5[Global`lambda],fppAm5[Global`lambda]}]","Cm"->"\nCmhich[Global`lambda<=0.096,{-1.451,fppCm1[Global`lambda]},\n      0.097<=Global`lambda<=0.506,{fpCm2[Global`lambda],fppCm2[Global`lambda]},\n      0.507<=Global`lambda<=0.521,{fpCm3[Global`lambda],fppCm3[Global`lambda]},\n      0.522<=Global`lambda<=0.654,{fpCm4[Global`lambda],fppCm4[Global`lambda]},\n      0.655<=Global`lambda<=1.971,{fpCm5[Global`lambda],fppCm5[Global`lambda]},      \n      Global`lambda>=1.972,{fpCm6[Global`lambda],fppCm6[Global`lambda]}]","Bk"->"\nBkhich[Global`lambda<=0.094,{-1.489,fppBk1[Global`lambda]},\n      0.095<=Global`lambda<=0.490,{fpBk2[Global`lambda],fppBk2[Global`lambda]},\n      0.491<=Global`lambda<=0.508,{fpBk3[Global`lambda],fppBk3[Global`lambda]},\n      0.509<=Global`lambda<=0.637,{fpBk4[Global`lambda],fppBk4[Global`lambda]},\n      0.638<=Global`lambda<=1.891,{fpBk5[Global`lambda],fppBk5[Global`lambda]}      \n      Global`lambda>=1.892,{fpBk6[Global`lambda],fppBk6[Global`lambda]}]","Cf"->"\nCfhich[Global`lambda<=0.091,{-1.528,fppCf1[Global`lambda]},\n      0.092<=Global`lambda<=0.478,{fpCf2[Global`lambda],fppCf2[Global`lambda]},\n      0.479<=Global`lambda<=0.495,{fpCf3[Global`lambda],fppCf3[Global`lambda]},\n      0.496<=Global`lambda<=0.627,{fpCf4[Global`lambda],fppCf4[Global`lambda]},\n      0.628<=Global`lambda<=1.859,{fpCf5[Global`lambda],fppCf5[Global`lambda]},\n      1.860<=Global`lambda<=1.978,{fpCf6[Global`lambda],fppCf6[Global`lambda]},      \n      Global`lambda>=1.979,{fpCf7[Global`lambda],fppCf7[Global`lambda]}]"|>;

	fp=StringTrim/@Transpose[{"\""<>#<>"\""&/@X,asf[#]&/@X}];
	fp[[All,2]]=StringReplace[fp[[All,2]],
	Shortest[f:("f"~~__)~~c_~~"["]:>
	f<>If[!NumericQ@ToExpression@c,c<>"1",c]<>"["];
	fp[[All,2]]=StringDelete[fp[[All,2]],"\n"];

	fpp="Get[\"inpol-"<>#<>
".dat\",Path->\"D:\\\\X-Ray-Diffraction\\\\Anomal\\\\Data\"];"&/@X;


(* Prepare file *)
end[x_]:=ToString[x,InputForm]<>";\n";
endTab[x_]:="{"<>(
Riffle[
ToString/@Riffle[x,"\n\t",{1,-1,2}],
",",{3,-3,3}]
)<>"};\n";

write=Flatten@{
"compound = \""<>crystal<>"\";\n",
"spacegroup = \""<>sg<>"\";\n",
"ltc="<>end@ltc,
"csmatrix="<>If[Length@csmatrix===1,
end@csmatrix,endTab@csmatrix],
"cell="<>end@cell,
"atoms="<>endTab@atoms,
"flag="<>end@flag,
"sccoeff="<>endTab@sccoeff,
"fp="<>endTab[DeleteDuplicates@fp]<>"\n",
DeleteDuplicates@fpp
};

(* Write file *)
Export[output,write,"Text"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
ExportReflectionFile::dir="Invalid directory.";
ExportReflectionFile::format="Invalid format of the reflection data.";
ExportReflectionFile::hkl="Output must end with \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"hkl\", \"Program\"]\).";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExportReflectionFile[output_String,hkl_List]:=Module[{dir,list,spacing,input,temp1,temp2,temp3,temp4},

(* Checking input *)
	dir=DirectoryName@output;

	If[dir==""||dir=="/",
	Message[ExportReflectionFile::dir];Abort[]];

	If[!DirectoryQ@dir,
	Message[ExportReflectionFile::dir];Abort[]];

	If[!StringTake[output,-3]=="hkl",
	Message[ExportReflectionFile::hkl];Abort[]];

	If[
	!Depth@hkl==3
	&&!MemberQ[{5,6},Length@RandomChoice@hkl],
	Message[ExportReflectionFile::format];Abort[]];

(* Handling the format of each reflection *)
	list={};
	spacing={4,4,4,8,8,4};
		If[Length@First@hkl==5,
		spacing=spacing[[;;5]]];

(* Adjusting spacing for each line *)
	input=Map[ToString,hkl,{2}];

	Do[
	temp1=input[[i]];
	temp2=spacing-StringLength/@temp1;
	temp3=StringJoin@ConstantArray[" ",#]&/@temp2;
	temp4=StringJoin@Riffle[temp3,temp1];
	AppendTo[list,temp4],
		{i,Length@input}
	];

	Export[output,list,"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
FindPixelClusters::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
FindPixelClusters::pixels="Pixels in the binarised image: `1`.";
FindPixelClusters::files="All images must be file paths.";
FindPixelClusters::dir="Invalid directory.";

Options@FindPixelClusters={
Method->"Auto",
"ReturnBinaryImage"->False,
"ClusterRange"->3,
"ClearStatus"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
FindPixelClusters[image_Image,OptionsPattern@FindPixelClusters]:=
Module[{
bin,data,L,method,fraction,check,
P,update,start,near,r,progress,status,total,p,i,j,neighbours,new,n,new2,
clusters,k},

(*---* Preparing image *---*)

	(* Otsu's cluster variance maximization method *)
	bin=Binarize@image;
	data=PixelValuePositions[bin,1];
	L=Length@data;

	(* Option: Choose method *)
	method=OptionValue[Method];
	Which[
	method=="Auto",method="Median",
	method=="Median",L=50000,
	method=="Mean",L=50000,
	method=="Cluster",L=50000,
	method=="HighestFraction",L=50001,
	method=="BinariseOnly",Goto["BinarisationDone"],
	True,Message[FindPixelClusters::method,method];Abort[]];

	(* Check if further refinement is necessary *)
	Which[
	L<=20000,Null,
	L<=50000,bin=DeleteSmallComponents[bin,Method->method],
	True,
	(* Special procedure for very noisy images *)
		fraction=1.00;
		check=True;

		While[check,
		fraction=fraction-0.005;
		bin=Binarize[image,Method->{"BlackFraction", fraction}];
		check=PixelValuePositions[bin,1]=={}];

		bin=DeleteSmallComponents[bin,Method->"Mean"]
	];

	data=PixelValuePositions[bin,1];
	
	(* Option: Return binary image and data length for inspection *)
		Label["BinarisationDone"];
		If[OptionValue["ReturnBinaryImage"],
		Message[FindPixelClusters::pixels,
		ToString@NumberForm[Length@data,DigitBlock->3]];
		Return@bin];


(*---* Cluster determination *---*)

	(* List of all pixels *)
	P={};
	update=N@data;
	start=First@update;
	r=N@OptionValue["ClusterRange"];
	near=N@DeleteCases[
	Flatten[Table[{i,j},{i,-r,r},{j,-r,r}],1],
	{0,0}];
	total=Length@data;
	progress=total;

	(* Dynamic status *)
	status=PrintTemporary[
	Row[
	{Text[Style["Determining pixel clusters:",FontFamily->"Avenir Next",14]],
	Spacer[20],
	Dynamic@ProgressIndicator[1-progress/total]
	},
	Alignment->Center
	]];

(* Single pixel *)
P=Reap@While[update!={},

(* First iteration *)
p={};

neighbours=start+#&/@near;
new=Intersection[update,neighbours];

	(* Avoid looping over the same single pixel *)
	If[new=={},update=Rest@update];

p=Join[p,new];
update=Complement[update,p];

	(* The next iterations *)
	While[new!={},
	
	(* Current and rest *)
	n=First@new;
	new=Rest@new;

		neighbours=n+#&/@near;
	
	(* Actual new elements *)
	new2=Intersection[update,neighbours];
	p=Join[p,new2];

	update=Complement[update,p];
	new=Join[new,new2];
	];

	(* One pixel done *)
	Sow[p];
	progress=Length@update;
	If[update!={},start=First@update]
];
	If[OptionValue["ClearStatus"],NotebookDelete@status];
	P=P[[2,1]];
	clusters=DeleteCases[P,{}];


(*---* Merge pixel clusters *---*)
	P=Reap@Do[
	k=Round[
	{
	Total@clusters[[i,All,1]],
	Total@clusters[[i,All,2]]
	}
	/Length@clusters[[i]]
	];
	Sow[k],
	{i,Length@clusters}
	];
	
	P[[2,1]]
]


(* ::Input::Initialization:: *)
FindPixelClusters[images_List,output_String,OptionsPattern@FindPixelClusters]:=Module[{progress,L,outputfile,step1,step2},

(* Check and prepare input *)
	If[AnyTrue[images,!FileExistsQ[#]&],
	Message[FindPixelClusters::files];Abort[]];
	If[!DirectoryQ@DirectoryName@output,
	Message[FindPixelClusters::dir];Abort[]];
	
	progress=0;
	L=Length@images;

(* Clear current $PixelData *)
	$PixelData=<||>;

(* Dynamic status *)
	PrintTemporary[
	Row[
	{Text[Style["Progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Images done: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

(* Preparing output file *)
	outputfile=output;
	Quiet@Close@outputfile;
	WriteString[outputfile,"<|"];

(* Loop *)
	Do[
	step1=IntegerString[FileHash[images[[i]],"MD5"],16,32];
	step2=FindPixelClusters[Import@images[[i]],
	Method->OptionValue[Method],
	"ClearStatus"->True];
	WriteString[outputfile,"\""<>step1<>"\""->step2];
	If[i!=Length@images,WriteString[outputfile,","]];
	progress++,
	{i,Length@images}];

(* End *)
	WriteString[outputfile,"|>"];
	Close@outputfile;
	AbsoluteFileName@outputfile
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
ImgScript::None="No \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) files were found.";
ImgScript::InvalidFormat="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";
ImgScript::String="\!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) file paths must be strings.";
ImgScript::span="The setting of \"SelectAdjust\" must be a Span.";
ImgScript::integers="The span in \"SelectAdjust\" must be comprised of integers.";
ImgScript::InvalidRange="Range for \"SelectAdjust\" is not compatible with the number of \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) files.";
ImgScript::na="\"SelectAdjust\" cannot be used without a brightness factor.";

Options[ImgScript]={
"WriteDirectory"->False,
"OutputFormat"->"bmp",
"SelectAdjust"->All};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ImgScript[input_,Optional[m_?NumericQ,1],OptionsPattern@ImgScript]:=Module[{
type,outdir,
imgfiles,name,ext,end,i,writedir,adjust,
fcode,entry},

(* Analysing input *)
	type=ToString[Head@input];
	Which[
	type=="String",
		(* Finding .img files in the given directory *)
		imgfiles=FileNames["*.img",input];
		outdir=input;
		(* Check *)
		If[imgfiles=={},Message[ImgScript::None];Abort[]],
	type=="List",
		imgfiles=input;
		outdir=DirectoryName@First@input;
		(* Check if empty *)
		If[imgfiles=={},Message[ImgScript::None];Abort[]];
		(* Check if list contains strings only *)
		If[!AllTrue[imgfiles,StringQ],Message[ImgScript::String];Abort[]]
	];

(* Determining .mac file name *)
	If[StringContainsQ[FileNameTake@First@imgfiles,"_"],
	(* Truncated name *)
	name=StringDrop[First@StringCases[FileNameTake@First@imgfiles,__~~"_"],-1],
	(* Base name *)
	name=StringDrop[First@StringCases[FileNameTake@
First@imgfiles,Shortest[__~~DigitCharacter]],-1]];

(* Function that sets new extension *)
	ext=OptionValue["OutputFormat"];
	end[i_]:=StringDrop[imgfiles[[i]],-3]<>ext;

(* Optional: Write a different directory *)
	writedir=OptionValue["WriteDirectory"];
	If[StringQ@writedir,
	imgfiles=FileNameJoin[{writedir,#}]&/@(FileNameTake/@imgfiles)];

(* Optional: Output format *)
	Which[
	ext=="bmp",fcode="bitmap ",
	ext=="jpg",fcode="jpgbmp ",
	True,Message[ImgScript::InvalidFormat,ext];Abort[]];

(* Optional: Adjust brightness *)
	adjust=OptionValue["SelectAdjust"];
		(* Checks *)
		If[!(adjust===All),
		If[ToString@Head@adjust!="Span",
		Message[ImgScript::span];Abort[]];
		If[!AllTrue[adjust,IntegerQ],
		Message[ImgScript::integers];Abort[]];
		If[!adjust[[1]]>=1||adjust[[2]]>Length@imgfiles,
		Message[ImgScript::InvalidRange];Abort[]];
		If[m==1,
		Message[ImgScript::na];Abort[]]
		];

	If[m!=1,If[adjust==All,
	adjust=Range@Length@imgfiles,Null,
	adjust=Part[Range@Length@imgfiles,adjust]]];

(* Function that writes code for each case *)
	entry[i_]:=
	"rd i \""<>imgfiles[[i]]<>"\"\n"<>
	If[MemberQ[adjust,i],
	"ip multiplydouble i1 i1 "<>ToString[N[m]]<>"\n",
	""]<>
	"wd "<>fcode<>"\""<>end[i]<>"\"";

(* Generating and exporting table *)
	Export[FileNameJoin[{outdir,name<>".mac"}],
	Table[entry[i],{i,Length@imgfiles}],"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ImportReflectionFile[file_?(StringTake[#,-3]=="hkl"&)]:=Module[
{import,end,temp,need0,l,zero},

(* Importing and trimming .hkl file *)
	import=Check[Import[file,"Table"],Abort[]];
	import=ToString/@import;
	end=Position[StringCases[import,"0, 0, 0"],{"0, 0, 0"}];
	(* Not ending with {0,0,0} *)
		If[end=={},
		end=Length@import;need0=True,
		end=First@Flatten@end;need0=False];
	temp=import[[;;end]];

(* Fixing clustered entries *)
	temp=StringReplace[temp,
	a:DigitCharacter~~"-"~~b:DigitCharacter:>a<>" , "<>b];
	temp=ToExpression/@StringTrim/@temp;

(* Appending zero element if needed *)
	l=Length@RandomChoice@temp;
	zero={0,0,0,0.00,0.00,0};
	zero=zero[[;;l]];
	If[need0,AppendTo[temp,zero]];
	temp
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options@IntensityTable={
"Sort"->-2
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
IntensityTable[group_String,file_?FileExistsQ,OptionsPattern@IntensityTable]:=
Module[{
import,sgHM,hkl,data,
gathered,wmean,
tally,minmax,min,max,range,span,
values,sort,table,
temp},

(*---* Importing data and reorganising *---*)
	import=Flatten@Check[Import[file,"CSV"],Abort[]];
	sgHM=SymmetryData[group,"HermannMauguinFull"];

	(* Removing the metadata appended in newer versions *)
		temp=Position[import,"   0   0   0    0.00    0.00   0"];
		If[temp!={},import=import[[;;temp[[1,1]]-1]]];		

	(* Fixing squeezed entries *)
	import=StringReplace[import,
	"  "~~p:{"-",""}~~a:DigitCharacter..~~"-"~~b:DigitCharacter:>
	"  "~~p~~a~~" -"~~b];
	import=ToExpression@StringSplit[import,Whitespace];

	(* Reorganising *)
	data=import/.{h_,k_,l_,F2_,\[Sigma]2_,batch_}:>{{h,k,l},F2,\[Sigma]2};
	
	(* Deleting extinct reflections *)
	hkl=data[[All,1]];
	temp=SystematicAbsentQ[sgHM,hkl];
	data=Pick[data,temp,False];

(*---* Gathering data by Laue class *---*)
	(* Gather by symmetry equivalence *)
	gathered=GatherBy[data,Sort@SymmetryEquivalentReflections[
sgHM,First@#]&];

	(* Calculating a weighted mean for each type *)
	temp=gathered[[All,All,{2,3}]];
	wmean=(WeightedMean@#)[[{1,3}]]&/@temp;

(*---* Extracting useful information for each group *---*)
	tally=Length/@gathered;
	minmax=Reap[
	Do[Sow[
	temp=f/@gathered[[All,All,2]];
	NumberForm[#,{6,0},
	DigitBlock->3,
	NumberSeparator->",",
	NumberPoint->""]&/@temp],
	{f,{Min,Max}}]
	];
	{min,max}=minmax[[2,1]];
	
	range=MapThread["("<>ToString[#1]<>"; "<>ToString[#2]<>")"&,{min,max}];
	span=MapThread[(#1-#2)/(2*#3)*100.0&,Map[First,{max,min,wmean},{2}]];

	(* Assigning a representative for each type of equivalent reflections *)
	temp=ToStandardSetting[sgHM,#]&/@
	(First/@First/@gathered);
	hkl=ToMiller/@temp;
	
	(* Merging the representatives with the corresponding values *)
	values=Transpose[{
	hkl,wmean[[All,1]],wmean[[All,2]],
	Length/@gathered,range,span}];

		(* Optional: Sorting option *)
		sort=OptionValue["Sort"];
		(* No preferance *)
		If[!MemberQ[Range@Last@Dimensions@values,Abs@sort],Goto["SortingDone"]];
		(* Sorting by a specific column *)			
		values=Sort[values,#1[[Abs@sort]]<#2[[Abs@sort]]&];
		(* Reversing if negative *)
		If[sort<0,values=Reverse@values];

(*---* Rounding off numbers *---*)
	Label["SortingDone"];
	temp=NumberForm[#,{6,0},
	DigitBlock->3,
	NumberSeparator->",",
	NumberPoint->""]&/@(Flatten@values);
	values=Partition[temp,Last@Dimensions@values];
	
	(* Inserting percentage signs to the 'relative span' *)
	values[[All,6]]=ToString[#]<>"%"&/@values[[All,6]];

(*---* Table construction *---*)
	table=PrependTo[values,
	{"(hkl)","[counts]","[counts]",Null,"(min; max)","from middle"}];
	table=PrependTo[table,
	{Null,"Intensity","Uncertainty","Tally","Range","Relative span"}];

	Grid[table,
	Dividers->{{None,{True},None},{None,None,True}},
	Background->{{None},{None,{None,GrayLevel[0.90]}}},
	Alignment->{Center,Center},
	Spacings->{1.5,2->0.25},
	ItemStyle->
	{Automatic,
	Automatic,
	{
	{{1,1},{1,Last@Dimensions@values}}->{FontFamily->"Times New Roman",FontSize->15},
	{{2,2},{1,Last@Dimensions@values}}->{FontFamily->"Times New Roman",FontSize->13,Gray},
	{{3,Length@table},{1,6}}->FontFamily->"Courier"
	}
	}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
MergeLogs::failed="Failed to interpret input. No log files with the prefix \[LeftGuillemet]crysalispro_red\[RightGuillemet] were found in \[LeftGuillemet]`1`\[RightGuillemet].";
MergeLogs::files="One or more log files were missing.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MergeLogs[input_?(StringQ[#]||AllTrue[#,StringQ]&),out_:" "]:=Module[{logs,sorted,imported,joined,output,name,file},
(*---* Processing input *---*)
(* A. Already merged log given *)
Quiet@If[
StringTake[input,27]=="Your current setup file is:",
Return@input];

(* B. Project or log directory given *)
Quiet@If[DirectoryQ@input,
logs=FileNames["crysalispro_red*",input,3];
Goto["InputCheck"]];

(* C. Single log file given *)
If[TrueQ[FileFormat[input]=="Text"],
Return@Import[input,"String"]];

(* D. Log files given as a list of paths *)
If[ListQ@input,
(* Check file existence *)
If[!AllTrue[input,FileExistsQ],
	Message[MergeLogs::files];Abort[]];
logs=input];

	(* Check input *)
	Label["InputCheck"];
	If[logs=={}||!ValueQ@logs,
	Message[MergeLogs::failed,input];Abort[]];

	(* Special case: Only one matching log file *)
	If[Length[logs]==1,
		joined=Import[First@logs,"Data"];
		If[Depth[joined]>2,joined=Flatten@joined];
		Goto["MergingDone"]
	];

(*---* Sorting chronologically and merging *---*)
	sorted=SortBy[logs,UnixTime@FileDate[#]&];
	imported=Map[Flatten,Import[#,"Data"]&/@sorted];
	joined=imported/.x_/;Depth[x]>2:>Flatten[x];

(*---* Returning merged log *---*)
	Label["MergingDone"];
	Which[
	(* A. Exporting to output directory *)
	Quiet@AllTrue[{input,ToString@out},DirectoryQ],
		name=FileNameTake[input,{-2}]<>"_log.txt";
		Export[FileNameJoin[{out,name}],joined],

	(* B. Returning merged log *)
	True,
		output=ToString/@joined;
		(* Export and import for correct formatting *)
		file=FileNameJoin[{$TemporaryDirectory,"temp.txt"}];
		Export[file,output];
		Import[file,"String"]
	]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
MonitorIni::InvInput="The length og the custom input does not match that of the \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"ini\", \"Program\"]\) file (or invalid range).";
MonitorIni::InvFlux="The flux file does not match the (length) of data.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MonitorIni[file_?(FileExtension[#]=="ini"&),input_]:=
Module[{flux,Flux,linFrom,linTo,method,import,end,prefix,L,seq,newvalues,i,newdata,filename},
(* Basic operations *)
	import=Check[Import@file,Abort[]];
	end=StringExtract[import[[2]],"_"->-1];
	prefix=StringTrim[import[[2,1]],end];
	L=Length@import-1;
	seq=ToString/@Range@L;

(* Checking if input is a flux file *)
	If[ToString@Head[input]=="String",
		flux=Check[Import[input,"Data"],Abort[]];
		Flux=Rest@flux;
		If[First[flux]=={"Flux"},
		newvalues=ToString/@(Flatten[Flux]/N[Max[Flux]]);
		(* Checking if the flux file is correct *)
		If[Length@newvalues!=L,Message[MonitorIni::InvFlux];
		Abort[]];
		Goto["ToNewData"];
		]
	];

(* Checking input for method *)
	method="LinearDecay";
	If[
	Length@Flatten@input==2,linFrom=input[[1]];linTo=input[[2]],
	method="CustomInput"
	];

(* Writing new data *)
	If[method=="CustomInput",
	newvalues=ToString/@input;
		(* Checking the custom input *)
		If[Length@newvalues!=L,Message[MonitorIni::InvInput];Abort[]],
	newvalues=ToString/@Reverse@Check[
Table[i,{i,linTo,linFrom,N[(linFrom-linTo)/(L-1)]}],Abort[]]];
	
	Label["ToNewData"];
	newdata=MapThread[prefix<>#1<>".img="<>#2&,{seq,newvalues}];
	PrependTo[newdata,"[Monitor]"];

(* Writing new file *)
	filename=StringDrop[file,-4];
	Export[filename<>"_new"<>".ini",newdata,"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
NonlinearLeastSquares::check="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised check method.";
NonlinearLeastSquares::stop="Procedure stopped at iteration `1`.";

Options@NonlinearLeastSquares={
"ConvergenceCheck"->"Shift",
"ConvergenceLimit"->0.0001,
"IterationStop"->10,
"Iterations"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
NonlinearLeastSquares[f_Symbol,data_List,\[Beta]_List,OptionsPattern@NonlinearLeastSquares]:=Module[{
X,m,v,n,
dummyV,dummy\[Beta],
p,i,\[CapitalDelta],R,
c,l,stop,test,
j,subst\[Beta],substV,J,
S,S0},

(* Number of data variables, unknown parameters and data points *)
X=Transpose@data;
m=Length@data;
v=Length@X;
n=Length@\[Beta];

(* Dummy variables *)
dummyV=Table[Unique["dummyV"],{i,v}];
dummy\[Beta]=Table[Unique["dummy\[Beta]"],{i,n}];

(* Initial setting of parameters and partial derivatives *)
p=\[Beta];
R={0};S=1000;(* Initial sum of squares *)
\[CapitalDelta]=1000;(* Inital shift in parameters *)
i=0;(* Iteration count *)

(* Convergence check method and limit *)
c=OptionValue["ConvergenceCheck"];
l=OptionValue["ConvergenceLimit"];
stop=OptionValue["IterationStop"];
Which[
c=="Shift",test:=\[CapitalDelta],
c=="Squares",test:=S,
True,Message[NonlinearLeastSquares::check,c];Abort[]
];

(** Iteration start **)
While[test>l,
i++;

j=Table[D[
f[dummyV,dummy\[Beta]/.List->Sequence],
dummy\[Beta][[i]]],{i,n}];

(* Substituting in parameter values *)
subst\[Beta]=Thread[dummy\[Beta]->p];
j=j/.subst\[Beta];

(* Preparing list of data points *)
substV=Table[
Thread[dummyV->X[[All,i]]],{i,m}];

(* Jacobian *)
J=N@Table[j/.substV[[i]],{i,m}];

(* Sum of squares (and difference from last iteration) *)
S0=Total[R^2];
R=N@Table[
f[X[[All,i]],p/.List->Sequence],
{i,m}];
S=Total[R^2];

(* New parameters *)
p=p-Inverse[Transpose[J].J].Transpose[J].R;

\[CapitalDelta]=Abs[S0-S];

(* Stop? *)
If[i==stop,
Message[NonlinearLeastSquares::stop,i];Break[]]
];

If[OptionValue["Iterations"],
{i,p},p]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
LeastSquaresFit::numeric="Numeric input only.";
LeastSquaresFit::invalid="Invalid input form.";
LeastSquaresFit::data="More data required.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LeastSquaresFit[data_List]:=Module[{
n,x,y,X,Y,
sumx2,sumy2,sumxy,s2y,
a,b,\[Delta]a,\[Delta]b,r,
\[Delta]y,\[CapitalDelta],w,sumx,sumy,sumw,wsumx2,wsumy2,wsumxy},

(*---* Check input *---*)
	If[!AllTrue[Flatten@data,NumericQ],
	Message[LeastSquaresFit::numeric];Abort[]];

	Which[
	MatchQ[Dimensions[data],{_,2}],Goto["WithoutWeights"],
	MatchQ[Dimensions[data],{_,3}],Goto["WithWeights"],
	True,Message[LeastSquaresFit::invalid];Abort[]];

	If[Length@data<3,Message[LeastSquaresFit::data];Abort[]];

(*---* Data without weights *---*)
	Label["WithoutWeights"];

	(* Useful variables *)
	n=Length@data;
	{x,y}=Transpose@data;
	{X,Y}=Mean/@{x,y};
	sumx2=Total[(x-X)^2];
	sumy2=Total[(y-Y)^2];
	sumxy=Total[(x-X)*(y-Y)];
	s2y=1/(n-2)*(sumx2*sumy2-sumxy^2)/sumx2;	

	(* Coefficients *)
	b=sumxy/sumx2;
	a=Y-b*X;	

	(* Uncertainties *)
	\[Delta]a=Sqrt[s2y*Total[x^2]/(n*sumx2)];
	\[Delta]b=Sqrt[s2y/sumx2];

	(* Correlation coefficient *)	
	If[sumx2==0||sumy2==0,
	r=1,
	r=sumxy/Sqrt[sumx2*sumy2]];

Return[{{a,\[Delta]a},{b,\[Delta]b},{r,s2y}}];


(*---* Data with weights *---*)
	Label["WithWeights"];

	(* Useful variables *)
	n=Length@data;
	{x,y,\[Delta]y}=N@Transpose@data;
	w=1/\[Delta]y^2;

	(* Sum of weighted lists and weighted means *)
	{sumx,sumy,sumw}={w.x,w.y,Total[w]};
	{X,Y}={sumx,sumy}/sumw;
	{sumx2,sumy2,sumxy}={w.x^2,w.y^2,Total[w*x*y]};
	\[CapitalDelta]=sumw*sumx2-sumx^2;

	(* Coefficients *)
	a=(sumx2*sumy-sumx*sumxy)/\[CapitalDelta];
	b=(sumw*sumxy-sumx*sumy)/\[CapitalDelta];

	(* Uncertainties *)
	wsumx2=Total[w*(x-X)^2];
	wsumy2=Total[w*(y-Y)^2];
	wsumxy=Total[w*(x-X)*(y-Y)];

	\[Delta]a=Sqrt[sumx2/\[CapitalDelta]];
	\[Delta]b=Sqrt[sumw/\[CapitalDelta]];

	(* Correclation coefficient *)
	If[wsumx2==0||wsumy2==0,
	r=1,
	r=wsumxy/Sqrt[wsumx2*wsumy2]];

Return[{{a,\[Delta]a},{b,\[Delta]b},{r}}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PeakTableInspection::cutoff="The cutoff intensity is relative to the maximum intensity and must be a number between 0 and 1.";
PeakTableInspection::width="The group width must be a positive number.";
PeakTableInspection::goniometer="Invalid goniometer data in \[LeftGuillemet]`1`\[RightGuillemet].";
PeakTableInspection::tab="\[LeftGuillemet]`1`\[RightGuillemet] is an invalid \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"tab\", \"Program\"]\) file.";

Options@PeakTableInspection={
"Cutoff"->0.85,
"GroupWidth"->5
};


(* ::Input::Initialization:: *)
PeakTableInspection[set_,OptionsPattern@PeakTableInspection]:=Module[{
cutoff,width,
lim,top,groups,newset,sort,\[Phi]max,\[Phi],j,keep},
(* Input check *)
	cutoff=OptionValue["Cutoff"];
	If[!0<=cutoff<=1,
	Message[PeakTableInspection::cutoff];Abort[]];
	
	width=OptionValue["GroupWidth"];
	If[!NumericQ[width]||Negative[width],
	Message[PeakTableInspection::width];Abort[]];

(* Keeping the top part of the registrations *)
	lim=Ceiling[cutoff*Max@set[[All,6]]];
	top=DeleteCases[set,i_/;i[[6]]<lim];

(* Groping registrated reflections *)
	groups={};newset={};
	Do[
	While[top!={},
	(* Finding the value of \[Phi] at maximum *)
		sort=Sort[top,#1[[6]]>#2[[6]]&];
		\[Phi]max=sort[[1,5]];

	(* Group reflections that are within 5\[Degree] of \[Phi]max *)
		Do[
		\[Phi]=top[[j,5]];
		If[IntervalMemberQ[
		Interval[{\[Phi]max-#,\[Phi]max+#}&[width]],\[Phi]],
		AppendTo[groups,top[[j]]]],
		{j,Length@top}];

	(* Clear group from the set and repeat *)
		top=Complement[top,groups];
		AppendTo[newset,{groups}];
		groups={}
	],
	{j,Length@top}
	];

(* Keeping only the peak from each group *)
	keep=TakeLargestBy[(First@Transpose@newset)[[#]],#[[6]]&,1]&/@(Range@Length@newset);
	(First@Transpose@keep)[[All,1]]
]


(* ::Input::Initialization:: *)
PeakTableInspection[goniometerfile_?(FileExtension[#]=="dat"&)]:=Module[{
import,data,gathered,multi,
inspected,keepsingles,keep,in,delete},
(* Check input *)
	If[!FileExistsQ@goniometerfile,
	Message[PeakTableInspection::goniometer,
	FileNameTake@goniometerfile];
	Abort[]];

(* Extracting the necessary data *)
	import=Check[Import[goniometerfile,"Data"],Abort[]];
	data=import[[All,{1,2,3,4,8,10}]];
	(* Gather by 'hkl' values *)
		gathered=GatherBy[data,#[[2;;4]]&];
	(* Delete cases with only one registration *)
		multi=DeleteCases[gathered,L_/;Length[L]==1];

(* Finding which registrations to delete *)
	(* Analysed *)
	inspected=Flatten[PeakTableInspection/@multi];
	(* Single reflections *)
	keepsingles=DeleteCases[gathered,L_/;Length[L]!=1];
	keepsingles=keepsingles[[All,1,1]];
	keep=Union[inspected,keepsingles];
	in=import[[All,1]];	

	delete=Complement[in,keep]
]


(* ::Input::Initialization:: *)
(* Pending *)
PeakTableInspection[goniometerfile_?(FileExtension[#]=="dat"&),tabfile_?(FileExtension[#]=="tab"&)]:=Module[{
delete,tab,head,n,nn,newfile},
(* Check input *)
	If[!FileExistsQ@goniometerfile,
	Message[PeakTableInspection::goniometer,
	FileNameTake@goniometerfile];
	Abort[]];

	If[!FileExistsQ@tabfile,
	Message[PeakTableInspection::tab,
	FileNameTake@tabfile];
	Abort[]];

(* Finding which registrations to delete *)
	delete=PeakTableInspection[goniometerfile];

(* Loading .tab file *)	
	tab=Import[tabfile,"TSV"];

	(* New header *)
	head=tab[[1,1]];
	n=First@StringSplit@head;
	nn=ToExpression[n]-Length@delete;
	tab[[1,1]]=StringReplace[head,n->ToString[nn]];

	(* Delete entries *)
	tab=Delete[tab,Map[{#}&,delete]];

	(* Export modiefied .tab file *)
	newfile=StringInsert[tabfile,"_modified",-5];
	Export[newfile,tab,"Table"]	
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
ReciprocalImageCheck::file="Input file was not found.";
ReciprocalImageCheck::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
ReciprocalImageCheck::system="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid lattice system.";
ReciprocalImageCheck::angles="Invalid angle input for the given system.";
ReciprocalImageCheck::load="\[LeftGuillemet]`1`\[RightGuillemet] cannot be loaded.";
ReciprocalImageCheck::form="The file does not appear to be on the correct Association form.";
ReciprocalImageCheck::asn="\[LeftGuillemet]$PixelData\[RightGuillemet] does not appear to be an Association.";
ReciprocalImageCheck::threshold="`1` reflection`2` outside the threshold for integer determination.";
ReciprocalImageCheck::all="All reflections were inside the threshold for integer determination.";
ReciprocalImageCheck::ambiguous="Ambiguous image orientation. Use different correspondence points.";
ReciprocalImageCheck::data="At least two data points are required.";
ReciprocalImageCheck::grid="The option \[LeftGuillemet]ShowLattice\[RightGuillemet] must either be set to \[LeftGuillemet]True\[RightGuillemet] or a non-negative integer.";

Options@ReciprocalImageCheck={
(* FindPixelClusters options *)
"ClearStatus"->False,
"ClusterRange"->3,
Method->"Auto",
"ReturnBinaryImage"->False,
(* ReciprocalImageCheck options *)
"Threshold"->0.15,
"RoundPixels"->True,
"LoadPixelData"->False,
"RetrieveData"->True,
"CountNonInteger"->False,
"StoreData"->False,
"ShowLattice"->False,
"Colours"->{ColorData[97,2],ColorData[97,1],LightGray},
"TooltipStyle"->{FontFamily->"Inconsolata",FontSize->14},
(* Plot options *)
Frame->True,
ImageSize->Large,
PlotRange->"ImageDimension",
PointSize->Large
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReciprocalImageCheck[
input_String,
system_,
data_List,
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],OptionsPattern@ReciprocalImageCheck]:=
Module[
{systems,sys,\[Alpha],\[Beta],\[Gamma],
image,imgdim,adjust,tx,ty,load,hash,pixlist,
hkls,sub,s,sel,normhkl,normorder,L,X,P,Pinv,method,
(* Lattice *)
L1x,L2x,L1y,L2y,
(* Conversion functions *)
\[CapitalLambda],\[CapitalGamma],\[Xi],convert,residue,threshold,result,i,\[Chi],
meddist,xy,rest,neighbour,distance,median,
selection,range,nearest,
clusters,off,groupfix,tooltip,
nodes,l,hkl,count,selection2D,pos,matching,pr,colourmatch,colourrest,colouroff,
temp,temp1,temp2,temp3,temp4,temp5,
(* Overalying grid *)
colours,V,c,L1,L2,t,tt,
gz,showgrid,del,grid,u,
(* Other *)
test,r,\[Lambda]1,\[Lambda]2,data2D,
plot,plotdata,plotoptions,
SD,grids},

(** Input check **)
	If[!FileExistsQ@input,
	Message[ReciprocalImageCheck::file];
	Abort[]];

	systems={
	"Triclinic","Monoclinic","Orthorhombic","Tetragonal",
	"Rhombohedral","Hexagonal","Cubic"};
	sys=If[ListQ@system,First@system,system];

	(* Check if valid lattice system *)
	If[!MemberQ[systems,sys],
	Message[ReciprocalImageCheck::system,system];
	Abort[]];

	(* Check if angles are required *)
	If[StringQ@system,	
	If[MemberQ[{"Triclinic","Monoclinic","Rhombohedral"},sys],
	Message[ReciprocalImageCheck::angles];Abort[]]
	];

	(* If angles given, check if form is valid *)
	If[ListQ@system,
	Which[
	sys=="Triclinic",
	If[MatchQ[Rest@system,
	{_?NumericQ,_?NumericQ,_?NumericQ}],
	{\[Alpha],\[Beta],\[Gamma]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]],

	sys=="Monoclinic",
	If[MatchQ[Rest@system,
	{_?NumericQ}],
	{\[Beta]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]],

	sys=="Rhombohedral",
	If[MatchQ[Rest@system,
	{_?NumericQ}],
	{\[Alpha]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]]
	]
	];

	(* Check for sufficient data *)
	If[Length@data<2,
	Message[ReciprocalImageCheck::data];
	Abort[]];

	(* Check for 'ShowLattice' and 'StoreData' option *)
	SD=OptionValue["StoreData"];
	gz=OptionValue["ShowLattice"];

	If[SD,gz=0];
	If[gz==True||(IntegerQ[gz]&&NonNegative[gz]),
	showgrid=True,showgrid=False,showgrid=False];
	If[gz==True,gz=0];


(** Preparations for extracting two dimensions (image plane) **)
	hkls=data[[All,{3,4,5}]];

		(* Test: Check for any column with the same element *)
		temp=DeleteDuplicates/@Transpose@hkls;
		test=Boole[Length[#]!=1&/@temp];
			If[Count[test,0]!=1,
			Message[ReciprocalImageCheck::ambiguous];
			Abort[]];

	(* Values describing the plane *)
	normorder=First@Flatten@Position[test,0];
	normhkl=data[[1,normorder+2]];
	sel=DeleteCases[{1,2,3},normorder];

	(* Planar data *)
	data2D=Transpose@Drop[Transpose@data,{2+normorder}];


(** Check if image is known **)
	image=Check[Import@input,Abort[]];
	imgdim=ImageDimensions@image;
	adjust={tx,ty}=imgdim/2;


	If[OptionValue["ReturnBinaryImage"],Goto["FindPixelClusters"]];

	(* Optional: Load file containing pixel data *)
	load=OptionValue["LoadPixelData"];
	If[StringQ@load,
	If[FileExistsQ@load,
	$PixelData=
	Check[ToExpression@Import[load,"String"],
	Message[ReciprocalImageCheck::form];Abort[]],
	Message[ReciprocalImageCheck::load,load];Abort[]
	]];
	If[!AssociationQ@$PixelData,
	Message[ReciprocalImageCheck::asn];Abort[]];

	(* Hash procedure *)
	hash=IntegerString[FileHash[input,"MD5"],16,32];	
	If[
	KeyExistsQ[$PixelData,hash]
	&&OptionValue["RetrieveData"],
	pixlist=$PixelData[hash];
	Goto["PixelDone"]];

(* Converting image to a list of pixels *)
	Label["FindPixelClusters"];
	pixlist=FindPixelClusters[image,
	#->OptionValue[#]&/@
{"ReturnBinaryImage",Method,"ClusterRange","ClearStatus"}];

	(* Option for returning binarised image *)
		If[OptionValue["ReturnBinaryImage"],Return@pixlist];

	(* Storing image hash along with pixel data *)
		AppendTo[$PixelData,hash->pixlist];


(** Setting up lattice **)
	Label["PixelDone"];

	(* Determining reciprocal lattice used in CrysAlis *)	
	Which[
	sys=="Triclinic",
		L=N[{
	{1,
	-Cot[\[Gamma]]/Sqrt[Cot[\[Gamma]]^2+Csc[\[Gamma]]^2],
	(Csc[\[Gamma]] (Cos[\[Alpha]] Cot[\[Gamma]]-Cos[\[Beta]] Csc[\[Gamma]]))/(\[Sqrt]((1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]))},
	{0,
	Csc[\[Gamma]]/Sqrt[Cot[\[Gamma]]^2+Csc[\[Gamma]]^2],
	(Csc[\[Gamma]] (Cos[\[Beta]] Cot[\[Gamma]]-Cos[\[Alpha]] Csc[\[Gamma]]))/(\[Sqrt]((1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]))},
	{0,
	0,
	1/Sqrt[
	(1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]]
	}}],

	sys=="Monoclinic",
		L=N[{
	{1,0,-Cos[\[Beta]]/Sqrt[1+Cos[\[Beta]]^2]},
	{0,1,0},
	{0,0,1/Sqrt[1+Cos[\[Beta]]^2]}}],

	sys=="Hexagonal",
		L=N[{{1,1/2,0},{0,Sqrt[3]/2,0},{0,0,1}}],

	True,L=IdentityMatrix[3]
	];

	(* Extracting two dimensions (image plane) *)
	L=L[[sel,sel]];

	(* Lattice components *)
	{{L1x,L2x},{L1y,L2y}}=L;

	(* Function for calculating residue *)
	r[{x_,y_,h1_,h2_},\[Lambda]1_,\[Lambda]2_]:=N[
	Sqrt[x^2+y^2]-
	Sqrt[(tx+h1*L1x*\[Lambda]1+h2*L2x*\[Lambda]2)^2+
	(ty+h1*L1y*\[Lambda]1+h2*L2y*\[Lambda]2)^2]];

	(* Determining scaling factors by iteration *)
	{\[Lambda]1,\[Lambda]2}=NonlinearLeastSquares[
	r,data2D,{50,50}];

	(* Scaled lattice *)
	\[CapitalLambda]=Transpose[Transpose[L]*{\[Lambda]1,\[Lambda]2}];
	\[CapitalGamma]=Inverse[\[CapitalLambda]];

	(* Conversion functions *)
	\[Xi][x_,y_]:=\[CapitalGamma].{x-tx,y-ty};
	\[Chi][h_,k_]:=\[CapitalLambda].{h,k}+{tx,ty};


(** Conversion functions **)
	
	(* Pixel to node *)
	\[Xi][{x_,y_}]:=(
	(* Calculation and discrepancy check *)
	convert=\[CapitalGamma].{x-tx,y-ty};
	residue=Abs/@FractionalPart/@N[convert];

	(* Decide whether to round to integer *)
	threshold=OptionValue["Threshold"];
	result={};
	
	Do[
	Which[
	residue[[i]]<=threshold,
		AppendTo[result,Round@convert[[i]]],
	1-residue[[i]]<=threshold,
		AppendTo[result,Round@convert[[i]]],
	True,
		AppendTo[result,N@convert[[i]]]
	],
	{i,2}];

	result);

	(* Node to pixel *)
	\[Chi][H_,round_:OptionValue["RoundPixels"]]:=(
	(* Calculation *)
	convert=\[CapitalLambda].H+adjust;
	
	(* Decide whether to round to integer *)
	If[round,Round@convert,convert]);


(** Optional: Overlaying grid/lattice **)
	If[!showgrid,Goto["LatticeDone"]];

	(* Preparations *)
	colours=<|1->Red,2->Green,3->Blue|>;
	c=Values@colours[[sel]];
	{L1,L2}=Transpose[\[CapitalLambda]];

	(* Lattice setup *)
	V[x0_,y0_]:=(
	t=\[CapitalLambda].{x0,y0}+adjust;
	tt={t,t};
	If[x0==y0==0,
	(* Origin arrows *)
	{
	{c[[1]],Arrow[{adjust,adjust+L1}]},
	{c[[2]],Arrow[{adjust,adjust+L2}]}
	},
	(* Translated arrows *)
	{
	{c[[1]],Dashed,Line[{{0,0},L1}+tt]},
	{c[[2]],Dashed,Line[{{0,0},L2}+tt]}
	}]
	);

	(* Lattice generation *)
	grids={};
	
	Label["StartGrid"];
	temp=Table[V[i,j],{i,-gz,Max[1,gz]},{j,-gz,Max[1,gz]}];
	temp=Flatten[temp,2];
	If[gz==0,
	temp=Delete[temp,{{3},{4},{5},{6},{7},{8}}];
	Goto["One"]
	];
	temp2=4gz+2;
	u=2*(2gz+1)^2;
	x1=Table[i,{i,temp2,u,temp2}];
		x1=Replace[x1,x_:>{x},{1}];
	x2=Table[j,{j,u-(4gz+1),u-1,2}];
		x2=Replace[x2,x_:>{x},{1}];
	del=DeleteDuplicates@Join[x1,x2];
	temp=Delete[temp,del];
	Label["One"];
	PrependTo[temp,Arrowheads[Medium]];

	grid=Graphics[temp,
	ImageSize->Small,
	AspectRatio->1,
	Axes->False
	];

	(* Optional: Generate several grids *)
		If[SD&&gz<8,
		AppendTo[grids,grid];gz++;Goto["StartGrid"]];

	Label["LatticeDone"];
	
	(* Consider relfections outside threshold to be wrong/off *)
	off=Select[pixlist,!AllTrue[\[Xi][#],IntegerQ]&];


(** Selecting nodes that match the pattern **)
	(* Setup *)
	nodes=\[Xi]/@pixlist;
	hkl=Partition[Riffle[
	Flatten@nodes,normhkl,{normorder,-1,3}],3];
	
	(* Check for non-integer cases *)
	If[OptionValue["CountNonInteger"],
		If[!FreeQ[hkl,_Real],
		Message[ReciprocalImageCheck::threshold,
		count=Count[FreeQ[#,_Real]&/@hkl,False],
		If[count>1,"s were"," was"]],
		Message[ReciprocalImageCheck::all]
		]];

	selection=Quiet@Cases[hkl,pattern];

	(* Backtracking *)
	selection2D=selection[[All,sel]];
	pos=Flatten[Position[nodes,#]&/@selection2D];
	matching=Part[pixlist,pos];

	(* Selection managment *)
	matching=Complement[matching,off];
	rest=Complement[pixlist,matching,off];

	(* Tooltip styling and managment *)
	groupfix[x_]:=Quiet[{x,ToMiller@
	Insert[\[Xi][x],normhkl,{normorder}]}];
	tooltip=Tooltip[#1,#2,TooltipStyle->
	OptionValue["TooltipStyle"]]&;

		(* Special case: Empty selections *)
		If[off=={},off={Null,Null}];
		If[rest=={},rest={Null,Null}];
		If[matching=={},matching={Null,Null};
		Goto["SkipMatching"]];

	(* Adding tooltip *)
	matching=MapThread[tooltip,
	Transpose[{
	pixlist[[#]],
	ToMiller@hkl[[#]]
	}&/@pos]
	];
	Label["SkipMatching"];

	rest=MapThread[tooltip,Transpose[groupfix/@rest]];
	off=MapThread[tooltip,Transpose[groupfix/@off]];


(** Plot **)
	(* Option: Custom PlotRange *)
	pr=OptionValue["PlotRange"];
	If[!MatchQ[pr,{{#,#},{#,#}}&[_Integer]],
	pr={0,#}&/@imgdim];

	{colourmatch,colourrest,colouroff}=OptionValue["Colours"];
	plotoptions={Frame->OptionValue[Frame],
	ImageSize->OptionValue[ImageSize],
	PlotRange->pr,
	AspectRatio->1/Divide@@imgdim,
	Axes->False,
	PlotStyle->{
{PointSize->OptionValue[PointSize],Automatic,colouroff},
{PointSize->OptionValue[PointSize],Automatic,colourrest},
{PointSize->OptionValue[PointSize],Automatic,colourmatch}}
	};
	plotdata={off,rest,matching};
	plot=ListPlot[plotdata,plotoptions];

(** End **)
	(* Optional: Store data *)
	If[OptionValue["StoreData"],
	Return[<|
	"Image"->image,
		"ImageGrayscale"->ColorConvert[image,"Grayscale"],
		"ImageNegative"->ColorNegate[image],
		"ImageGrayscaleNegative"->
		ColorConvert[ColorNegate[image],"Grayscale"],
		"ImageBinarised"->Binarize[image],
	"Lattice"->\[CapitalLambda],
	"LatticeBasic"->L,
	"Adjust"->adjust,
	"Plotdata"->rest,
		"PlotdataMatch"->matching,
		"PlotdataWrong"->off,
	"Grids"->grids
	|>
	]];

	(* Plot *)
	If[showgrid,
	Show[grid,plot,plotoptions],
	plot]
]


(* ::Input::Initialization:: *)
$PixelData=<||>;


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options@ReciprocalSpaceTool={
"TooltipStyle"->{FontFamily->"Inconsolata",FontSize->14}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReciprocalSpaceTool[
input_String,
system_,
data_List,
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],
OptionsPattern@ReciprocalSpaceTool
]:=Manipulate[
Module[{
xraytemp,lastinput,
adjust,
img,imgN,imgG,imgNG,imgB,
L,pd,pdMatch,pdOff,grids,
sim1,tooltip,SIM1,data2D,
\[CapitalLambda],\[CapitalGamma],\[Xi],\[Chi],r,\[CapitalLambda]1x,\[CapitalLambda]1y,\[CapitalLambda]2x,\[CapitalLambda]2y,p,\[Lambda]1,\[Lambda]2,tx,ty,h1h2,xy,
\[Sigma],\[Tau]x,\[Tau]y,xysim1,hksim1,sim1data,
plots,
plotbackground,
N1,N2,N3,plotoptions,plotaxes,plotgrid},

(** Input check **)
	(* Check temporary variables *)
	Label["CollectData"];
	xraytemp=$XrayTemp;
	lastinput=$XrayTempLast;

	If[update,lastinput="False";update=False];
	If[lastinput===input&&AssociationQ@$XrayTemp,
	(* Use stored data *)
	{img,imgN,imgG,imgNG,imgB,
	\[CapitalLambda],L,adjust,
	pd,pdMatch,pdOff,
	grids}=
	Values@xraytemp[[{
	"Image","ImageNegative","ImageGrayscale",
	"ImageGrayscaleNegative","ImageBinarised",
	"Lattice","LatticeBasic","Adjust",
	"Plotdata","PlotdataMatch","PlotdataWrong",
	"Grids"
	}]],
	(* Collect new data *)
		(* Update temporary variables *)
		$XrayTemp=ReciprocalImageCheck[
		input,system,data,pattern,
		"StoreData"->True];
		(* Update  *)
		$XrayTempLast=input;
		(* Go back and load data *)
		Goto["CollectData"]
	];


(** Plot layers **)
	plots={};

	(* Background image processing *)
	plotbackground=Which[
	LAimage=="Original",img,
	LAimage=="Negative",imgN,
	LAimage=="Grayscale",imgG,
	LAimage=="Negative + Grayscale",imgNG,
	LAimage=="Binarised",imgB,
	True,False
	];

	If[ImageQ@plotbackground,
	AppendTo[plots,plotbackground]];

	(* Grid *)
	If[IntegerQ@LAsize,
	plotgrid=grids[[LAsize]];
	AppendTo[plots,plotgrid]];

	(* Extracted nodes *)
	If[pd!={Null,Null},
	N1enable=True,
	N1enable=False];
	N1=ListPlot[pd,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N1colour,
	Opacity[N1opacity]}}];
	If[N1show,AppendTo[plots,N1]];

	(* Nodes matching condition *)
	If[pdMatch!={Null,Null},
	N2enable=True,
	N2enable=False];
	N2=ListPlot[pdMatch,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N2colour,
	Opacity[N2opacity]}}];
	If[N2show,AppendTo[plots,N2]];

	(* Wrong nodes *)
	If[pdOff!={Null,Null},
	N3enable=True,
	N3enable=False];
	N3=ListPlot[pdOff,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N3colour,
	Opacity[N3opacity]}}];
	If[N3show,AppendTo[plots,N3]];


(** Simulated nodes **)
	If[SIM1calc,
	(* Generate simulated nodes *)
	sim1=ReciprocalSpaceSimulation[
	SIM1name,SIM1plane,
	Total[SIM1plane]-1/.-1->SIM1level,
	SIM1res,
	"ReturnData"->True];

	(* Lattice components and misc *)
	{{\[CapitalLambda]1x,\[CapitalLambda]2x},{\[CapitalLambda]1y,\[CapitalLambda]2y}}=\[CapitalLambda];
	{tx,ty}=adjust;
	p=First@Flatten@Position[Total[SIM1plane],0];
	sim1=Delete[sim1,Table[{i,2,p},{i,Length@sim1}]];
	data2D=Partition[Flatten@sim1,4];

	(* Function for calculating residue *)
	r[{x_,y_,h1_,h2_},\[Sigma]_,\[Tau]x_,\[Tau]y_]:=N[
	Sqrt[(\[Sigma]*x+\[Tau]x)^2+(\[Sigma]*y+\[Tau]y)^2]-
	Sqrt[(tx+h1*\[CapitalLambda]1x+h2*\[CapitalLambda]2x)^2+(ty+h1*\[CapitalLambda]1y+h2*\[CapitalLambda]2y)^2]];

	(* Determining scaling factors by iteration *)
	{\[Sigma],\[Tau]x,\[Tau]y}=NonlinearLeastSquares[
	r,data2D,{1000,tx,ty}];
	
	(* Scaling and preparing simulated nodes *)
	xysim1=data2D[[All,{1,2}]];
		xysim1=Round[{\[Tau]x,\[Tau]y}+#&/@(\[Sigma]*xysim1)];
	hksim1=data2D[[All,{3,4}]];
		hksim1=Map[ToMiller,
		Insert[#,SIM1level,{3}]&/@hksim1];

	(* Add tooltip and prepare plot *)
	sim1data=MapThread[Tooltip[#1,#2,
	TooltipStyle->OptionValue["TooltipStyle"]]&,{xysim1,hksim1}];
	
	SIM1=ListPlot[
	sim1data,
	Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	SIM1colour,
	Opacity[SIM1opacity]}}]
	];

	If[SIM1add,
	AppendTo[plots,SIM1]];

(** Plot **)
	plotoptions={
	ImageSize->{OUTx,Floor[1475/1679*OUTx]},
	PlotRange->{{0,1679},{0,1475}},
	AspectRatio->1475/1679,
	ToExpression@OUTframe
	};

	plotaxes=ListPlot[{},plotoptions];
	PrependTo[plots,plotaxes];
	output=Show[plots,plotoptions]
],



(** Manipulation controls **)

	(* Misc initial parameters *)
	{update,False,ControlType->None},

	{OUTx,520,ControlType->None},
	{OUTframe,{"Frame->True"},ControlType->None},

	{LAswitch,False,ControlType->None},
	{LAsize,"Off",ControlType->None},
	{LAimage,"Off",ControlType->None},

	{N1enable,False,ControlType->None},
	{N1switch,False,ControlType->None},
	{N1show,True,ControlType->None},
	{N1colour,ColorData[97,1],ControlType->None},
	{N1opacity,1,ControlType->None},

	{N2enable,False,ControlType->None},
	{N2switch,False,ControlType->None},
	{N2show,True,ControlType->None},
	{N2colour,ColorData[97,2],ControlType->None},
	{N2opacity,1,ControlType->None},

	{N3enable,False,ControlType->None},
	{N3switch,False,ControlType->None},
	{N3show,True,ControlType->None},
	{N3colour,LightGray,ControlType->None},
	{N3opacity,1,ControlType->None},

	{SIM1switch,False,ControlType->None},
	{SIM1colour,ColorData[97,3],ControlType->None},
	{SIM1opacity,1,ControlType->None},
	{SIM1name,"",ControlType->None},
	{SIM1plane,"None",ControlType->None},
	{SIM1level,0,ControlType->None},
	{SIM1res,0.8,ControlType->None},
	{SIM1calc,False,ControlType->None},
	{SIM1add,False,ControlType->None},

	{POswitch,False,ControlType->None},

	{EPswitch,False,ControlType->None},
	{EPformat,"pdf",ControlType->None},
	{EPname,"",ControlType->None},
	{output,True,ControlType->None},


	(* Extracted data *)
	Row[{
	Style["Extracted data",Bold,Medium,16],
	Spacer[160],
	Button["Update",update=True,ImageSize->{65,Automatic}]
	}],
	Delimiter,

		(* Lattice and background *)
		Row[{
		Toggler[Dynamic@LAswitch,{True->#,False->#}&
		@Style["Lattice and background",14]],
		Spacer[5],
		Opener@Dynamic@LAswitch
		}],

		Dynamic@If[LAswitch,
		Panel@Column[{
		Row[{
		Text["Lattice"],
		Spacer[50],
		SetterBar[Dynamic@LAsize,{
		"Off"->"Off",
		1->"Unit vectors",
		2->"1",3->"2",4->"3",5->"4",6->"5",7->"6"}]
		}],

		Row[{
		Text["Background"],
		Spacer[25],
		PopupMenu[Dynamic@LAimage,{
		"Off","Original","Negative","Grayscale",
		"Negative + Grayscale","Binarised"}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Extracted nodes *)
		Dynamic@If[N1enable,
		Row[{
		Toggler[Dynamic@N1switch,{True->#,False->#}&
		@Style["Extracted nodes",14]],
		Spacer[5],
		Opener@Dynamic@N1switch
		}],

		Style["Extracted nodes",14,Gray]
		],

		Dynamic@If[N1switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N1show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N1colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N1opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N1colour=ColorData[97,1];
		N1opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Conditional selection *)
		Dynamic@If[N2enable,
		Row[{
		Toggler[Dynamic@N2switch,{True->#,False->#}&
		@Style["Conditional selection",14]],
		Spacer[5],
		Opener@Dynamic@N2switch
		}],

		Style["Conditional selection",14,Gray]
		],

		Dynamic@If[N2switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N2show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N2colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N2opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N2colour=ColorData[97,2];
		N2opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Wrong nodes *)		
		Dynamic@If[N3enable,
		Row[{
		Toggler[Dynamic@N3switch,{True->#,False->#}&
		@Style["Wrong nodes",14]],
		Spacer[5],
		Opener@Dynamic@N3switch
		}],

		Style["Wrong nodes",14,Gray]
		],

		Dynamic@If[N3switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N3show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N3colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N3opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N3colour=LightGray;
		N3opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

Spacer[{15,15}],


	(* Simulated data *)	
	Style["Simulated data",Bold,Medium,16],
	Delimiter,

		(* Simulation input 1 *)
		Row[{
		Toggler[Dynamic@SIM1switch,{True->#,False->#}&
		@Style["Simulation input",14]],
		Spacer[5],
		Opener@Dynamic@SIM1switch
		}],

		Dynamic@If[SIM1switch,
		Panel@Column[{

		Row[{
		Text["Input data"],
		Spacer[7],
		InputField[
		Dynamic[SIM1name],
		String,
		FieldHint->"Crystal name",
		FieldSize->14]
		}],
		
		Row[{
		Text["Image plane normal"],
		Spacer[3],
		SetterBar[Dynamic@SIM1plane,{
		{{0,1,0},{0,0,1}}->"\!\(\*SuperscriptBox[\(a\), \(*\)]\)",
		{{1,0,0},{0,0,1}}->"\!\(\*SuperscriptBox[\(b\), \(*\)]\)",
		{{1,0,0},{0,1,0}}->"\!\(\*SuperscriptBox[\(c\), \(*\)]\)"
		}],
		Spacer[5],
		Text["intersecting the plane at"],
		Spacer[5],
		PopupMenu[Dynamic@SIM1level,Reverse@Range[-5,5]]
		}],

		Row[{
		Text["Resolution"],
		Spacer[5],
		Slider[Dynamic@SIM1res,{0.1,5.0,0.05}],
		Spacer[5],
		Dynamic[Row[{
		NumberForm[SIM1res,{3,2}],
		" \!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-1\)]\)"}]]
		}],

		Row[{
		Text["Node colour"],
		Spacer[60],
		ColorSlider[Dynamic@SIM1colour,ImageSize->{192,31}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[5],
		Slider[Dynamic@SIM1opacity,{0,1}]
		}],

		Row[{
		Button["Add",SIM1calc=SIM1add=True,
		If[SIM1plane==="None"||SIM1name==="",
		Enabled->False,Enabled->True]],
		Spacer[5],
		Button["Remove",SIM1calc=SIM1add=False]
		}]
		}],
		
			Row[{}]
		],


Spacer[{15,15}],


	(* Image controls *)
	Style["Image controls",Bold,Medium,16],
	Delimiter,

		(* Plot options *)
		Row[{
		Toggler[Dynamic@POswitch,{True->#,False->#}&
		@Style["Plot options",14]],
		Spacer[5],
		Opener@Dynamic@POswitch
		}],

		Dynamic@If[POswitch,
		Panel@Column[{

		Row[{
		Text["Plot size"],
		Spacer[10],
		Slider[Dynamic@OUTx,{320,1024,1}]
		}],

		Row[{
		Text["Pixel dimensions"],
		Spacer[10],
		InputField[Dynamic@OUTx,Number,
		ImageSize->30],
		" \[Times] ",
		Dynamic@Floor[1475/1679*OUTx]
		}],

		Row[{
		Text["Plot frame"],
		Spacer[10],
		SetterBar[Dynamic@OUTframe,{
		{"Frame->True"}->"Frame",
		{"Axes->True"}->"Axes",
		{"Axes->False"}->"None"}]
		}]

	}],

		Row[{}]
		],

		(* Export plot *)
		Row[{
		Toggler[Dynamic@EPswitch,{True->#,False->#}&
		@Style["Export plot",14]],
		Spacer[5],
		Opener@Dynamic@EPswitch
		}],

		Dynamic@If[EPswitch,
		Panel@Column[{

		Row[{
		Text["Filename"],
		Spacer[10],
		InputField[Dynamic@EPname,String,FieldHint->"Name"]
		}],

		Row[{
		Text["File format"],
		Spacer[10],
		SetterBar[Dynamic@EPformat,{"jpg","png","pdf"}]
		}],

		Row[{
		Text["Output directory"],
		Spacer[10],
		Button["Desktop",
		Export[FileNameJoin[{
		$HomeDirectory,"Desktop",
		EPname<>"."<>EPformat}],
		output]
		]
		}]

	}],

		Row[{}]
		],




ControlPlacement->Left,
Paneled->False
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
RefinedValues::label="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised label.";
RefinedValues::log="Search for log files has failed.";
RefinedValues::residue="No residue value found.";
RefinedValues::matrix="No `1` matrix was found.";
RefinedValues::mosaicity="No mosaicity values found in \[LeftGuillemet]`1`\[RightGuillemet].";
RefinedValues::wavelength="No wavelength found in \[LeftGuillemet]`1`\[RightGuillemet].";

Options[RefinedValues]={
"ConstrainedCell"->True,
"Uncertainties"->False,
"Units"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RefinedValues[input_String,label_String,OptionsPattern@RefinedValues]:=Module[{
(* Setup *)
files,import,
constrained,uncertainties,units,
allvalues,take,
(* 'Refinement' *)
n0,n,r,
(* 'Wavelength' *)
\[Lambda],c,cInverse,
(* 'InstrumentModel' *)
lattice,latticeU,X,x,\[Delta],
goniometer,detector,rotation,instrument,parameters,
(* 'UB', 'U' and 'B' *)
UB,
(* 'Angles' *)
num,angles,\[Alpha]\[Beta],\[Omega],\[Theta],\[Kappa],\[Phi],
(* 'CorrelationMatrix' *)
m,tags,
(* Miscellaneous *)
temp
},
(*---* Setup *---*)
	(* Label check *)
	If[!MemberQ[{
	"Refinement","UnitCell","Wavelength",
	"InstrumentModel","UB","U","B","Mosaicity",
	"Angles","CorrelationMatrix"},label],
	Message[RefinedValues::label,label];Abort[]];

	(* Input check *)
		(* Scenario 1: Log information given directly *)
		Quiet@If[
		StringTake[input,27]=="Your current setup file is:",
		import=input;
		Goto["ImportDone"]];

		(* Scenario 2: Single log file given *)
		If[FileExistsQ[input]&&StringTake[input,-3]=="txt",
		import=Import[input,"String"];
		Goto["ImportDone"]];

		(* Scenario 3: Log- or project directory given *)
		files=FileNames["*.txt",{input},3];
		If[DirectoryQ[input]&&files!={},
		import=MergeLogs[input];
		Goto["ImportDone"]];		

		(* Finding log failed *)
			Message[RefinedValues::log];
			Goto["End"];

	(* Preparations common for all tasks *)
	Label["ImportDone"];

		(* Options *)
		constrained=OptionValue["ConstrainedCell"];
		uncertainties=OptionValue["Uncertainties"];
		units=OptionValue["Units"];

		(* Making a list to store all the values in *)
		allvalues=<||>;

	Goto[label];


(*---* 'Refinement' *---*)
Label["Refinement"];

	(* Extracting the number of reflections, initially and finally *)
	n0=First@StringCases[import,
	Shortest["UB fit with "~~__~~"out of "~~n0:DigitCharacter..~~" "]:>n0];
	n=Last@StringCases[import,
	Shortest["UB fit with "~~n:DigitCharacter..~~" "]:>n];
	{n0,n}=ToExpression[{n0,n}];
	AppendTo[allvalues,{"ReflectionsInitial"->n0,"ReflectionsFinal"->n}];

	(* Extracting the latest residue parameter *)
	r=StringCases[import,
	"Resid:"~~" "..~~r:{DigitCharacter,"-","."}..:>r];
	If[r=={},Message[RefinedValues::residue];Abort[]];
	r=ToExpression@Last@r;

	(* Optional: Units *)
	If[units,r=100*r;r=Quantity[r,"Percent"]];

	AppendTo[allvalues,"Rint"->r];

Return@allvalues;


(*---* 'UnitCell' *---*)
Label["UnitCell"];

	(* Finding and extracting the lattice parameters *)
	Quiet[
	lattice=StringCases[import,
	Shortest["unit cell:"~~__~~"V"~~__~~EndOfLine]];

		(* Constrained or non-constrained cell *)
		If[constrained,take=-1,take=-2];
		lattice=StringCases[lattice[[take]],
		{DigitCharacter,"-",".","(",")"}..][[;;6]];

		latticeU={};
		Do[
		X=StringCases[lattice[[i]],{DigitCharacter,"-","."}..];
		If[Length[X]==2,
			(* Uncertainty given *)
			x=X[[1]];
			\[Delta]=ToExpression@X[[2]];
			temp=StringLength@First@
			StringCases[x,"."~~n:(DigitCharacter..):>n];
			X={x,N[\[Delta]*10^(-temp)]},

			(* No uncertainty *)
			X=Flatten[{X,0.}]
			];
		AppendTo[latticeU,X],
		{i,Length@lattice}
		];

	(* Optional: Units *)
	temp=<|Thread[{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}->latticeU]|>;
	If[units,
	lattice=Quantity[#,"Angstroms"]&/@temp[[{"a","b","c"}]];
	angles=Quantity[#,"Degrees"]&/@temp[[{"\[Alpha]","\[Beta]","\[Gamma]"}]];
	temp=Join[lattice,angles]];

	(* Optional: Uncertainties *)
	If[!uncertainties,temp=temp[[All,1]]];	

Return@temp];


(*---* 'Wavelength' *---*)
Label["Wavelength"];

	temp=StringCases[import,
	"wavelength: "~~\[Lambda]:{DigitCharacter,"."}..:>\[Lambda]];
	temp=DeleteCases[temp,{}];
	(* Check *)
	If[temp=={},
	(* Exploit that UB is scaled by wavelength *)
	UB=RefinedValues[input,"UB"];
	cInverse=(QRDecomposition@UB)[[-1,-1,-1]];
	c=ToExpression@RefinedValues[input,"UnitCell"]["c"];
	\[Lambda]=Abs[c*cInverse],

	(* Extract directly *)
	\[Lambda]=ToExpression@First@Flatten@temp
	];	

	(* Optional: Units *)
	If[units,\[Lambda]=Quantity[\[Lambda],"Angstroms"]];

Return@\[Lambda];


(*---* 'InstrumentModel' *---*)
Label["InstrumentModel"];

	(* Finding and extracting goniometer and detector data *)
		rotation={
		"Cryst. Rot. X","Cryst. Rot. Y","Cryst. Rot. Z",
		"Cryst. Dance X","Cryst. Dance Y","Cryst. Dance Z"};
		goniometer={
		"Beam. Rot. Y","Beam. Rot. Z",
		"Alpha Value","Beta Value",
		"Omega Offset","Theta Offset","Kappa Offset","Phi Offset"};
		detector={
		"Det. Rot. X","Det. Rot. Y","Det. Rot. Z",
		"Det. Offset X","Det. Offset Y","Det. D. Scale"};
		instrument={rotation,goniometer,detector};
	
		Quiet[
		parameters=Last@DeleteCases[StringCases[import,
#~~" "..~~
v1:{DigitCharacter,"-","."}..~~" "..~~
v2:{DigitCharacter,"-","."}..:>v2],
	x_/;StringLength[x]<=5]&/@#&/@instrument;

		AppendTo[allvalues,
		"Rotation"->Association@
		Thread[{"r1","r2","r3","w1","w2","w3"}->
		parameters[[1]]
	]];
		AppendTo[allvalues,
		"Goniometer"->Association@
		Thread[{"b2","b3","al","be","o0","t0","k0","p0"}->
		parameters[[2]]
	]];
		AppendTo[allvalues,
		"Detector"->Association@
		Thread[{"d1","d2","d3","x0","y0","dd"}->
		parameters[[3]]
	]];

Return@ToExpression@allvalues];


(*---* 'UB' *---*)
Label["UB"];

	(* Extracting the UB matrix *)
	If[StringContainsQ[import,"UM S "~~{"-",DigitCharacter}],
	(* Preferred pattern *)
		UB=AlignUB@Last@
	StringCases[import,Shortest[
	"UM S "~~{"-",DigitCharacter}~~__~~EndOfLine]],

	(* Other method *)
		(* Check *)
		If[!StringContainsQ[import,"UB - matrix:"],
		Message[RefinedValues::matrix,"UB"];Goto["End"]];

		UB=Partition[StringCases[Last@
	StringCases[import,Shortest["UB - matrix:"~~
m:(__~~Repeated[EndOfLine~~__,{3}])]:>m],{DigitCharacter,".","-"}..][[{1,2,3,7,8,9,13,14,15}]],3]
	];

Return@ToExpression@Chop[ToExpression@UB,10^-5];


(*---* 'U' or 'B' *---*)
Label["U"];Label["B"];
x=label;

	(* Check *)
	If[!StringContainsQ[import," "~~x~~" - matrix"],
	Message[RefinedValues::matrix,x];
	Goto["End"]];

	(* Extracting the matrix *)
	temp=StringCases[import,
	Shortest[" "~~x~~" - matrix:"~~
	m:(__~~Repeated[EndOfLine~~__,{4}])]:>m];
	temp=StringCases[Last@temp,
	{DigitCharacter,".","-"}..];
	temp=ToExpression@Partition[temp,3];
	temp=Chop[temp,10^-5];

Return@temp;


(*---* 'Mosaicity' *---*)
Label["Mosaicity"];

	(* Extracting the mosaicities *)
		(* Check *)
		If[!StringContainsQ[import,"Profile size analysis"],
		Message[RefinedValues::mosaicity,FileNameTake@input];
		Goto["End"]];
	
	temp=Last@StringCases[import,
	Shortest["Profile size analysis"~~__~~"|\n\n"]];
	temp=StringExtract[temp,-13;;];
	temp=StringCases[temp,
	DigitCharacter..~~"."~~DigitCharacter..];
	temp=ToExpression@Partition[Flatten@temp,2];

	(* Optional: Units *)
	temp=Quantity[temp,"Degrees"];
	temp=Association@Thread[{"e1","e2","e3"}->temp];
	
	(* Optional: Uncertainties *)
	If[!OptionValue["Uncertainties"],temp=temp[[All,1]]];

Return@temp;


(*---* 'Angles' *---*)
Label["Angles"];

	(* Extracting the diffractometer angles *)
	temp=ToExpression@Last@DeleteCases[StringCases[import,
#~~" "..~~
v1:{DigitCharacter,"-","."}..~~" "..~~
v2:{DigitCharacter,"-","."}..:>v2],
	x_/;StringLength[x]<=5]&/@
	{"Alpha Value","Beta Value"};

	(* Extracting the goniometer angles *)
	num={DigitCharacter,".","-"}..;
	AppendTo[temp,ToExpression@First@StringCases[import,
"om="~~Whitespace~~\[Omega]:num~~WhitespaceCharacter...
~~"th="~~Whitespace~~\[Theta]:num~~WhitespaceCharacter...
~~"ka="~~Whitespace~~\[Kappa]:num~~WhitespaceCharacter...
~~"ph="~~Whitespace~~\[Phi]:num~~WhitespaceCharacter...
:>{\[Omega],\[Theta],\[Kappa],\[Phi]}]];
	temp=Flatten@temp;

	(* Optional: Units *)
	If[units,temp=Quantity[temp,"Degrees"]];

	temp=Association@
	Thread[{"\[Alpha]","\[Beta]","\[Omega]","\[Theta]","\[Kappa]","\[Phi]"}->temp];

Return@temp;


(*---* 'CorrelationMatrix' *---*)
Label["CorrelationMatrix"];

	temp=Last@StringTrim@StringCases[import,
Shortest["Correlation matrix:"~~x__
	~~"                 "]:>x];

	tags=StringTrim@StringCases[temp,
	x:(LetterCharacter~~{LetterCharacter," ",".","*"}..):>x];
	tags=StringReplace[tags,{
	"Det. D. Scale"->"dd",
	"Det. Offset X"->"x0",
	"Det. Offset Y"->"y0",
	"Det. Rot. X"->"d1",
	"Det. Rot. Y"->"d2",
	"Det. Rot. Z"->"d3",
	"Beam. Rot. Y"->"b2",
	"Beam. Rot. Z"->"b3",
	"Cryst. Rot. X"->"r1",
	"Cryst. Rot. Y"->"r2",
	"Cryst. Rot. Z"->"r3",
	"Rec. latt. "~~x__:>x
	}];

	temp=StringTrim@StringCases[temp,Shortest[
{"-",DigitCharacter}~~__~~EndOfLine]];
	temp=ToExpression/@StringSplit[temp,Whitespace];
	m=PadRight[temp,{#,#}]&@Length@tags;

Return[{tags,m}];


(*---* Return message and end procedure *---*)
Label["End"];
]


(* ::Input::Initialization:: *)
RefinedValues[input_String,OptionsPattern@RefinedValues]:=Module[{log},
log=MergeLogs@input;

Association[Quiet[#->RefinedValues[log,#,
"ConstrainedCell"->OptionValue["ConstrainedCell"],
"Uncertainties"->OptionValue["Uncertainties"],
"Units"->OptionValue["Units"]
]]&/@{
	"Refinement","UnitCell","Wavelength",
	"InstrumentModel","UB","U","B","Mosaicity",
	"Angles","CorrelationMatrix"}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options@RoundSignificantFigures={
"Prefix"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RoundSignificantFigures[{x_?NumericQ,\[Delta]x_?NumericQ},
OptionsPattern@RoundSignificantFigures]:=Module[{
a,\[Delta],\[Delta]1,\[Delta]2,p1,p2,d,X,\[Delta]X,postfix,output,temp},

(* Extract first two signigicant figures of uncertainty *)
\[Delta]=SetPrecision[\[Delta]x,2];
{\[Delta]1,\[Delta]2}=First@RealDigits@\[Delta];

(* Determining difference in order of magnitude *)
{p1,p2}=(RealDigits[#][[2]]-1)&/@{x,\[Delta]x};
d=p1-p2+1;

Which[
(* Rounding to one digit + zero *)
\[Delta]1==9&&MemberQ[Range[5,9],\[Delta]2],
	X=SetPrecision[x,d];
	\[Delta]X=SetPrecision[Round[\[Delta]x,10^p2],2],

(* Rounding to two digits *)
\[Delta]1==1&&MemberQ[Range[0,5],\[Delta]2],
	X=SetPrecision[x,d+1];
	\[Delta]X=\[Delta],

(* Rounding to one digit *)
True,
	X=SetPrecision[x,d];
	\[Delta]X=SetPrecision[\[Delta]x,1]
];

(* Chopping result *)
output={X,\[Delta]X};

(* Optional: Replace powers with appropriate SI prefix *)
If[OptionValue["Prefix"],
If[Divisible[p1,3]&&p1!=0&&d<=6,
postfix=Which[
p1==-12,"pico",
p1==-9,"nano",
p1==-6,"mikro",
p1==-3,"milli",
p1==3,"kilo",
p1==6,"mega",
p1==9,"giga",
p1==12,"tera"
];

X=X/10^p1;
\[Delta]X=\[Delta]X/10^p1;
output="("<>ToString@X<>" \[PlusMinus] "<>ToString@\[Delta]X<>") "<>postfix
]
];

output
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
UnwarpLayerList::dir="The direction vector must be three-dimensional and numeric.";
UnwarpLayerList::dep="The layer vectors are not linearly independent.";
UnwarpLayerList::dim="One or both of the layer vectors are not three dimensional.";
UnwarpLayerList::extended="\[LeftGuillemet]`1`\[RightGuillemet] has been extended.";
UnwarpLayerList::jobs="Some unwarping jobs are identical. Try increasing the range or step size.";
UnwarpLayerList::steps="\!\(\*
StyleBox[\"CrysAlis\",\nFontSlant->\"Italic\"]\) will only queue 500 jobs at a time.";
UnwarpLayerList::small="Some values are smaller than \!\(\*SuperscriptBox[\(10\), \(-6\)]\).";
UnwarpLayerList::path="\[LeftGuillemet]`1`\[RightGuillemet] is an invalid path.";
UnwarpLayerList::notfound="No existing \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"dcunwarp\", \"Program\"]\) file was found in the export directory.";

Options[UnwarpLayerList]={"ExportDirectory"->FileNameJoin[{$HomeDirectory,"Desktop"}],"AppendToExisting"->False,
"SeparationCommas"->True};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
UnwarpLayerList[
prefix_String,L1_List,L2_List,
{dir_List,start_,end_,stepinput_?NumericQ},
Res_,OptionsPattern[UnwarpLayerList]]:=Module[
{steps,path,output,
len,replacerule,\[Delta],
MakeValue,OriginVector,
const,MakeName,
newL1,newL2,res,line,original,old,new,j,valuestest,
temp},
(* Checking input vectors *)
	If[Length/@Flatten/@{L1,L2}!={3,3},Message[UnwarpLayerList::dim];Abort[]];

(* Ascertaining steps or stepsize *)
	If[stepinput>1,
	steps=stepinput,
	steps=Round[Abs[end-start]/stepinput+1]];

(* Check resolution of the range *)
	If[Abs[end-start]/steps<10^-6-10^-12,Message[UnwarpLayerList::jobs]];
	If[steps>500,Message[UnwarpLayerList::steps]];

(* Path check and setup *)
	path=OptionValue["ExportDirectory"];
	If[!DirectoryQ@path,Message[UnwarpLayerList::path,path];Abort[];];
	output=FileNameJoin[{path,prefix<>".dcunwarp"}];


(* Useful variables *)
	len=StringLength@ToString@steps;
	replacerule={","->"  ",{"{","}"}->""};
	\[Delta]=Min[6,StringLength@ToString@N[(end-start)/(steps-1)]-2];

(* Check if vectors are linearly independent *)
	If[Det[{{L1.L1,L1.L2},{L2.L1,L2.L2}}]==0,
	Message[UnwarpLayerList::dep];Abort[]];

(*---* Making the origin vectors *---*)
	(* Check input form *)
	If[!MatchQ[dir,{_?NumericQ,_?NumericQ,_?NumericQ}],
	Message[UnwarpLayerList::dir]Abort[]];

	MakeValue[i_]:=start+(end-start)/(steps-1)*(i-1);

	OriginVector[i_]:=(
	temp=dir*MakeValue[i];
	temp=AccountingForm@NumberForm[N[temp],{Infinity,6}];
	temp=StringReplace[ToString@temp,replacerule]
	);

	(* Check for duplicates and values smaller than 10^-6 *)
	valuestest=ToString/@Table[MakeValue[j],{j,steps}];
	If[!DuplicateFreeQ@valuestest,Message[UnwarpLayerList::small]];


(*---* Generating names *---*)
	(* Integer Miller indices *)
	const=dir+{"h","k","l"}/.a_+b_->0;

	(* Procedure *)
	MakeName[i_]:=(
	temp=ToExpression@StringSplit@OriginVector[i];
	If[\[Delta]==0,(* Integers only? *)
	temp=Rationalize@temp,
	temp=NumberForm[
	#,{Infinity,\[Delta]},
	ExponentFunction->(Null&)]&/@temp];
	temp=const+temp/.x_String+y_:>x;
	If[OptionValue["SeparationCommas"],
	(* Remove separating commas? *)
	temp=StringRiffle[ToString/@temp,","],
	temp=ToString/@temp];
	StringJoin["\"",prefix,"_(",temp,")\""]
	);

(* The L1 and L2 vectors *)
	newL1=StringReplace[ToString@NumberForm[L1,{Infinity,6}],replacerule];
	newL2=StringReplace[ToString@NumberForm[L2,{Infinity,6}],replacerule];

(* The resolution *)
	res=ToString@NumberForm[Res,{Infinity,6}];

(* Function that writes a single line *)
	line[i_]:=StringJoin[MakeName[i],"   ",OriginVector[i],"     ",newL1,"     ",newL2,"        ",res,"       ","0","       ","0"];

(* Generating and exporting table *)
	If[OptionValue["AppendToExisting"],
	original=FileNames[OptionValue["ExportDirectory"]<>"/*.dcunwarp"];
	If[original=={},Message[UnwarpLayerList::notfound];Abort[]];
	old=Import[First@original,"String"];
	new=Table[line[i]<>If[i<steps,"\n",""],{i,steps}];
	Export[original,old<>If[StringTake[old,-1]=="0","\n",""]<>new,"String"];
	Message[UnwarpLayerList::extended,FileNameTake@First@original],	

	Export[output,Table[line[i],{i,steps}],"Table"]]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
WeightedMean::numeric="Numeric input only.";
WeightedMean::invalid="Invalid input form.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
WeightedMean[data_List]:=Module[{
n,sum,x,d,\[Sigma],m,
w,sumw,sumxw,wx,sumxn,\[Sigma]i,\[Sigma]e},

(** Check input **)
	If[!AllTrue[Flatten@data,NumericQ],
	Message[WeightedMean::numeric];Abort[]];

	Which[
	Depth[data]==2,Goto["WithoutWeights"],
	MatchQ[Dimensions[data],{_,2}],Goto["WithWeights"],
	True,Message[WeightedMean::invalid];Abort[]];

(** Data without weights **)
	Label["WithoutWeights"];

	(* Useful variables *)
	n=Length@data;
		If[n==1,
		Return[{First@data,Indeterminate,Indeterminate}]];
	sum=N@Total@data;
	x=sum/n;
	d=data-x;

	(* Standard deviations *)
	\[Sigma]=Sqrt[Total[d^2]/(n-1)];
	m=\[Sigma]/Sqrt[n];

	Return[{x,\[Sigma],m}];

(** Data with weights **)
	Label["WithWeights"];

	(* Useful variables *)
	n=Length@data;
		If[n==1,
		Return[{data[[1,1]],Indeterminate,data[[1,2]]}]];
	{x,\[Sigma]}=N@Transpose@data;
	w=1/\[Sigma]^2;
	sumw=Total[w];
	sumxw=x.w;

	wx=sumxw/sumw;

	(* Standard deviation (internal) *)
	\[Sigma]i=1/Sqrt[sumw];

	(* Standard deviation (external) *)
	d=x-wx;
	sumxn=w.d^2;
	\[Sigma]e=Sqrt[sumxn/((n-1)*sumw)];

	Return[{wx,\[Sigma]i,\[Sigma]e}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$PixelData=Association[];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
