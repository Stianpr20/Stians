(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Start package context Stians` *)
BeginPackage["Stians`"];

(* Import any usage messages *)
If[!FailureQ@FindFile[#],Get@FindFile[#]]&["Stians/Messages.txt"]


(* ::Input::Initialization:: *)
(* Start subcontext *)
Begin["`FileOperations`"];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ChangeExtension[input_,newext_String]:=
Module[{path,file,extension,name,output},
(* Input metadata *)
	path=DirectoryName@input;
	file=FileNameTake@input;

(* Extracting extension and preparing output *)	extension=First@StringReverse@StringCases[StringReverse@file,__~~".",1];
	name=StringDrop[file,-StringLength@extension];
	output=StringJoin[path<>name<>"."<>newext];

RenameFile[input,output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyncSpellings::one="Input consists of only one dictionary.";
SyncSpellings::missing="File \[LeftGuillemet]`1`\[RightGuillemet] was not found.";
SyncSpellings::done="Update`1` completed.";
SyncSpellings::inv="Invalid input format.";

Options[SyncSpellings]={"Remove"->{}};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SyncSpellings[input__String,OptionsPattern[SyncSpellings]]:=Module[{checked,new,remove,afterfilter},
(* Checking input *)
	If[checked,Goto["checked"]];
	If[Length[{input}]==1,Message[SyncSpellings::one];Abort[]];
	If[!FileExistsQ[#],Message[SyncSpellings::missing,#];Abort[]]&/@{input};

(* Merging dictionaries *)
	Label["checked"];
	new=Sort@DeleteDuplicates@Flatten[StringSplit@Import[#,"Text"]&/@{input}];

(* Optional: Remove word(s) from the dictionary *)
	If[Depth[#]==1,remove={#},remove=#]&@OptionValue["Remove"];
	afterfilter=DeleteCases[new,x_/;MemberQ[remove,x]];

(* Rewriting the old files with the new version *)
	Export[#,afterfilter,"Text"]&/@{input};

Message[SyncSpellings::done,""]
]


(* ::Input::Initialization:: *)
SyncSpellings[input__List]:=Module[{all,depthcheck,checked},
(* Checking input *)
	all={input};
	depthcheck=DeleteCases[all,"Remove"->_List,{2}];
	If[Depth[depthcheck]!=3,Message[SyncSpellings::inv];Abort[]];
	If[!FileExistsQ[#],Message[SyncSpellings::missing,#];Abort[]]&/@Flatten@depthcheck;

(* Processing each dictionary batch *)
	Off[SyncSpellings::done];
	checked=True;
	Do[SyncSpellings@@all[[i]],{i,Length@all}];
	On[SyncSpellings::done];

Message[SyncSpellings::done,"s"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyncTexitEasy::done="TexitEasy configuration files were copied successfully from `1` to `2`.";
SyncTexitEasy::uptodate="Nothing to update.";

Options@SyncTexitEasy={
"LocalPaths"-><|
"MacOSX"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud"|>,
"ShowDialogue"->True,
"ForceCopyFrom"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SyncTexitEasy[OptionsPattern@SyncTexitEasy]:=Module[{
cloudDir,dialogueQ,
configDirSystem,libraryDirSystem,configDirCloud,libraryDirCloud,
dirs,configDir,libraryDir,
forceOpt,files,top,newest,newestSource,copyFrom,
buttonRow,
temp
},
(* Check local paths *)
cloudDir=OptionValue["LocalPaths"][$OperatingSystem];
dialogueQ=OptionValue["ShowDialogue"];

(* Directories *)
configDirSystem="/Users/Stian/.config/texiteasy.com";
libraryDirSystem="/Users/Stian/Library/Application Support/TexitEasy/TexitEasy";
configDirCloud=FileNameJoin[{
cloudDir,"Prosjekter/Programoppsett/TexitEasy-oppsett"}];
libraryDirCloud=FileNameJoin[{
cloudDir,"Prosjekter/Programoppsett/TexitEasy-oppsett/Bibliotek-mappe"}];

dirs={
configDirSystem,libraryDirSystem,
configDirCloud,libraryDirCloud
};

configDir=FileNameJoin[{configDirCloud,"Config-mappe"}];
libraryDir=FileNameJoin[{configDirCloud,"Bibliotek-mappe"}];

	(* Option: Force copy *)
	forceOpt=OptionValue["ForceCopyFrom"];
	Which[
	forceOpt==="System",copyFrom="System";Goto["Copy"],
	forceOpt==="Cloud",copyFrom="Cloud";Goto["Copy"]];

	(* Any directories missing? *)
	If[!AllTrue[dirs[[{1,2}]],DirectoryQ],
	copyFrom="Cloud";
	If[dialogueQ,Goto["Dialogue"],Goto["Copy"]]];
	If[!AllTrue[dirs[[{3,4}]],DirectoryQ],
	copyFrom="System";
	If[dialogueQ,Goto["Dialogue"],Goto["Copy"]]];

(* Find newest; 'push' to cloud or 'pull' from cloud *)
files=FileNames["*",{#},Infinity]&/@dirs;
	(*files=DeleteCases[files,x_/;StringTake[#,1]==="."&,Infinity];*)
top=Check[
	Flatten[TakeLargestBy[#,(FileDate[#,"Modification"]&),1]&/@files],
	Abort[]];
	(* Nothing new? *)
	If[!dialogueQ&&Abs[Subtract@@(
UnixTime@FileDate[top[[#]],"Modification"]&/@{2,4}
)]<30,
	Message[SyncTexitEasy::uptodate];Goto["End"]];
newest=First@TakeLargestBy[top,(FileDate[#,"Modification"]&),1];
newestSource=Select[dirs,StringContainsQ[DirectoryName@newest,#]&];
copyFrom=If[SubsetQ[{configDirSystem,libraryDirSystem},newestSource],"System","Cloud"];

(* Dialogue *)
Label["Dialogue"];
temp=If[copyFrom==="System",{"System","Cloud"},{"Cloud","System"}];

buttonRow={Spacer[200],
DefaultButton[#1,DialogReturn[#1]],
Spacer[5],
Button[#2,DialogReturn[#2]]}&@@temp;

copyFrom=DialogInput[
Column[{Style[
"Choose where to copy from.\nMost recently modified: "<>copyFrom,13],
Spacer[20],
Row[buttonRow]
}],
WindowTitle->"Sync TexitEasy settings"];

If[copyFrom===$Failed,Abort[]];

(* Delete and copy *)
Label["Copy"];
If[
copyFrom==="System",
(* 'System' --> 'Cloud' *)
DeleteDirectory[configDirCloud,DeleteContents->True];
CreateDirectory[configDirCloud];
CopyDirectory[configDirSystem,configDir];
CopyDirectory[libraryDirSystem,libraryDir],

(* 'Cloud' --> 'System' *)
DeleteDirectory[configDirSystem,DeleteContents->True];
CopyDirectory[configDir,configDirSystem];
DeleteDirectory[libraryDirSystem,DeleteContents->True];
CopyDirectory[libraryDir,libraryDirSystem]
];

(* Report *)
temp={"system","cloud"};
If[copyFrom==="Cloud",temp=Reverse@temp];

Message[SyncTexitEasy::done,temp[[1]],temp[[2]]];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetWallpapers::noNew="No new images found.";
GetWallpapers::invURL="Invalid URL.";

Options@GetWallpapers={
"DownloadDirectory"->"/Users/Stian/Pictures/InterfaceLIFT (2560x1440)",
"Resolution"->"2560x1440",
"PageIndex"->1
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetWallpapers[OptionsPattern@GetWallpapers]:=Module[{
url,resolution=OptionValue["Resolution"],htmlData,itemData,
downloadDir=OptionValue["DownloadDirectory"],
imageIDs,archivedIDs,newIDs,
archived,newTitles,
commentData,thumbnailData,downloadURLdata,data,
userSelected,
n,k,
temp},

(*---* A. Organising archived images and URL data *---*)
(* A.1. Fetching latest wallpapers from InterfaceLift.com *)
url="https://interfacelift.com/wallpaper/downloads/date/wide_16:9/"<>resolution<>"/index"<>ToString@OptionValue["PageIndex"]<>".html";
htmlData=Check[
URLRead[url,"Content"],
Return@url];
If[Head@htmlData===Failure,Return@htmlData];

itemData=Association@StringCases[htmlData,Shortest[
"<div id=\"list_"~~Longest[idNumber:DigitCharacter..]~~__~~
		"High-resolution desktop wallpaper "~~
title__~~" by"
]:>{ToExpression@idNumber->StringDelete[title,{"!","..."}]}];

imageIDs=Keys@itemData;

(* A.2. Check with storage directory to see if already downloaded *)
archived=FileNames["*.jpg"~~{"",".icloud"},{downloadDir}];
archived=FileNameTake/@archived;

archivedIDs=Flatten@StringCases[archived,
Shortest["("~~idNumber:DigitCharacter..~~")"
]:>ToExpression@idNumber];

newIDs=Complement[imageIDs,archivedIDs];

	(* End if no new images *)
	If[newIDs==={},Message[GetWallpapers::noNew];
	Goto["End"]];

itemData=KeySelect[itemData,MemberQ[newIDs,#]&];
itemData=StringReplace[#,{"/","\\"}->"-"]&/@itemData;
newTitles=Values@itemData;

(* A.3. Photographers' comments *)
commentData=Association@StringCases[
htmlData,Shortest[
"<div class=\"details\""~~__~~
"/wallpaper/details/"~~idNumber:(ToString/@newIDs)~~__~~
"<"~~__~~"<p>"~~comment___~~"</p>"]
:>{ToExpression@idNumber->StringTrim@comment},
IgnoreCase->True];

(* A.4 Thumbnails of new images *)
thumbnailData=Association@StringCases[htmlData,Shortest[
"<div id=\"list_"~~Longest[idNumber:DigitCharacter..]~~__~~
		url:("http://interfacelift.com/wallpaper/previews/"~~__~~"672x420.jpg")]
:>{ToExpression@idNumber->url}];
thumbnailData=KeySelect[thumbnailData,MemberQ[newIDs,#]&];
thumbnailData=URLExecute/@thumbnailData;

(* A.5 URL preparations *)
downloadURLdata=StringCases[htmlData,Shortest[
url:("href=\"/wallpaper/"~~Except[WhitespaceCharacter]..~~
"/"~~IntegerString[newIDs,10,5]~~__~~resolution<>".jpg")
]:>StringReplace[url,"href=\""->"https://interfacelift.com"]];
temp=Flatten@StringCases[downloadURLdata,
Shortest["/wallpaper/"~~__~~"/0"~~id:DigitCharacter..~~"_"]:>id];
downloadURLdata=Association@Thread[
ToExpression@temp->downloadURLdata];

(* A.6. Merging data associations *)
data=Merge[{itemData,thumbnailData,commentData,downloadURLdata},Identity];
data=SortBy[data,#0&];


(*---* B. Selection and download of images *---*)
(* B.1. Function for displaying thumbnails *)
i=1;
L=Length@data;
userSelected={};
f[i_]:=ChoiceDialog[Column[{
Style[data[[i,1]],24,FontFamily->"Avenir Next"],
Show[data[[i,2]],ImageSize->750],
Style[data[[i,3]],14,FontFamily->"Avenir Next",LineIndent->0]
}],
{
"Queue"->True,
"Skip"->False},
WindowTitle->"Wallpaper selection",
WindowSize->{750,All}
];
Label["Return"];
AppendTo[userSelected,f[i]];i++;
If[i<=L,Goto["Return"]];

userSelected=Pick[data,userSelected,True];

	(* None selected? *)
	If[userSelected===<||>,
	Message[GetWallpapers::noNew];Goto["End"]];

temp=Check[userSelected[[All,{1,4}]],Abort[]];

(* B.2 Download *)
(* Dynamic status *)
n=0;
k=Length@temp;

PrintTemporary[
Row[
{Text[Style["Wallpaper download progress:",FontFamily->"Avenir Next",16]],
Spacer[20],
Dynamic@ProgressIndicator[n/k],
Spacer[20],

Dynamic[Text[Style["Downloaded: "<>ToString[n]<>" of "<>ToString[k],FontFamily->"Avenir Next",12]]]
},
Alignment->Center
]];

(* Actual download *)
Do[
URLSave[temp[[i,2]],FileNameJoin[{downloadDir,
"("<>ToString[(Keys@temp)[[i]]]<>") "<>
temp[[i,1]]<>".jpg"}]
];
n++,
{i,Length@temp}];

(* Messages *)
If[temp==={},
Print[Text[Style["All images already downloaded",FontFamily->"Avenir Next",16]]],
Print[Text[Style["Download completed",FontFamily->"Avenir Next",16]]]
];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GifGenerator::names="Invalid dimensions of custom name list.";
GifGenerator::namestring="Some of the names are not strings.";
GifGenerator::invalid="Invalid \[LeftGuillemet]Names\[RightGuillemet] option.";
GifGenerator::format="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";

Options@GifGenerator={
"Time"->0.1,
"GifName"->False,
"OutputDirectory"->False,
"Format"->"gif",
"BackwardsLoop"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GifGenerator[input_List,OptionsPattern@GifGenerator]:=Module[{
L,autoimport,format,
data,progress,image,
data1,data2,
gifname,dir,random,temp},

(* Checking input form *)
	L=Length@input;
		Off[FileExistsQ::fstr];
	If[Check[FileExistsQ@First@input,Abort[]],
	autoimport=True,
	autoimport=False,
	autoimport=False];
		On[FileExistsQ::fstr];

	format=OptionValue["Format"];
	If[!MemberQ[{"gif","mp4"},format],
	Message[GifGenerator::format,format]];

(* Importing data if necessary *)
	If[autoimport,
	(* Dynamic status *)
	data={};
	progress=0;
	PrintTemporary[
	Row[
	{Text[Style["Image import progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Imported: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

	Do[
	image=Import@input[[i]];
	AppendTo[data,image];
	progress++,
	{i,L}],	

	(* No import *)
	data=input];

(* Optional: Backwards loop *)
	If[OptionValue["BackwardsLoop"],
	data1=data;
	data2=Rest@Reverse@data;
	data=Join[data1,data2]
	];

(* Making the name of the gif *)
	If[ImageQ[First@input],
	gifname="output",
	If[StringContainsQ[FileNameTake@First@input,"_"],
	gifname=StringDrop[First@StringCases[FileNameTake@First@input,__~~"_"],-1],
	gifname="output"]];

	If[StringQ@OptionValue["GifName"],gifname=OptionValue["GifName"]];

(* Checking output directory *)
	If[autoimport,
	(* Use source directory *)
		dir=FileNameTake[First@input,{1,-2}],
	(* Use desktop *)
		dir=FileNameJoin[{$HomeDirectory,"Desktop"}]
	];

	If[OptionValue["OutputDirectory"],Null,Null,dir=OptionValue["OutputDirectory"]];

(* Optional: Exporting to a .mp4 video *)
	If[format==="mp4",
	random=ToString@RandomInteger[10^10];
	temp=FileNameJoin[{dir,"tempname"<>random<>".mov"}];
	Export[
	temp,
	data,
	"VideoEncoding"->"MPEG-4 Video",
	"FrameRate"->1/OptionValue["Time"]];
	
	Return@RenameFile[
	temp,
	FileNameJoin[{dir,gifname<>".mp4"}],
	OverwriteTarget->True]
	];

(* Exporting gif *)
	If[format==="gif",
	Return@Export[
	FileNameJoin[{dir,gifname<>".gif"}],
	data,
	"DisplayDurations"->OptionValue["Time"]]
	];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
TagImages::images="Some of the images or file paths were invalid.";
TagImages::tags="Invalid dimensions of tag list.";
TagImages::tagstrings="Some of the tags are not strings.";
TagImages::format="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";

Options@TagImages={
"ExportTo"->"InputDirectory",
"Style"->{White,"Inconsolata",54},
"ImageFormat"->"png",
"NewName"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
TagImages[input_,tags_List,OptionsPattern@TagImages]:=
Module[{
images,type,L,
tagsLB,tagsRB,progress,i,firstimage,dim,Lspace,Rspace,Bspace,
oldbasename,newnamesf,newnames,nnOption,
inputdir,outputdir,format,
s1,s2,s3,image,new1,new2},

(* Checking input form *)
	images=Flatten[{input}];
	Which[
	AllTrue[images,ImageQ],
		type="image",
	AllTrue[images,FileExistsQ],
		type="string",	
	True,Message[TagImages::images];Abort[]
	];
	
	L=Length@images;

	(* Check format of tags *)
	If[Not[Dimensions[tags]=={L,2}],
	Message[TagImages::tags];Abort[]];

	If[!AllTrue[Flatten@tags,StringQ],
	Message[TagImages::tagstrings];Abort[]];

	(* Check image output format *)
	format=ToLowerCase@OptionValue["ImageFormat"];
	format=StringReplace[format,"jpeg"->"jpg"];
	If[!MemberQ[{"jpg","png"},format],
	Message[TagImages::format,format];Abort[]];

(* Preparing *)
	tagsLB=tags[[All,1]];
	tagsRB=tags[[All,2]];
	progress=0;
	i=1;

	firstimage=Which[
	type=="string",Import@First@images,
	type=="image",First@images];
	dim=ImageDimensions@firstimage;

	Lspace=Round[0.015*First@dim];
	Rspace=Round[0.985*First@dim];
	Bspace=Round[0.03*Last@dim];

(* Dynamic status *)
	PrintTemporary[
	Row[
	{Text[Style["Image conversion progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Converted: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

(* New names *)
	newnamesf[old_]:=old<>"_"<>
	IntegerString[#,10,StringLength@ToString@L]&/@Range@L;
	nnOption=OptionValue["NewName"];

	Which[
	type=="string",
	Which[
	(* File name input, use numeric names *)
	TrueQ@nnOption,
	oldbasename=First@StringCases[StringTake
	[FileNameTake@First@images,{1,-5}],__~~LetterCharacter];
	newnames=newnamesf@oldbasename,

	!TrueQ@nnOption,
	(* File name input, keep old names *)
	newnames=FileBaseName/@FileNameTake/@images,

	StringQ@nnOption,
	(* File name input, custom base name *)
	newnames=newnamesf@nnOption
	],

	type=="image",
	Which[
	StringQ@nnOption,
	(* Image intput, custom base name *)
	newnames=newnamesf@nnOption,

	(* Image input, defualt 'Output' name *)
	True,
	newnames=newnamesf["Output"]
	]
	];

(* Export directory *)
	Which[
	DirectoryQ@OptionValue["ExportTo"],
	(* Option: Custom output directory *)
	outputdir=OptionValue["ExportTo"],

	type=="image",
	(* If images, export to desktop *)
	outputdir=FileNameJoin[{
	$HomeDirectory,"Desktop","Output"}],

	type=="string",
	(* Use input directory *)
	inputdir=DirectoryName@First@images;
	outputdir=FileNameJoin[{inputdir,"Output"}]
	];
	Quiet@CreateDirectory@outputdir;

(*---* Procedure *---*)
	Label["StartProcedure"];

	(* Marking *)
	{s1,s2,s3}=OptionValue["Style"];

	Do[
	image=Which[
	type=="string",
		Import@images[[i]],
	type=="image",
		images[[i]]
	];

	new1=ImageCompose[
	image,
	Graphics[
	Text[
	Style[tagsLB[[i]],s1,FontFamily->s2,s3],
	{0,0},{Left,Center}]],{Lspace,Bspace}];

	new2=ImageCompose[
	new1,
	Graphics[
	Text[
	Style[tagsRB[[i]],s1,FontFamily->s2,s3],
	{0,0},{Right,Center}]],{Rspace,Bspace}];

	(* Export *)
	Export[FileNameJoin[{outputdir,
	newnames[[i]]<>"."<>format}],
	new2];
	
	progress++,
	{i,L}];

Print[
ToString[progress]<>" "<>
If[L==1,"image","images"]<>
" were exported to \[LeftGuillemet]"<>
ToString[outputdir]<>"\[RightGuillemet]."
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ExtractUsage::mode="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised mode.";
ExtractUsage::link="The function name \[LeftGuillemet]`1`\[RightGuillemet] needs to be a hyperlink.";

Options@ExtractUsage={
"Mode"->"Normal"
};

SetAttributes[ExtractUsage,Listable]


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExtractUsage[notebook_String,OptionsPattern@ExtractUsage]:=Module[
{nb,packageName,functionName=FileBaseName@notebook,check,data,
L,starts,intervals,usages,span,
specialStart,specialEnd,wrap,messages,s,arg,info,startSpace,line,
temp},

(* Get main usage cell from (undeployed) documentation notebook *)
nb=Check[NotebookOpen[notebook,Visible->False],Abort[]];
SetSelectedNotebook@nb;
check=False;
While[check===False,
SelectionMove[nb,Next,Cell];
data=NotebookRead[nb];
check=Quiet[(data[[2]]==="Usage")]
];
NotebookClose[nb];

(* Find intervals with usage information *)
temp=data[[1,1]];
L=Length@temp;
starts=starts=1+Position[temp,"ModInfo",Infinity][[All,1]];
If[MatchQ[starts,{_Integer}],
intervals={{starts[[1]],L}},
intervals=Table[{starts[[i]],starts[[i+1]]-2},{i,Length@starts-1}];
intervals=Join[intervals,{{intervals[[-1,2]]+2,L}}]
];

span=Span[#[[1]],#[[2]]]&/@intervals;
usages=Part[temp,#]&/@span;

(* Extraction *)
specialStart="\!\(\*";
specialEnd="\)";
wrap[input_]:=Module[{x=ToString@input},
If[StringContainsQ[x,"Box"],x,"\""<>x<>"\""]];

messages={};
Do[
s=usages[[l]]/.x_ButtonBox:>First@x;
s=ToExpression@StringDelete[ToString@FullForm@s,{"\\[LineSeparator]","\\n"}];

Which[
Cases[s,"[",Infinity]==={},(* Function name only *)
arg=functionName,

MatchQ[s[[1,1,1,1]],{functionName,"[","]"}],(* Void function *)
arg=ToString@RowBox[{"\""<>functionName<>"\"","\""<>"[]"<>"\""}],

True,
arg=s[[1,1,1,1,3;;-2]];
If[Depth@arg<5,
arg=RowBox[{functionName,"[",First@arg,"]"}],
arg=Insert[arg,{functionName,"["},{1,1,1}];
arg=Insert[arg,"]",{1,1,-1}];
arg=FlattenAt[First@arg,{1,1}]];
arg=wrap//@arg
];

info=s[[2;;]]/.s_String:>"\""<>s<>"\"";
info=info/.s_String:>StringDelete[s,{"\[LineSeparator]","\n"}];
startSpace=If[StringTake[info[[1]],{2}]===" ",""," "];
info=ToString@RowBox@info;

line=specialStart<>arg<>specialEnd<>startSpace<>specialStart<>info<>specialEnd;

AppendTo[messages,line],
{l,Length@intervals}];

(* Optional: Include package- and function name *)
If[OptionValue["Mode"]==="Full",
packageName=First@StringCases[
notebook,name:Except["/"]..~~"/Documentation":>name];
messages={packageName,functionName,messages}];

(* Returning information *)
messages
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
NeatUsage::error="The usage is neither a string nor a list of strings.";
NeatUsage::dir="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid directory.";

Options@NeatUsage={
"DocumentationHyperlink"->False,
"Mode"->"Normal",
"OverwriteAutomatically"->True,
"WriteTo"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
NeatUsage[{application_String,symbol_Symbol},usage_,OptionsPattern@NeatUsage]:=
Module[
{mode,L,usagelist,messagelist,
cleared1,cleared2,cleared3,cleared4,
arguments,rules,message,nogap,complete,f,
outputfile,old,windowtext,decision,case},

(** Analysing input **)
	
	(* Message may already be formatted *)
		mode=OptionValue["Mode"];
		If[StringContainsQ[
		ToString[usage,StandardForm],
		"StyleBox"|"SubscriptBox"],
			mode="Formatted"];
		
		If[mode=="Formatted",
		If[ListQ@usage,
		messagelist=usage,
		messagelist={usage}];
		Goto["FormattingDone"]];

	(* Input form *)
	Which[
	ToString[Head@usage]=="String",
		L=1;
		usagelist={usage},
	ToString[Head@usage]=="List",
		If[!AllTrue[usage,StringQ],
		Message[NeatUsage::error];Abort[]];
		L=Length@usage;
		usagelist=usage,
	True,Message[NeatUsage::error];Abort[]];


(** Formatting one or several messages **)
	messagelist={};
	Do[

(* Formatting usage message *)
	(* In case function name contains '$' *)
	cleared1=StringCases[usagelist[[i]],"$"~~LetterCharacter..~~_];
	cleared2=StringTrim@DeleteCases[cleared1,x_/;StringTake[x,-1]=="$"];
	cleared3=StringReplace[cleared2,"$"->"\[Section]"];
	cleared4=StringReplace[usagelist[[i]],Thread[cleared2->cleared3]];
	
	arguments=StringCases[cleared4,Shortest["$"~~__~~"$"]];

	rules=Table[
	arguments[[i]]->"\!\(\*\nStyleBox[\""<>arguments[[i]]<>"\", \"TI\"]\)",
	{i,Length@arguments}];

	message=StringReplace[cleared4,rules];
	message=StringDelete[message,"$"];
	message=StringReplace[message,"\[Section]"->"$"];

(* Processing subscripts *)
	nogap=WordCharacter..|Except[" ",Except[" "]..~~", "~~Except[" "]..]..;

	message=StringReplace[message,
	pre:nogap~~"_"~~sub:nogap:>"\!\(\*SubscriptBox[\("<>pre<>"\), \("<>sub<>"\)]\)"];

(* Correcting ellipses *)
	message=StringReplace[message,"..."->"\[Ellipsis]"];

(* Correcting spaces between arguments *)
	message=StringReplace[message,
	{"\"TI\"]\),\!\(\*\nStyleBox["->"\"TI\"], \*\nStyleBox[",
	"\"TI\"]\),{\!\(\*\nStyleBox["->"\"TI\"]\), {\!\(\*\nStyleBox[",
	"\"TI\"]\)},\!\(\*\nStyleBox["->"\"TI\"]\)}, \!\(\*\nStyleBox["}];

	AppendTo[messagelist,message],
	{i,L}];


(** Preparing the usage layout **)
	Label["FormattingDone"];
	complete=Riffle[messagelist,"\n"];

(* Appending hyperlink to the documentation *)
f=ToString@symbol;
If[TrueQ@OptionValue["DocumentationHyperlink"],
	complete[[-1]]=
	ToString[Row[
	{
	complete[[-1]],
	"   ",
	Hyperlink["\[RightSkeleton]","paclet:"<>application<>"/ref/"<>f,
	ActiveStyle->None]
	}
	],StandardForm]
];

(* Setting the usage *)
	outputfile=ToString@OptionValue["WriteTo"];
	message=StringJoin@complete;

	If[DirectoryName[outputfile]==""||!DirectoryQ@DirectoryName@outputfile,
	symbol::usage=message;
	Return@Information[symbol,LongForm->False]
	];


(** Option: Store usage messages **)

(* Check if output file already exists *)
	If[!FileExistsQ@outputfile,
	Check[Export[outputfile,""],Abort[]];
	old="",
	old=Check[ReadString@outputfile,Abort[]]
	];

(* Check if file already contains the symbol *)
	If[StringContainsQ[old,StartOfLine~~f<>"::usage="],
	If[!OptionValue["OverwriteAutomatically"],
	windowtext=StringJoin[
	{"A usage message for \[LeftGuillemet]",
	f,
	"\[RightGuillemet] already exists in \[LeftGuillemet]",
	FileNameTake@outputfile,
	"\[RightGuillemet].\nWould you like to overwrite the old message?"}];

	decision=ChoiceDialog[windowtext,
	{"No"->False,"Yes"->True},
	WindowTitle->"Overwrite usage message",
	WindowFloating->True];
		
	If[!decision,Abort[]]
	];

	(* Replacing old message *)
		case=StringReplace[old,
		Shortest[f<>"::usage="~~__~~";"]->
		f<>"::usage="<>ToString@FullForm@StringJoin@message<>";"];
		
		Return@Export[outputfile,case]
		];


(* Append new usage *)
	WriteString[outputfile,
	old,
	f<>"::usage="<>ToString@FullForm@StringJoin@message,
	";\n\n\n"];

	Close@outputfile
]


(* ::Input::Initialization:: *)
NeatUsage[notebook_String,output_String,OptionsPattern@NeatUsage]:=
Module[{info},
(* Extract information from notebook *)
	info=ExtractUsage[notebook,"Mode"->"Full"];

(* Check output directory *)
	If[DirectoryName[output]==""||!DirectoryQ@DirectoryName@output,
	Message[NeatUsage::dir,DirectoryName@output];Abort[]];

(* Write information to output file *)
	NeatUsage[{info[[1]],ToExpression@info[[2]]},info[[3]],
	"Mode"->"Formatted",
	"WriteTo"->output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation::missingFile="Cannot find the file for \[LeftGuillemet]`1`\[RightGuillemet].";
CopyDefinitionCodeToDocumentation::nbEditor="\[LeftGuillemet]`1`\[RightGuillemet] does not appear to be open. Recall that this function has to be run in the 'Notebook Editor' front end.";
CopyDefinitionCodeToDocumentation::missingDocTools="Missing \[LeftGuillemet]DocumentationTools\[RightGuillemet] from Applications.";

Options@CopyDefinitionCodeToDocumentation={
"DocumentationSymbolsDir"->"/Users/Stian/Jottacloud/UiS/Mathematica project/GitHub/MaXrd/Documentation/English/ReferencePages/Symbols",
"DefinitionFile"->"/Users/Stian/Jottacloud/UiS/Mathematica project/GitHub/MaXrd/Core/Definitions.nb",
"ShowNotebooks"->False,
"TestRun"->False,
"OpenedWindowsMode"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation[symbol_String,OptionsPattern@CopyDefinitionCodeToDocumentation]:=
Module[
{symbolsDocDir,definitionsFile,targetFile,
showQ,testRunQ,windowModeQ,
nb,check,data,cells,
temp},

(*---* File and directory setup *---*)
symbolsDocDir=OptionValue["DocumentationSymbolsDir"];
definitionsFile=OptionValue["DefinitionFile"];
Check[targetFile=First@FileNames[symbol<>".nb",symbolsDocDir],
Message[CopyDefinitionCodeToDocumentation::missingFile,symbol];
Abort[]];
showQ=OptionValue["ShowNotebooks"];
testRunQ=OptionValue["TestRun"];
windowModeQ=OptionValue["OpenedWindowsMode"];

(*---* Copy cell(s) from source *---*)
nb=NotebookOpen[definitionsFile,Visible->False];
SetSelectedNotebook@nb;
check=False;
While[check===False,
NotebookFind[definitionsFile,symbol];
SelectionMove[nb,Next,Cell];
data=NotebookRead[nb];
check=(data[[1]]===symbol&&data[[2]]==="Subchapter")
];
SelectionMove[nb,Next,CellGroup];
cells=NotebookRead[nb];
NotebookClose[nb];
temp=Flatten[Position[cells,Background->#,Infinity]&/@{RGBColor[0.87, 0.94, 1],RGBColor[1, 0.9, 0.8]},1];
temp=Join[{{1,1,1}},temp[[All,;;3]]];
cells=Delete[cells,temp[[All,;;3]]];
cells=Replace[cells,(InitializationCell->True)->InitializationCell -> False,Infinity];

(*---* Copy to target (documentation notebook) *---*)
If[windowModeQ,
(* a. 'OpenedWindows' mode: execute copying on window opened in notebook editior *)
nb=Check[SetSelectedNotebook@@Notebooks@symbol,
Message[CopyDefinitionCodeToDocumentation::nbEditor,symbol];Abort[]],

(* b. Assume notebook editor front-end is running and open notebook *)
(* Check if 'DocumentationTools' are present *)
If[!FileExistsQ@FileNameJoin[{
$UserBaseDirectory,"Applications","DocumentationTools",
"Kernel","init.m"}],
Message[CopyDefinitionCodeToDocumentation::missingDocTools];
Abort[]];

nb=NotebookOpen[
FileNameJoin[{symbolsDocDir,symbol<>".nb"}],Visible->showQ];
];

(* Common copying procedure *)
SelectionMove[nb,After,Notebook];
NotebookFind[nb,"Mathematica code",Previous];
While[
True,
SelectionMove[nb,Next,Cell];
check=NotebookRead[nb];
If[check==={},Break[]];
NotebookDelete[nb]
];
NotebookFind[nb,"Mathematica code",Previous];
SelectionMove[nb,Next,Cell];
NotebookWrite[nb,cells];
If[!testRunQ,NotebookSave@nb];
If[!testRunQ,NotebookClose@nb];

Label["End"];
]


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation[OptionsPattern@CopyDefinitionCodeToDocumentation]:=
Module[{symbolsDocDir,definitionsFile,functionNames,options},

(*---* Find all symbols automatically *---*)
symbolsDocDir=OptionValue["DocumentationSymbolsDir"];
definitionsFile=OptionValue["DefinitionFile"];
functionNames=NotebookImport[definitionsFile,"Subchapter"];

(* Options *)
options=Keys@Options@CopyDefinitionCodeToDocumentation;
options=#->OptionValue[#]&/@options;

Do[
CopyDefinitionCodeToDocumentation[
functionNames[[i]],options/.List->Sequence],
{i,Length@functionNames}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
RenamePackageFunction::notfound="\[LeftGuillemet]`1`\[RightGuillemet] was not found in the definitions file.";
RenamePackageFunction::nbNotFound="No notebook \[LeftGuillemet]`1`.nb\[RightGuillemet] was found in \[LeftGuillemet]`2`\[RightGuillemet].";
RenamePackageFunction::missingDocTools="Missing \[LeftGuillemet]DocumentationTools\[RightGuillemet] from Applications.";

Options@RenamePackageFunction={
"DocumentationDir"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud/Utdanning/(2016-2020) Universitetet i Stavanger (PhD)/Mathematica project/GitHub/MaXrd/Documentation",
"DefinitionFile"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud/Utdanning/(2016-2020) Universitetet i Stavanger (PhD)/Mathematica project/GitHub/MaXrd/Core/Definitions.nb",
"ShowNotebooks"->False,
"TestRun"->False,
"ReturnContainedOnly"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RenamePackageFunction[oldName_String,newName_String,OptionsPattern@RenamePackageFunction]:=
Module[
{docDir,symbolsDocDir,definitionsFile,showQ,testRunQ,
import,L,nb,
allDocPages,contained={},exc,oldNamePattern,
checkAndReplace,searchAndReplace,saveProcedure,
read,write,oldFile,newFile},

(*---* File and directory setup *---*)
docDir=OptionValue["DocumentationDir"];
symbolsDocDir=FileNameJoin[{docDir,"English","ReferencePages","Symbols"}];
definitionsFile=OptionValue["DefinitionFile"];
showQ=OptionValue["ShowNotebooks"];
testRunQ=OptionValue["TestRun"];

(* Pattern recognition *)
exc=Except[{LetterCharacter|"\""}];
oldNamePattern={StartOfString,exc}~~oldName~~{exc,EndOfString};

(* Symbol notebooks *)
allDocPages=FileNames["*.nb",symbolsDocDir];
oldFile=Select[allDocPages,
StringContainsQ[#,$PathnameSeparator~~oldName~~".nb"~~EndOfString]&];
	(* Check: Does '<oldName>.nb' exist? *)
	If[oldFile==={},Message[RenamePackageFunction::nbNotFound,
	oldName,symbolsDocDir];Abort[],
	oldFile=First@oldFile];
contained=Select[allDocPages,StringContainsQ[Import[#,"Text"],oldName]&];
If[OptionValue["ReturnContainedOnly"],Return[FileBaseName/@contained]];

(*---* check-and-replace procedures *---*)
(* Check-and-replace *)
checkAndReplace[nb_NotebookObject]:=(
SelectionMove[nb,All,Expression];
read=NotebookRead[nb];
	If[Head@read==TemplateBox,
	SelectionMove[nb,Next,Cell];Continue[]];
If[StringContainsQ[ToString@read,oldNamePattern],
write=read/.s_String:>StringReplace[s,oldName->newName];
NotebookWrite[nb,write]];
SelectionMove[nb,Next,Word]);

(* Search-and-replace *)
searchAndReplace[nb_NotebookObject]:=While[
NotebookFind[nb,oldName,WordSearch->True]=!=$Failed,
checkAndReplace[nb]];

(* Saving *)
saveProcedure[nb_NotebookObject]:=If[testRunQ,
If[showQ,DialogInput[Column[{"Click OK to close this (unsaved) and continue.",DefaultButton["OK",DialogReturn[]]}]]],
NotebookSave[nb]];

(*---* Replacements *---*)
(* 1. Scan through definitions notebook *)
import=Import[definitionsFile,"Text"];
	(* Check if old function exists *)
	If[!StringContainsQ[import,oldName],
	Message[RenamePackageFunction::notfound,oldName];Abort[]];
L=Total@Flatten@List@StringCount[import,oldName];
nb=NotebookOpen[definitionsFile,Visible->showQ];
searchAndReplace[nb];
saveProcedure[nb];
NotebookClose[nb];

(* 2. Scan through documentation pages *)
(* Check if 'DocumentationTools' are present *)
If[!FileExistsQ@FileNameJoin[{
$UserBaseDirectory,"Applications","DocumentationTools",
"Kernel","init.m"}],
Message[RenamePackageFunction::missingDocTools];Goto["End"]];

Do[(* Execution *)
nb=NotebookOpen[contained[[i]],Visible->showQ];
searchAndReplace[nb];
saveProcedure[nb];
NotebookClose@nb,
{i,Length@contained}];

(* Rename corresponding documentation page *)
If[!testRunQ,newFile=FileNameJoin@ReplacePart[
FileNameSplit@oldFile,newName<>".nb",-1];
RenameFile[oldFile,newFile]];

(*---* Print information *---*)
Label["End"];
Print[
"Changed: "<>oldName<>" \[LongRightArrow] "<>newName<>"\n"<>
"Replacements in definitions file: "<>ToString@L<>"\n"
<>"Documentation pages considered:"];
Print[FileBaseName/@contained];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* End previous subcontext and start a new one *)
End[];
Begin["`GroupTheory`"];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GroupTable[m_Integer]:=
Module[{table},
table=Table[Mod[i*j,m],{i,0,m-1},{j,0,m-1}];
TableForm[table,
TableHeadings->{#,#}&@Range[0,m]]
]


(* ::Input::Initialization:: *)
GroupTable[set_List,m_Integer]:=Module[{antall,table},
antall=Length@set;
table=Table[Mod[set[[i]]*set[[j]],m],{i,1,antall},{j,1,antall}];
TableForm[table,
TableHeadings->{#,#}&@set]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GroupInverse[t_Integer,m_Integer]:=Module[{k},
k=2;
While[Mod[k*t,m]!=1,k++];
k
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RelativelyPrimeList[t_Integer]:=Module[{liste,i},
liste={};
For[i=1,i<=t-1,i++,
If[GCD[i,t]==1,
AppendTo[liste,i],
(Null)]];
liste]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CommonPrimes[i__Integer]:=Module[{antall,temp1,temp2,felles,j},
antall=Length@{i};
temp1=FactorInteger[#][[All,1]]&/@{i};
temp2=Tally@Flatten@temp1;
felles={};
For[j=1,j<=Length@temp2,j++,
If[temp2[[j,2]]==antall,AppendTo[felles,temp2[[j,1]]],Null]];
felles
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
FindGenerators[m_Integer]:=Module[{generatorer,i},
generatorer={};
For[i=2,
	i<m,
	i++,
	If[Sort@Mod[i^Range@(m-1),m]===Range@(m-1),
	AppendTo[generatorer,i],
	Null]
	];
generatorer
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
LinearCongruenceSolve::nosolution="No solutions.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LinearCongruenceSolve[\[Alpha]_Integer,\[Beta]_Integer,\[Gamma]_Integer]:=Module[{solutions,a,b,c,k,x,X,n},
(* Checking the number of solutions (if any) *)
	solutions=GCD[\[Alpha],\[Gamma]];
	If[Divisible[\[Beta],solutions],Null,
		Message[LinearCongruenceSolve::nosolution];Goto["End"]];

(* Reducing the congruence *)
	{a,b,c}={\[Alpha],\[Beta],\[Gamma]}/GCD[\[Alpha],\[Beta],\[Gamma]];
	If[a>c,a=a-Quotient[a,c]*c,Null];

(* Finding the inverse in the corresponding cyclic group *)
	k=2;
	While[Mod[k*a,c]!=1,k++]; (* The inverse will be 'k' *)

(* Finding the solutions *) 
	x = Mod[k*b,c];
	X= {};
	For[n=0,x+n<\[Gamma],n=n+c,AppendTo[X,x+n]];
Return[ToString@X<>" + "<>ToString@\[Gamma]<>"\[DoubleStruckCapitalZ]"];
		Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* End previous subcontext and start a new one *)
End[];
Begin["`Miscellaneous`"];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PolygonArea[input_List]:=Module[{n,i,s,dets},
n=Length[input];
For[i=1;s=0,
i<Length[input],
i++,
s=s+Det[{input[[i]],input[[i+1]]}]];
dets=s+Det[{input[[n]],input[[1]]}];
Abs[dets/2]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ColourConversion::invRGB="RGB colours should be a list of three integers.";
ColourConversion::invHTMLlength="HTML colours should be six characters long.";
ColourConversion::invHTML="HTML colours should only contain digits or letters a\[Dash]e.";
ColourConversion::inv="Invalid input.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ColourConversion[{R_Integer,G_Integer,B_Integer}]:=Module[{r,g,b,temp1,temp2,temp3,i},
r=IntegerString[R,16];
g=IntegerString[G,16];
b=IntegerString[B,16];
temp1={r,g,b};
temp2={};
For[i=1,i<4,i++,
If[StringLength[Part[temp1,i]]==1,
AppendTo[temp2,StringJoin["0",Part[temp1,i]]],
AppendTo[temp2,Part[temp1,i]]]];
temp3=StringJoin@temp2;
temp3
]


(* ::Input::Initialization:: *)
ColourConversion[HTML_]:=Module[{html,r,g,b,R,G,B},
html=ToString[HTML];
r=StringTake[html,{1,2}];
g=StringTake[html,{3,4}];
b=StringTake[html,{5,6}];
R=FromDigits[r,16];
G=FromDigits[g,16];
B=FromDigits[b,16];
{R,G,B}
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ComplementaryColour[input_]:=Module[{type,c,c1,c2,m1,m2,m3,colour},
(* Interpreting and testing input format *)
	If[!AnyTrue[Head[input]===#&/@{String,List},TrueQ],Message[Colour::inv];Abort[]];

	(* RGB input *)
		If[Head[input]==List,
		If[!Length@Flatten[input]==3,Message[Colour::invRGB];Abort[]];
		c=input;
		type="RGB"];

	(* HTML input *)
		If[Head[input]==String,
		If[!StringLength[input]==6,Message[Colour::invHTMLlength];Abort[]];
		If[!StringLength[StringReplace[input,{DigitCharacter,"a","b","c","d","e","f"}->""]]==0,Message[Colour::invHTML];Abort[]];
		c=ColourConversion[input];
		type="HTML"];


(* Step A: If at least two values are identical, swap them *)
	If[!DuplicateFreeQ[c],
	{c1,c2}=DeleteDuplicates[c][[{1,-1}]];
	colour=c/.{c1->c2,c2->c1}];

(* Step B: If all values are distinct, first swap position of the minimum and maximum values *)
(* The remaining middle position will be filled by 'max - middle + min' *)
	If[DuplicateFreeQ[c],
	{m1,m2,m3}={Min[c],Max[c],Sort[c][[2]]};
	colour=c/.{m1->m2,m2->m1,m3->m2-m3+m1}];

Which[
	type=="RGB",colour,
	type=="HTML",ColourConversion[colour]]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@ColourTriad={
"Display"->False,
"Format"->Null
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ColourTriad[input_,OptionsPattern@ColourTriad]:=Module[{type,c,p,colour,format,output,rgb},
(* Interpreting and testing input format *)
	If[!AnyTrue[Head[input]===#&/@{String,List},TrueQ],Message[Colour::inv];Abort[]];

	(* RGB input *)
		If[Head[input]==List,
		If[!Length@Flatten[input]==3,Message[Colour::invRGB];Abort[]];
		c=input;
		type="RGB"];

	(* HTML input *)
		If[Head[input]==String,
		If[!StringLength[input]==6,Message[Colour::invHTMLlength];Abort[]];
		If[!StringLength[StringReplace[input,{DigitCharacter,"a","b","c","d","e","f"}->""]]==0,Message[Colour::invHTML];Abort[]];
		c=ColourConversion[input];
		type="HTML"];

(* Cycle the values *)
	p=Select[Permutations[Range@3],Signature[#]==1&];
	colour={c[[#1]],c[[#2]],c[[#3]]}&@@p;

(* Option: Output format *)
	format=OptionValue["Format"];
	Which[
	format=="RGB"||format=="rgb",type="RGB",
	format=="HTML"||format=="html",type="HTML",
	True,Null];	

Which[
	type=="RGB",output=colour,
	type=="HTML",output=ColourConversion/@colour];

(* Option: Display colours *)
	If[OptionValue["Display"],
	rgb=RGBColor@@@(colour/255);
	Graphics[
	{
	{rgb[[1]],Rectangle[{0,0}]},
	{rgb[[2]],Rectangle[{1,0}]},
	{rgb[[3]],Rectangle[{2,0}]}
	}
	],
	output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
LaTeXReminderCheck::ok="No duplicates found.";
LaTeXReminderCheck::dup="`1` duplicates were found.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LaTeXReminderCheck[file_String:
"/Users/Stian/Dropbox/Prosjekter/LaTeX/Guider og hjelp/LaTeX reminders.txt"
]:=Module[{temp1,a,b,temp2,temp3,temp4,temp5},

temp1=Import[file,"Data"];

{a,b}=Position[temp1,#][[1,1]]&/@{"Custom shortcuts in TexitEasy:","Custom shortcuts in Texmaker:"};

temp2=StringCases[ToString/@temp1[[a;;b]],{WordCharacter,"[","]"}..~~Repeated[" + "~~{WordCharacter..,_}]]/.{}->Nothing;

temp3=Gather[ToString/@temp2];

If[Evaluate[(Length/@temp3)/.{1->Nothing}]=={},Message[LaTeXReminderCheck::ok];Goto["End"]];

temp4=DeleteDuplicates@Flatten@Select[temp3,Length[#]==2&];

temp5=StringDelete[temp4,{"{","}"}];

Message[LaTeXReminderCheck::dup,Length@temp5];Print@TableForm@temp5;


Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PlagiarismCheck[input_String]:=Module[{temp,temp2,temp3,temp4},
temp=FileNameJoin[
{$TemporaryDirectory,ToString@Unique["temp"]<>".pdf"}];
CopyFile[input,temp];

temp2=ChangeExtension[temp,"txt"];
temp3=Import[temp2,"String"];
temp4=Hash[temp3,"MD5"];
IntegerString[temp4,16]
]


(* ::Input::Initialization:: *)
PlagiarismCheck[input_List]:=Module[{list,found,n,h,i},
list=<||>;
found={};

Do[
n=input[[i]];
h=PlagiarismCheck@input[[i]];
If[KeyExistsQ[list,h],
AppendTo[found,{list[h],n}]];
AppendTo[list,h->n],
{i,Length@input}];

found
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Default[PokemonTeamTest,2]=({{Null,"normal","fight","flying","poison","ground","rock","bug","ghost","steel","fire","water","grass","electric","psychic","ice","dragon","dark","fairy"},{"normal",1,1,1,1,1,.5,1,0,.5,1,1,1,1,1,1,1,1,1},{"fight",2,1,.5,.5,1,2,.5,0,2,1,1,1,1,.5,2,1,2,.5},{"flying",1,2,1,1,1,.5,2,1,.5,1,1,2,.5,1,1,1,1,1},{"poison",1,1,1,.5,.5,.5,1,.5,0,1,1,2,1,1,1,1,1,2},{"ground",1,1,0,2,1,2,.5,1,2,2,1,.5,2,1,1,1,1,1},{"rock",1,.5,2,1,.5,1,2,1,.5,2,1,1,1,1,2,1,1,1},{"bug",1,.5,.5,.5,1,1,1,.5,.5,.5,1,2,1,2,1,1,2,.5},{"ghost",0,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,.5,1},{"steel",1,1,1,1,1,2,1,1,.5,.5,.5,1,.5,1,2,1,1,2},{"fire",1,1,1,1,1,.5,2,1,2,.5,.5,2,1,1,2,.5,1,1},{"water",1,1,1,1,2,2,1,1,1,2,.5,.5,1,1,1,.5,1,1},{"grass",1,1,.5,.5,2,2,.5,1,.5,.5,2,.5,1,1,1,.5,1,1},{"electric",1,1,2,1,0,1,1,1,1,1,2,.5,.5,1,1,.5,1,1},{"psychic",1,2,1,2,1,1,1,1,.5,1,1,1,1,.5,1,1,0,1},{"ice",1,1,2,1,2,1,1,1,.5,.5,.5,2,1,1,.5,2,1,1},{"dragon",1,1,1,1,1,1,1,1,.5,1,1,1,1,1,1,2,1,0},{"dark",1,.5,1,1,1,1,1,2,1,1,1,1,1,2,1,1,.5,.5},{"fairy",1,2,1,.5,1,1,1,1,.5,.5,1,1,1,1,1,2,2,1}});

PokemonTeamTest::InvType="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid Pok\[EAcute]mon type.";
PokemonTeamTest::InvTypes="\[LeftGuillemet]`1`\[RightGuillemet] are not a valid Pok\[EAcute]mon types.";
PokemonTeamTest::NotString="Pok\[EAcute]mon types must be strings.";
PokemonTeamTest::OK="Pok\[EAcute]mon team OK.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PokemonTeamTest[pokemon_,typetable_.]:=Module[
{alltypes,notpokemon,ttable,pkmn,str,goodagainst,good,missing},
(* Basic information *)
	alltypes=typetable[[1,2;;]];
	notpokemon=Complement[pokemon,alltypes];

(* Input check *)
	If[notpokemon!={},
	If[Length[notpokemon]==1,
	Message[PokemonTeamTest::InvType,First@notpokemon];Abort[],
	Message[PokemonTeamTest::InvTypes,notpokemon]
	]];

	If[!AllTrue[pokemon,StringQ],Message[PokemonTeamTest::NotString];Abort[]];

(* Keeping rows with given types *)
	ttable=typetable[[2;;]];
	pkmn=Select[ttable,MemberQ[pokemon,First[#]]&];

(* Finding which types the team is effective against *)
	str=Last/@Position[pkmn,2];
	goodagainst=typetable[[1,#]]&/@str;
	good=DeleteDuplicates@goodagainst;

(* Missing types effective against... *)
	missing=Complement[alltypes,good];

(* Returning result *)
	If[missing=={},Message[PokemonTeamTest::OK],Return@missing];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GradeCalculation::invalid="Invalid input.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GradeCalculation[input__]:=(
(* Gather numbers in a list *)
	GradeCalculation[{input}]
)


(* ::Input::Initialization:: *)
GradeCalculation[input_]:=Module[{L,Letter,Number,sum,averagegrade},
(* Input check *)
	L=Length[input];
	If[!MemberQ[{5,6},L],Message[GradeCalculation::invalid];Abort[]];

(* Conversion functions *)
	Letter[number_]:=Which[
	number<0.5,           "F",
	0.5<=number<1.5,"E",
	1.5<=number<2.5,"D",
	2.5<=number<3.5,"C",
	3.5<=number<4.5,"B",
	number>=4.5,           "A"];

	Number[letter_]:=Which[
	letter=="F",0,
	letter=="E",1,
	letter=="D",2,
	letter=="C",3,
	letter=="B",4,
	letter=="A",5,
	NumericQ[letter],letter];

(* Average grade of an exam *)
	Which[
	L==5,sum=input.(Number/@{"A","B","C","D","E"}),
	L==6,sum=input.(Number/@{"A","B","C","D","E","F"})];
	
averagegrade=Letter[sum/Total@input]
]


(* ::Input::Initialization:: *)
GradeCalculation[input_?MatrixQ]:=Module[{Letter,Number,grades,weights,gpa},
(* Conversion functions *)
	Letter[number_]:=Which[
	number<0.5,           "F",
	0.5<=number<1.5,"E",
	1.5<=number<2.5,"D",
	2.5<=number<3.5,"C",
	3.5<=number<4.5,"B",
	number>=4.5,           "A"];

	Number[letter_]:=Which[
	letter=="F",0,
	letter=="E",1,
	letter=="D",2,
	letter=="C",3,
	letter=="B",4,
	letter=="A",5,
	NumericQ[letter],letter];

(* Grade point average *)
	grades=Number/@input[[All,1]];
	weights=input[[All,2]];
	gpa=(grades.weights)/Total[weights];

{NumberForm[N[gpa],3],Letter@gpa}
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@GridToLaTeX={
"WrapNumbers"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GridToLaTeX[grid_Grid,OptionsPattern@GridToLaTeX]:=Module[{
dim,content,
greek,rule1,rule2,extrarules,rules,extranonmath,
temp
},

(* Table dimensions and content *)
	If[Length@grid>1,
	dim={Length@First[#],Length@First@First[#]}&[grid],
	dim=Dimensions@First@grid];
	content=ToString/@Flatten@First@grid;

(* Convert to string and correct empty cells *)
	temp=(ToString/@content)/."Null"->"";

(* Correct subscripts *)
	temp=StringReplace[temp,
	{pre:Except[" "]..~~"\n"~~sub__:>
	"{"<>pre<>"}"<>"_{"<>StringTrim@sub<>"}",
	pre1:Except[" "]..~~" "..|"\\n"~~pre2___~~"\n"~~sub__:>
	"{"<>pre1<>"}"<>"_{"<>StringTrim@sub<>"} "<>pre2}];

(* Correct greek *)
	greek={
{"alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"},
{"Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega"},
{"CapitalAlpha","CapitalBeta","CapitalGamma","CapitalDelta","CapitalEpsilon","CapitalZeta","CapitalEta","CapitalTheta","CapitalIota","CapitalKappa","CapitalLambda","CapitalMu","CapitalNu","CapitalXi","CapitalOmicron","CapitalPi","CapitalRho","CapitalSigma","CapitalTau","CapitalUpsilon","CapitalPhi","CapitalChi","CapitalPsi","CapitalOmega"}};

	rule1=Thread[greek[[3]]->greek[[2]]];
	rule1="\\["<>#[[1]]<>"]"->"\\"<>#[[2]]&/@rule1;

	rule2=Thread[greek[[2]]->greek[[1]]];
	rule2="\\["<>#[[1]]<>"]"->"\\"<>#[[2]]&/@rule2;

	extrarules={
	"\\[Micro]"->"\\mu",
	"\\[Degree]"->"\\si{\\degree}"};

	rules=Join@@{rule1,rule2,extrarules};

	
	temp=ToString/@FullForm/@temp;

	(* Clearing extra quatiation marks *)
	temp=StringReplace[temp,{
	"\"\\\""~~c__~~"\\\"\"":>
	"\""<>c<>"\"","\""->""}];

	temp=StringReplace[temp,rules];

	temp=StringReplace[temp,x:greek~~y:LetterCharacter..:>x<>" "<>y];

	(* Wrapping subscript expressions on the form {...}_{...} with $...$ *)
	temp=StringReplace[temp,G:
	Shortest["{"~~__~~"}_{"~~__~~"}"]:>"$"<>G<>"$"];

	(* Finding unwrapped greek math *)
	temp=StringReplace[temp,
	(q:(
	p__/;(
	StringMatchQ[p,"$"~~___~~"\\"~~greek~~___~~"$"]||
	StringMatchQ[p,"\\"~~greek])
	):>
	StringReplace[q,{
	Shortest["$"~~k__~~"$"]:>"\[Section]"~~k~~"\[Section]",
	g:("\\"~~greek):>"$"<>g<>"$"}])/."\[Section]"->"$"
	];


(* Other corrections *)
	extranonmath={
	"\\[ODoubleDot]"->"\[ODoubleDot]",
	"_"->"\\textunderscore "};

	temp=StringReplace[temp,extranonmath];

(* Option: Wrap numbers *)
	If[StringQ@OptionValue["WrapNumbers"],
	temp=StringReplace[temp,t:{DigitCharacter,".","-"}..:>
	"\\"<>OptionValue["WrapNumbers"]<>"{"<>t<>"}"]];

(* Writing out lines *)
	temp=Partition[temp,Last@dim];
	temp=Riffle[#,{"&"}]&/@temp;
	temp=StringJoin@Riffle[#," "]&/@temp;
	temp=#<>" \\\\\n"&/@temp;

	Print@@Join@@
{{"\\begin{tabular}{"<>StringJoin@ConstantArray["c",Last@dim]<>"}\n"},
temp,
{"\\end{tabular}"}};	
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* End previous subcontext and start a new one *)
End[];
Begin["`PhD`"];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
AlignUB::ambiguous="`1` possible matrices found. Use a smaller tolerance.";
AlignUB::none="No matrices found.";
AlignUB::notfound="The `1` data file was not found.";
AlignUB::invalid="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid input.";
AlignUB::delta="Invalid setting for \[Delta].";

Options@AlignUB={
"Delta"->"Auto",
"ReturnDelta"->False,
"ReturnMatrices"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
AlignUB[input_String]:=Module[{input2,temp1,temp2,temp3,temp4,temp5},
(* Import if input is a file *)
If[FileExistsQ@input,
input2=StringJoin@Riffle[ToString/@Import[input][[1]]," "],
input2=input];

temp1=StringCases[input2,{"-",DigitCharacter}~~__];
temp2=First@StringSplit[temp1," "];
temp3=StringReplace[temp2,"E"->"*10^"];
temp4=ToExpression/@temp3;
temp5=Partition[temp4,3]
]


(* ::Input::Initialization:: *)
AlignUB[class_String,ref_,input_,OptionsPattern@AlignUB]:=Module[{
M,m,ubref,ubinput,delta,
temp,temp1,temp2,temp3,temp4,temp5,temp6,temp7,
tempA,tempB,tempC,tempD,tempE,tempF,tempG},

(*--- Preparing input ---*)
	(* Reference and input matrices *)
	M={};
	Do[
	Which[
	(* Import .dat file *)
	TrueQ[FileFormat[M]=="Table"],
		temp=Check[Import[M],
		Message[AlignUB::notfound,"reference"];
		Abort[]];
		m=Partition[temp[[1,3;;11]],3],

	(* Matrix given as string *)
	StringQ@m,m=AlignUB@m,

	(* Matrix given directly *)
	MatrixQ@m,Null,

	(* None of the above *)
	True,Message[AlignUB::invalid,m];Abort[]
	];
	AppendTo[M,m],
	{m,{ref,input}}
	];

	{ubref,ubinput}=M;


(*--- Finding correct matrix ---*)
	(* Multiplying input matrix by all symmetry operations *)
	temp1=Check[
	SymmetryOperations[class],
	Goto["End"]];
	temp2=Transpose/@temp1;
	temp3=Dot[ubinput,#]&/@temp2;

	(*-- Determining the value of 'delta' --*)
	delta=OptionValue["Delta"];
	Which[
	(* Automatic method *)
	TrueQ[delta==="Auto"],
		(* Subtracting reference matrix with
		every Laue equivalent *)
			tempA=Subtract[ubref,#]&/@temp3;
		(* Find the matrix with the smallest
		total squared deviation *)
			tempB=Total/@(Flatten/@tempA^2);
		(* Find the largest element of that matrix *)
			tempC=First@TakeSmallest[tempB,1];
			tempD=Position[tempB,tempC][[1,1]];
			tempE=First@TakeLargestBy[
			Flatten@tempA[[tempD]],Abs,1];
			tempF=RealDigits@tempE;
			tempG=Length@Select[First@tempF,#>0&]-Last@tempF;
			delta=Abs[tempE]+10^(-tempG);
			(* Optional: Return the found value *)
			If[OptionValue["ReturnDelta"],Return@delta],

	(* Use value set by user -- check if numeric *)
	NumericQ@delta,Null,
	
	(* None of the above *)
	True,Message[AlignUB::delta];Abort[]
	];

	(* Finding matrices within threshold *)
	temp4=Select[temp3,
	Chop[#-ubref,delta]==ConstantArray[0,{3,3}]&];
	temp5=Flatten[Position[temp3,#]&/@temp4];
		(* Abort if there are more than one possibility *)
		If[Length@temp5>1,
			(* Option *)
				If[OptionValue["ReturnMatrices"],Return@temp4];
		Message[AlignUB::ambiguous,Length@temp5];
		Goto["End"]];
		(* Warning if no matrices were found *)
		If[temp5=={},
		Message[AlignUB::none];
		Goto["End"]];

(*--- Formatting output ---*)
	temp6=temp1[[First@temp5]];
	temp7=StringDelete[ToString@temp6,{"{","}",","}];
	Return["um crec "<>temp7];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@ErrorPropagation={
"RoundSignificantFigures"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ErrorPropagation[function_,values__List,
OptionsPattern@ErrorPropagation]:=
Module[{n,X,\[Delta]X,f,\[Delta]f,u,x,pd,calc}, 

(*---* Preparations *---*)
	n=Length@{values};
	{X,\[Delta]X}=Transpose@{values};
	f=function@@X;

(*---* Partial derivatives *---*)
	(* Dummy variables *)
	u=IntegerString[Range[1,n],10,2];
	x=ToExpression@Map[StringJoin["x",#]&,u];

	(* Partial derivatives for each variable *)
	pd={};
	Do[
	AppendTo[pd,D[function@@x,x[[i]]]*\[Delta]X[[i]]],
	{i,n}];

(*---* Inserting values *---*)
	calc=ReplaceAll[pd,Thread[x->X]];
	\[Delta]f=Sqrt@Total[calc^2];

	(* Optional: 'RoundSignificantFigures' *)
	If[OptionValue["RoundSignificantFigures"],
	RoundSignificantFigures[{f,\[Delta]f}],
	{f,\[Delta]f}
	]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options@ExportCrystalData={
"IncludeSymmetryOperations"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExportCrystalData[crystal_String,output_String,OptionsPattern@ExportCrystalData]:=Module[{
data,compound,c,ltc,sg,csmatrix,
cell,atoms,siteM,type,flag,X,
$f0,sccoeff,asf,fp,fpp,write,end,endTab,
temp},

(* Input check *)
InputCheck[crystal,"CrystalQ"];

(*---* Preparing data *---*)
	(* Input *)
	data=$CrystalData[crystal];

	(* Compounds *)
	compound=crystal;

	(* Centring vectors *)
	c=SymmetryData[crystal,"Centring"];
	ltc=Which[
	c=="P",{{0,0,0}},
	c=="A",{{0,0,0},{0,1/2,1/2}},
	c=="B",{{0,0,0},{1/2,0,1/2}},
	c=="C",{{0,0,0},{1/2,1/2,0}},
	c=="I",{{0,0,0},{1/2,1/2,1/2}},
	c=="F",{{0,0,0},{1/2,1/2,0},
				{0,1/2,1/2},{1/2,0,1/2}},
	c=="R",{{0,0,0},{2/3,1/3,1/3},{1/3,2/3,2/3}}
	];

	(* Space group *)
	sg=SymmetryData[crystal,"HermannMauguinShort"];

	(* Symmetry operations *)
	If[OptionValue["IncludeSymmetryOperations"],
	csmatrix=SymmetryOperations[crystal];
	csmatrix=ToString[#,InputForm]&/@csmatrix,

	csmatrix={{{{1,0,0},{0,1,0},{0,0,1}},{0,0,0}}}
	];

	(* Lattice parameters *)
	cell=N@LatticeParameters[crystal,"Units"->False];

	(* Atom data *)
	atoms=Table[data["AtomData"][[i,#]]&/@
	{"Element","OccupationFactor","FractionalCoordinates",
	"DisplacementParameters"},
	{i,Length@$CrystalData[crystal,"AtomData"]}];

	Do[atoms[[i,-1]]=Flatten[{atoms[[i,-1]]}],{i,Length@atoms}];

	atoms[[All,1]]=StringDelete[
	atoms[[All,1]],{DigitCharacter,"+","-"}];	

	(* Multiplicity *)
	r=atoms[[All,3]];
	siteM=Table[N@Length@
	SymmetryEquivalentPositions[
	crystal,r[[a]]],{a,Length@r}]
	/Length@SymmetryOperations@crystal;

	atoms[[All,2]]=atoms[[All,2]]*siteM;

	(* ToString *)
	atoms=atoms/.x_String:>"\""<>x<>"\"";
	atoms=atoms/.x_?NumericQ:>ToString[x,InputForm];

	(* Flag (ADP type) *)
	type=data[["AtomData",1,"Type"]];
	flag=If[type=="Biso",{"B","B"},{"U","U"}];

	(* Scattering coefficients *)
	X=DeleteDuplicates@data[["AtomData",All,"Element"]];
	X=StringDelete[X,{DigitCharacter,"+","-"}];
	$f0=Import@FileNameJoin[{
	$XrayPath,"Core","Data",
	"AtomicScatteringFactor","WaasmaierKirfel.m"}];
	temp=Flatten[{$f0/@X}];
	temp=Values@temp[[All,
{"a1","a2","a3","a4","a5",
"b1","b2","b3","b4","b5",
"c"}]];
	sccoeff=Append[Partition[#,5],Last@#]&/@temp;
	Do[PrependTo[sccoeff[[i]],X[[i]]],{i,Length@X}];

	sccoeff=sccoeff/.x_String:>"\""<>x<>"\"";

	(* Anomalous corrections *)
	asf=
<|"H"->"{0.,0.}","He"->"{0.,0.}","Li"->"{0.,0.}","Be"->"{fpBe[Global`lambda],fppBe[Global`lambda]}","B"->"{fpB[Global`lambda],fppB[Global`lambda]}","C"->"{fpC[Global`lambda],fppC[Global`lambda]}","N"->"{fpN[Global`lambda],fppN[Global`lambda]}","O"->"{fpO[Global`lambda],fppO[Global`lambda]}","F"->"{fpF[Global`lambda],fppF[Global`lambda]}","Ne"->"{fpNe[Global`lambda],fppNe[Global`lambda]}","Na"->"{fpNa[Global`lambda],fppNa[Global`lambda]}","Mg"->"{fpMg[Global`lambda],fppMg[Global`lambda]}","Al"->"{fpAl[Global`lambda],fppAl[Global`lambda]}","Si"->"{fpSi[Global`lambda],fppSi[Global`lambda]}","P"->"{fpP[Global`lambda],fppP[Global`lambda]}","S"->"{fpS[Global`lambda],fppS[Global`lambda]}","Cl"->"{fpCl[Global`lambda],fppCl[Global`lambda]}","Ar"->"{fpAr[Global`lambda],fppAr[Global`lambda]}","K"->"{fpK[Global`lambda],fppK[Global`lambda]}","Ca"->"{fpCa[Global`lambda],fppCa[Global`lambda]}","Sc"->"{fpSc[Global`lambda],fppSc[Global`lambda]}","Ti"->"{fpTi[Global`lambda],fppTi[Global`lambda]}","V"->"{fpV[Global`lambda],fppV[Global`lambda]}","Cr"->"{fpCr[Global`lambda],fppCr[Global`lambda]}","Mn"->"\nIf[Global`lambda<=1.895,{fpMn1[Global`lambda],fppMn1[Global`lambda]},\n                   {fpMn2[Global`lambda],fppMn2[Global`lambda]}]","Fe"->"\nIf[Global`lambda<=1.743,{fpFe1[Global`lambda],fppFe1[Global`lambda]},\n                   {fpFe2[Global`lambda],fppFe2[Global`lambda]}]","Co"->"\nIf[Global`lambda<=1.608,{fpCo1[Global`lambda],fppCo1[Global`lambda]},\n                   {fpCo2[Global`lambda],fppCo2[Global`lambda]}]","Ni"->"\nIf[Global`lambda<=1.487,{fpNi1[Global`lambda],fppNi1[Global`lambda]},\n                   {fpNi2[Global`lambda],fppNi2[Global`lambda]}]","Cu"->"\nIf[Global`lambda<=1.380,{fpCu1[Global`lambda],fppCu1[Global`lambda]},\n                   {fpCu2[Global`lambda],fppCu2[Global`lambda]}]","Zn"->"\nIf[Global`lambda<=1.283,{fpZn1[Global`lambda],fppZn1[Global`lambda]},\n                   {fpZn2[Global`lambda],fppZn2[Global`lambda]}]","Ga"->"\nIf[Global`lambda<=1.195,{fpGa1[Global`lambda],fppGa1[Global`lambda]},\n                   {fpGa2[Global`lambda],fppGa2[Global`lambda]}]","Ge"->"\nIf[Global`lambda<=1.11659,{fpGe1[Global`lambda],fppGe1[Global`lambda]},\n                          {fpGe2[Global`lambda],fppGe2[Global`lambda]}]","As"->"\nIf[Global`lambda<=1.044,{fpAs1[Global`lambda],fppAs1[Global`lambda]},\n                   {fpAs2[Global`lambda],fppAs2[Global`lambda]}]","Se"->"\nIf[Global`lambda<=0.979,{fpSe1[Global`lambda],fppSe1[Global`lambda]},\n                   {fpSe2[Global`lambda],fppSe2[Global`lambda]}]","Br"->"\nIf[Global`lambda<=0.920,{fpBr1[Global`lambda],fppBr1[Global`lambda]},\n                   {fpBr2[Global`lambda],fppBr2[Global`lambda]}]","Kr"->"\nIf[Global`lambda<=0.865,{fpKr1[Global`lambda],fppKr1[Global`lambda]},\n                   {fpKr2[Global`lambda],fppKr2[Global`lambda]}]","Rb"->"\nIf[Global`lambda<=0.815,{fpRb1[Global`lambda],fppRb1[Global`lambda]},\n                   {fpRb2[Global`lambda],fppRb2[Global`lambda]}]","Sr"->"\nIf[Global`lambda<=0.769,{fpSr1[Global`lambda],fppSr1[Global`lambda]},\n                   {fpSr2[Global`lambda],fppSr2[Global`lambda]}]","Y"->"\nIf[Global`lambda<=0.727,{fpY1[Global`lambda],fppY1[Global`lambda]},\n                   {fpY2[Global`lambda],fppY2[Global`lambda]}]","Zr"->"\nIf[Global`lambda<=0.688,{fpZr1[Global`lambda],fppZr1[Global`lambda]},\n                   {fpZr2[Global`lambda],fppZr2[Global`lambda]}]","Nb"->"\nIf[Global`lambda<=0.653,{fpNb1[Global`lambda],fppNb1[Global`lambda]},\n                   {fpNb2[Global`lambda],fppNb2[Global`lambda]}]","Mo"->"\nIf[Global`lambda<=0.619,{fpMo1[Global`lambda],fppMo1[Global`lambda]},\n                   {fpMo2[Global`lambda],fppMo2[Global`lambda]}]","Tc"->"\nIf[Global`lambda<=0.589,{fpTc1[Global`lambda],fppTc1[Global`lambda]},\n                   {fpTc2[Global`lambda],fppTc2[Global`lambda]}]","Ru"->"\nIf[Global`lambda<=0.560,{fpRu1[Global`lambda],fppRu1[Global`lambda]},\n                   {fpRu2[Global`lambda],fppRu2[Global`lambda]}]","Rh"->"\nIf[Global`lambda<=0.533,{fpRh1[Global`lambda],fppRh1[Global`lambda]},\n                   {fpRh2[Global`lambda],fppRh2[Global`lambda]}]","Pd"->"\nIf[Global`lambda<=0.509,{fpPd1[Global`lambda],fppPd1[Global`lambda]},\n                   {fpPd2[Global`lambda],fppPd2[Global`lambda]}]","Ag"->"\nIf[Global`lambda<=0.485,{fpAg1[Global`lambda],fppAg1[Global`lambda]},\n                   {fpAg2[Global`lambda],fppAg2[Global`lambda]}]","Cd"->"\nIf[Global`lambda<=0.464,{fpCd1[Global`lambda],fppCd1[Global`lambda]},\n                   {fpCd2[Global`lambda],fppCd2[Global`lambda]}]","In"->"\nIf[Global`lambda<=0.443,{fpIn1[Global`lambda],fppIn1[Global`lambda]},\n                   {fpIn2[Global`lambda],fppIn2[Global`lambda]}]","Sn"->"\nIf[Global`lambda<=0.424,{fpSn1[Global`lambda],fppSn1[Global`lambda]},\n                   {fpSn2[Global`lambda],fppSn2[Global`lambda]}]","Sb"->"\nIf[Global`lambda<=0.406,{fpSb1[Global`lambda],fppSb1[Global`lambda]},\n                   {fpSb2[Global`lambda],fppSb2[Global`lambda]}]","Te"->"\nIf[Global`lambda<=0.389,{fpTe1[Global`lambda],fppTe1[Global`lambda]},\n                   {fpTe2[Global`lambda],fppTe2[Global`lambda]}]","I"->"\nIf[Global`lambda<=0.373,{fpI1[Global`lambda],fppI1[Global`lambda]},\n                   {fpI2[Global`lambda],fppI2[Global`lambda]}]","Xe"->"\nIf[Global`lambda<=0.358,{fpXe1[Global`lambda],fppXe1[Global`lambda]},\n                   {fpXe2[Global`lambda],fppXe2[Global`lambda]}]","Cs"->"\nIf[Global`lambda<=0.344,{fpCs1[Global`lambda],fppCs1[Global`lambda]},\n                   {fpCs2[Global`lambda],fppCs2[Global`lambda]}]","Ba"->"\nIf[Global`lambda<=0.331,{fpBa1[Global`lambda],fppBa1[Global`lambda]},\n                   {fpBa2[Global`lambda],fppBa2[Global`lambda]}]","La"->"\nLahich[Global`lambda<=0.318,{fpLa1[Global`lambda],fppLa1[Global`lambda]},\n      0.319<=Global`lambda<=1.978,{fpLa2[Global`lambda],fppLa2[Global`lambda]},\n      Global`lambda>=1.979,{fpLa3[Global`lambda],fppLa3[Global`lambda]}]","Ce"->"\nCehich[Global`lambda<=0.306,{fpCe1[Global`lambda],fppCe1[Global`lambda]},\n      0.307<=Global`lambda<=1.893,{fpCe2[Global`lambda],fppCe2[Global`lambda]},\n      Global`lambda>=1.894,{fpCe3[Global`lambda],fppCe3[Global`lambda]}]","Pr"->"\nPrhich[Global`lambda<=0.295,{fpPr1[Global`lambda],fppPr1[Global`lambda]},\n      0.296<=Global`lambda<=1.813,{fpPr2[Global`lambda],fppPr2[Global`lambda]},\n      1.814<=Global`lambda<=1.924,{fpPr3[Global`lambda],fppPr3[Global`lambda]},\n      Global`lambda>=1.925,{fpPr4[Global`lambda],fppPr4[Global`lambda]}]","Nd"->"\nNdhich[Global`lambda<=0.284,{fpNd1[Global`lambda],fppNd1[Global`lambda]},\n      0.285<=Global`lambda<=1.739,{fpNd2[Global`lambda],fppNd2[Global`lambda]},\n      1.740<=Global`lambda<=1.844,{fpNd3[Global`lambda],fppNd3[Global`lambda]},\n      1.845<=Global`lambda<=1.997,{fpNd4[Global`lambda],fppNd4[Global`lambda]},\n      Global`lambda>=1.998,{fpNd5[Global`lambda],fppNd5[Global`lambda]}]","Sm"->"\nSmhich[Global`lambda<=0.264,{fpSm1[Global`lambda],fppSm1[Global`lambda]},\n      0.265<=Global`lambda<=1.602,{fpSm2[Global`lambda],fppSm2[Global`lambda]},\n      1.603<=Global`lambda<=1.695,{fpSm3[Global`lambda],fppSm3[Global`lambda]},\n      1.696<=Global`lambda<=1.845,{fpSm4[Global`lambda],fppSm4[Global`lambda]},\n      Global`lambda>=1.846,{fpSm5[Global`lambda],fppSm5[Global`lambda]}]","Eu"->"\nEuhich[Global`lambda<=0.255,{fpEu1[Global`lambda],fppEu1[Global`lambda]},\n      0.256<=Global`lambda<=1.539,{fpEu2[Global`lambda],fppEu2[Global`lambda]},\n      1.540<=Global`lambda<=1.627,{fpEu3[Global`lambda],fppEu3[Global`lambda]},\n      1.628<=Global`lambda<=1.776,{fpEu4[Global`lambda],fppEu4[Global`lambda]},\n      Global`lambda>=1.777,{fpEu5[Global`lambda],fppEu5[Global`lambda]}]","Gd"->"\nGdhich[Global`lambda<=0.246,{fpGd1[Global`lambda],fppGd1[Global`lambda]},\n      0.247<=Global`lambda<=1.480,{fpGd2[Global`lambda],fppGd2[Global`lambda]},\n      1.481<=Global`lambda<=1.563,{fpGd3[Global`lambda],fppGd3[Global`lambda]},\n      1.564<=Global`lambda<=1.711,{fpGd4[Global`lambda],fppGd4[Global`lambda]},\n      Global`lambda>=1.712,{fpGd5[Global`lambda],fppGd5[Global`lambda]}]","Tb"->"\nTbhich[Global`lambda<=0.238,{fpTb1[Global`lambda],fppTb1[Global`lambda]},\n      0.239<=Global`lambda<=1.423,{fpTb2[Global`lambda],fppTb2[Global`lambda]},\n      1.424<=Global`lambda<=1.502,{fpTb3[Global`lambda],fppTb3[Global`lambda]},\n      1.503<=Global`lambda<=1.649,{fpTb4[Global`lambda],fppTb4[Global`lambda]},\n      Global`lambda>=1.650,{fpTb5[Global`lambda],fppTb5[Global`lambda]}]","Yb"->"\nYbhich[Global`lambda<=0.202,{fpYb1[Global`lambda],fppYb1[Global`lambda]},\n      0.203<=Global`lambda<=1.182,{fpYb2[Global`lambda],fppYb2[Global`lambda]},\n      1.183<=Global`lambda<=1.242,{fpYb3[Global`lambda],fppYb3[Global`lambda]},\n      1.243<=Global`lambda<=1.386,{fpYb4[Global`lambda],fppYb4[Global`lambda]},\n      Global`lambda>=1.387,{fpYb5[Global`lambda],fppYb5[Global`lambda]}]","Lu"->"\nLuhich[Global`lambda<=0.195,{fpLu1[Global`lambda],fppLu1[Global`lambda]},\n      0.196<=Global`lambda<=1.140,{fpLu2[Global`lambda],fppLu2[Global`lambda]},\n      1.141<=Global`lambda<=1.198,{fpLu3[Global`lambda],fppLu3[Global`lambda]},\n      1.199<=Global`lambda<=1.341,{fpLu4[Global`lambda],fppLu4[Global`lambda]},\n      Global`lambda>=1.342,{fpLu5[Global`lambda],fppLu5[Global`lambda]}]","Hf"->"\nHfhich[Global`lambda<=0.189,{fpHf1[Global`lambda],fppHf1[Global`lambda]},\n      0.190<=Global`lambda<=1.099,{fpHf2[Global`lambda],fppHf2[Global`lambda]},\n      1.100<=Global`lambda<=1.154,{fpHf3[Global`lambda],fppHf3[Global`lambda]},\n      1.155<=Global`lambda<=1.296,{fpHf4[Global`lambda],fppHf4[Global`lambda]},\n      Global`lambda>=1.297,{fpHf5[Global`lambda],fppHf5[Global`lambda]}]","Ta"->"\nTahich[Global`lambda<=0.183,{fpTa1[Global`lambda],fppTa1[Global`lambda]},\n      0.184<=Global`lambda<=1.061,{fpTa2[Global`lambda],fppTa2[Global`lambda]},\n      1.062<=Global`lambda<=1.113,{fpTa3[Global`lambda],fppTa3[Global`lambda]},\n      1.114<=Global`lambda<=1.254,{fpTa4[Global`lambda],fppTa4[Global`lambda]},\n      Global`lambda>=1.255,{fpTa5[Global`lambda],fppTa5[Global`lambda]}]","W"->"\nWhich[Global`lambda<=0.178,{fpW1[Global`lambda],fppW1[Global`lambda]},\n      0.179<=Global`lambda<=1.024,{fpW2[Global`lambda],fppW2[Global`lambda]},\n      1.025<=Global`lambda<=1.073,{fpW3[Global`lambda],fppW3[Global`lambda]},\n      1.074<=Global`lambda<=1.214,{fpW4[Global`lambda],fppW4[Global`lambda]},\n      Global`lambda>=1.215,{fpW5[Global`lambda],fppW5[Global`lambda]}]","Re"->"\nRehich[Global`lambda<=0.172,{fpRe1[Global`lambda],fppRe1[Global`lambda]},\n      0.173<=Global`lambda<=0.989,{fpRe2[Global`lambda],fppRe2[Global`lambda]},\n      0.990<=Global`lambda<=1.036,{fpRe3[Global`lambda],fppRe3[Global`lambda]},\n      1.037<=Global`lambda<=1.176,{fpRe4[Global`lambda],fppRe4[Global`lambda]},\n      Global`lambda>=1.177,{fpRe5[Global`lambda],fppRe5[Global`lambda]}]","Os"->"\nOshich[Global`lambda<=0.167,{fpOs1[Global`lambda],fppOs1[Global`lambda]},\n      0.168<=Global`lambda<=0.956,{fpOs2[Global`lambda],fppOs2[Global`lambda]},\n      0.957<=Global`lambda<=1.001,{fpOs3[Global`lambda],fppOs3[Global`lambda]},\n      1.002<=Global`lambda<=1.140,{fpOs4[Global`lambda],fppOs4[Global`lambda]},\n      Global`lambda>=1.141,{fpOs5[Global`lambda],fppOs5[Global`lambda]}]","Ir"->"\nIrhich[Global`lambda<=0.162,{fpIr1[Global`lambda],fppIr1[Global`lambda]},\n      0.163<=Global`lambda<=0.923,{fpIr2[Global`lambda],fppIr2[Global`lambda]},\n      0.924<=Global`lambda<=0.966,{fpIr3[Global`lambda],fppIr3[Global`lambda]},\n      0.967<=Global`lambda<=1.105,{fpIr4[Global`lambda],fppIr4[Global`lambda]},\n      Global`lambda>=1.106,{fpIr5[Global`lambda],fppIr5[Global`lambda]}]","Pt"->"\nPthich[Global`lambda<=0.158,{fpPt1[Global`lambda],fppPt1[Global`lambda]},\n      0.159<=Global`lambda<=0.893,{fpPt2[Global`lambda],fppPt2[Global`lambda]},\n      0.894<=Global`lambda<=0.934,{fpPt3[Global`lambda],fppPt3[Global`lambda]},\n      0.935<=Global`lambda<=1.072,{fpPt4[Global`lambda],fppPt4[Global`lambda]},\n      Global`lambda>=1.073,{fpPt5[Global`lambda],fppPt5[Global`lambda]}]","Au"->"\nAuhich[Global`lambda<=0.153,{-0.9007,fppAu1[Global`lambda]},\n      0.154<=Global`lambda<=0.863,{fpAu2[Global`lambda],fppAu2[Global`lambda]},\n      0.864<=Global`lambda<=0.902,{fpAu3[Global`lambda],fppAu3[Global`lambda]},\n      0.903<=Global`lambda<=1.040,{fpAu4[Global`lambda],fppAu4[Global`lambda]},\n      Global`lambda>=1.041,{fpAu5[Global`lambda],fppAu5[Global`lambda]}]","Hg"->"\nHghich[Global`lambda<=0.149,{-0.9287,fppHg1[Global`lambda]},\n      0.150<=Global`lambda<=0.835,{fpHg2[Global`lambda],fppHg2[Global`lambda]},\n      0.836<=Global`lambda<=0.872,{fpHg3[Global`lambda],fppHg3[Global`lambda]},\n      0.873<=Global`lambda<=1.009,{fpHg4[Global`lambda],fppHg4[Global`lambda]},\n      Global`lambda>=1.010,{fpHg5[Global`lambda],fppHg5[Global`lambda]}]","Tl"->"\nTlhich[Global`lambda<=0.144,{-0.9566,fppTl1[Global`lambda]},\n      0.145<=Global`lambda<=0.807,{fpTl2[Global`lambda],fppTl2[Global`lambda]},\n      0.808<=Global`lambda<=0.843,{fpTl3[Global`lambda],fppTl3[Global`lambda]},\n      0.844<=Global`lambda<=0.979,{fpTl4[Global`lambda],fppTl4[Global`lambda]},\n      Global`lambda>=0.980,{fpTl5[Global`lambda],fppTl5[Global`lambda]}]","Pb"->"\nPbhich[Global`lambda<=0.140,{-0.9856,fppPb1[Global`lambda]},\n      0.141<=Global`lambda<=0.781,{fpPb2[Global`lambda],fppPb2[Global`lambda]},\n      0.782<=Global`lambda<=0.815,{fpPb3[Global`lambda],fppPb3[Global`lambda]},\n      0.816<=Global`lambda<=0.951,{fpPb4[Global`lambda],fppPb4[Global`lambda]},\n      Global`lambda>=0.952,{fpPb5[Global`lambda],fppPb5[Global`lambda]}]","Bi"->"\nBihich[Global`lambda<=0.136,{-1.015,fppBi1[Global`lambda]},\n      0.137<=Global`lambda<=0.756,{fpBi2[Global`lambda],fppBi2[Global`lambda]},\n      0.757<=Global`lambda<=0.789,{fpBi3[Global`lambda],fppBi3[Global`lambda]},\n      0.790<=Global`lambda<=0.923,{fpBi4[Global`lambda],fppBi4[Global`lambda]},\n      Global`lambda>=0.924,{fpBi5[Global`lambda],fppBi5[Global`lambda]}]","Po"->"\nPohich[Global`lambda<=0.133,{-1.045,fppPo1[Global`lambda]},\n      0.134<=Global`lambda<=0.731,{fpPo2[Global`lambda],fppPo2[Global`lambda]},\n      0.732<=Global`lambda<=0.763,{fpPo3[Global`lambda],fppPo3[Global`lambda]},\n      0.764<=Global`lambda<=0.897,{fpPo4[Global`lambda],fppPo4[Global`lambda]},\n      Global`lambda>=0.898,{fpPo5[Global`lambda],fppPo5[Global`lambda]}]","At"->"\nAthich[Global`lambda<=0.129,{-1.076,fppAt1[Global`lambda]},\n      0.130<=Global`lambda<=0.708,{fpAt2[Global`lambda],fppAt2[Global`lambda]},\n      0.709<=Global`lambda<=0.738,{fpAt3[Global`lambda],fppAt3[Global`lambda]},\n      0.739<=Global`lambda<=0.872,{fpAt4[Global`lambda],fppAt4[Global`lambda]},\n      Global`lambda>=0.873,{fpAt5[Global`lambda],fppAt5[Global`lambda]}]","Rn"->"\nRnhich[Global`lambda<=0.125,{-1.107,fppRn1[Global`lambda]},\n      0.126<=Global`lambda<=0.686,{fpRn2[Global`lambda],fppRn2[Global`lambda]},\n      0.687<=Global`lambda<=0.715,{fpRn3[Global`lambda],fppRn3[Global`lambda]},\n      0.716<=Global`lambda<=0.848,{fpRn4[Global`lambda],fppRn4[Global`lambda]},\n      Global`lambda>=0.849,{fpRn5[Global`lambda],fppRn5[Global`lambda]}]","Fr"->"\nFrhich[Global`lambda<=0.122,{-1.138,fppFr1[Global`lambda]},\n      0.123<=Global`lambda<=0.665,{fpFr2[Global`lambda],fppFr2[Global`lambda]},\n      0.666<=Global`lambda<=0.692,{fpFr3[Global`lambda],fppFr3[Global`lambda]},\n      0.693<=Global`lambda<=0.824,{fpFr4[Global`lambda],fppFr4[Global`lambda]},\n      Global`lambda>=0.825,{fpFr5[Global`lambda],fppFr5[Global`lambda]}]","Ra"->"\nRahich[Global`lambda<=0.119,{-1.170,fppRa1[Global`lambda]},\n      0.120<=Global`lambda<=0.644,{fpRa2[Global`lambda],fppRa2[Global`lambda]},\n      0.645<=Global`lambda<=0.670,{fpRa3[Global`lambda],fppRa3[Global`lambda]},\n      0.671<=Global`lambda<=0.802,{fpRa4[Global`lambda],fppRa4[Global`lambda]},\n      Global`lambda>=0.803,{fpRa5[Global`lambda],fppRa5[Global`lambda]}]","Ac"->"\nAchich[Global`lambda<=0.116,{-1.203,fppAc1[Global`lambda]},\n      0.117<=Global`lambda<=0.624,{fpAc2[Global`lambda],fppAc2[Global`lambda]},\n      0.625<=Global`lambda<=0.649,{fpAc3[Global`lambda],fppAc3[Global`lambda]},\n      0.650<=Global`lambda<=0.781,{fpAc4[Global`lambda],fppAc4[Global`lambda]},\n      Global`lambda>=0.782,{fpAc5[Global`lambda],fppAc5[Global`lambda]}]","Th"->"\nThhich[Global`lambda<=0.113,{-1.237,fppTh1[Global`lambda]},\n      0.114<=Global`lambda<=0.605,{fpTh2[Global`lambda],fppTh2[Global`lambda]},\n      0.606<=Global`lambda<=0.629,{fpTh3[Global`lambda],fppTh3[Global`lambda]},\n      0.630<=Global`lambda<=0.760,{fpTh4[Global`lambda],fppTh4[Global`lambda]},\n      Global`lambda>=0.761,{fpTh5[Global`lambda],fppTh5[Global`lambda]}]","Pa"->"\nPahich[Global`lambda<=0.110,{-1.271,fppPa1[Global`lambda]},\n      0.111<=Global`lambda<=0.587,{fpPa2[Global`lambda],fppPa2[Global`lambda]},\n      0.588<=Global`lambda<=0.610,{fpPa3[Global`lambda],fppPa3[Global`lambda]},\n      0.611<=Global`lambda<=0.740,{fpPa4[Global`lambda],fppPa4[Global`lambda]},\n      Global`lambda>=0.741,{fpPa5[Global`lambda],fppPa5[Global`lambda]}]","U"->"\nUhich[Global`lambda<=0.107,{-1.305,fppU1[Global`lambda]},\n      0.108<=Global`lambda<=0.569,{fpU2[Global`lambda],fppU2[Global`lambda]},\n      0.570<=Global`lambda<=0.591,{fpU3[Global`lambda],fppU3[Global`lambda]},\n      0.592<=Global`lambda<=0.722,{fpU4[Global`lambda],fppU4[Global`lambda]},\n      Global`lambda>=0.723,{fpU5[Global`lambda],fppU5[Global`lambda]}]","Np"->"\nNphich[Global`lambda<=0.104,{-1.341,fppNp1[Global`lambda]},\n      0.105<=Global`lambda<=0.552,{fpNp2[Global`lambda],fppNp2[Global`lambda]},\n      0.553<=Global`lambda<=0.573,{fpNp3[Global`lambda],fppNp3[Global`lambda]},\n      0.574<=Global`lambda<=0.704,{fpNp4[Global`lambda],fppNp4[Global`lambda]},\n      Global`lambda>=0.705,{fpNp5[Global`lambda],fppNp5[Global`lambda]}]","Pu"->"\nPuhich[Global`lambda<=0.101,{-1.377,fppPu1[Global`lambda]},\n      0.102<=Global`lambda<=0.539,{fpPu2[Global`lambda],fppPu2[Global`lambda]},\n      0.540<=Global`lambda<=0.559,{fpPu3[Global`lambda],fppPu3[Global`lambda]},\n      0.560<=Global`lambda<=0.692,{fpPu4[Global`lambda],fppPu4[Global`lambda]},\n      Global`lambda>=0.693,{fpPu5[Global`lambda],fppPu5[Global`lambda]}]","Am"->"\nAmhich[Global`lambda<=0.099,{-1.414,fppAm1[Global`lambda]},\n      0.100<=Global`lambda<=0.521,{fpAm2[Global`lambda],fppAm2[Global`lambda]},\n      0.522<=Global`lambda<=0.540,{fpAm3[Global`lambda],fppAm3[Global`lambda]},\n      0.541<=Global`lambda<=0.669,{fpAm4[Global`lambda],fppAm4[Global`lambda]},\n      Global`lambda>=0.670,{fpAm5[Global`lambda],fppAm5[Global`lambda]}]","Cm"->"\nCmhich[Global`lambda<=0.096,{-1.451,fppCm1[Global`lambda]},\n      0.097<=Global`lambda<=0.506,{fpCm2[Global`lambda],fppCm2[Global`lambda]},\n      0.507<=Global`lambda<=0.521,{fpCm3[Global`lambda],fppCm3[Global`lambda]},\n      0.522<=Global`lambda<=0.654,{fpCm4[Global`lambda],fppCm4[Global`lambda]},\n      0.655<=Global`lambda<=1.971,{fpCm5[Global`lambda],fppCm5[Global`lambda]},      \n      Global`lambda>=1.972,{fpCm6[Global`lambda],fppCm6[Global`lambda]}]","Bk"->"\nBkhich[Global`lambda<=0.094,{-1.489,fppBk1[Global`lambda]},\n      0.095<=Global`lambda<=0.490,{fpBk2[Global`lambda],fppBk2[Global`lambda]},\n      0.491<=Global`lambda<=0.508,{fpBk3[Global`lambda],fppBk3[Global`lambda]},\n      0.509<=Global`lambda<=0.637,{fpBk4[Global`lambda],fppBk4[Global`lambda]},\n      0.638<=Global`lambda<=1.891,{fpBk5[Global`lambda],fppBk5[Global`lambda]}      \n      Global`lambda>=1.892,{fpBk6[Global`lambda],fppBk6[Global`lambda]}]","Cf"->"\nCfhich[Global`lambda<=0.091,{-1.528,fppCf1[Global`lambda]},\n      0.092<=Global`lambda<=0.478,{fpCf2[Global`lambda],fppCf2[Global`lambda]},\n      0.479<=Global`lambda<=0.495,{fpCf3[Global`lambda],fppCf3[Global`lambda]},\n      0.496<=Global`lambda<=0.627,{fpCf4[Global`lambda],fppCf4[Global`lambda]},\n      0.628<=Global`lambda<=1.859,{fpCf5[Global`lambda],fppCf5[Global`lambda]},\n      1.860<=Global`lambda<=1.978,{fpCf6[Global`lambda],fppCf6[Global`lambda]},      \n      Global`lambda>=1.979,{fpCf7[Global`lambda],fppCf7[Global`lambda]}]"|>;

	fp=StringTrim/@Transpose[{"\""<>#<>"\""&/@X,asf[#]&/@X}];
	fp[[All,2]]=StringReplace[fp[[All,2]],
	Shortest[f:("f"~~__)~~c_~~"["]:>
	f<>If[!NumericQ@ToExpression@c,c<>"1",c]<>"["];
	fp[[All,2]]=StringDelete[fp[[All,2]],"\n"];

	fpp="Get[\"inpol-"<>#<>
".dat\",Path->\"D:\\\\X-Ray-Diffraction\\\\Anomal\\\\Data\"];"&/@X;


(* Prepare file *)
end[x_]:=ToString[x,InputForm]<>";\n";
endTab[x_]:="{"<>(
Riffle[
ToString/@Riffle[x,"\n\t",{1,-1,2}],
",",{3,-3,3}]
)<>"};\n";

write=Flatten@{
"compound = \""<>crystal<>"\";\n",
"spacegroup = \""<>sg<>"\";\n",
"ltc="<>end@ltc,
"csmatrix="<>If[Length@csmatrix===1,
end@csmatrix,endTab@csmatrix],
"cell="<>end@cell,
"atoms="<>endTab@atoms,
"flag="<>end@flag,
"sccoeff="<>endTab@sccoeff,
"fp="<>endTab[DeleteDuplicates@fp]<>"\n",
DeleteDuplicates@fpp
};

(* Write file *)
Export[output,write,"Text"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ExportReflectionFile::dir="Invalid directory.";
ExportReflectionFile::format="Invalid format of the reflection data.";
ExportReflectionFile::hkl="Output must end with \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"hkl\", \"Program\"]\).";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExportReflectionFile[output_String,hkl_List]:=Module[{dir,list,spacing,input,temp1,temp2,temp3,temp4},

(* Checking input *)
	dir=DirectoryName@output;

	If[dir==""||dir=="/",
	Message[ExportReflectionFile::dir];Abort[]];

	If[!DirectoryQ@dir,
	Message[ExportReflectionFile::dir];Abort[]];

	If[!StringTake[output,-3]=="hkl",
	Message[ExportReflectionFile::hkl];Abort[]];

	If[
	!Depth@hkl==3
	&&!MemberQ[{5,6},Length@RandomChoice@hkl],
	Message[ExportReflectionFile::format];Abort[]];

(* Handling the format of each reflection *)
	list={};
	spacing={4,4,4,8,8,4};
		If[Length@First@hkl==5,
		spacing=spacing[[;;5]]];

(* Adjusting spacing for each line *)
	input=Map[ToString,hkl,{2}];

	Do[
	temp1=input[[i]];
	temp2=spacing-StringLength/@temp1;
	temp3=StringJoin@ConstantArray[" ",#]&/@temp2;
	temp4=StringJoin@Riffle[temp3,temp1];
	AppendTo[list,temp4],
		{i,Length@input}
	];

	Export[output,list,"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
FindPixelClusters::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
FindPixelClusters::pixels="Pixels in the binarised image: `1`.";
FindPixelClusters::files="All images must be file paths.";
FindPixelClusters::dir="Invalid directory.";

Options@FindPixelClusters={
Method->"Auto",
"ReturnBinaryImage"->False,
"ClusterRange"->3,
"ClearStatus"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
FindPixelClusters[image_Image,OptionsPattern@FindPixelClusters]:=
Module[{
bin,data,L,method,fraction,check,
P,update,start,near,r,progress,status,total,p,i,j,neighbours,new,n,new2,
clusters,k},

(*---* Preparing image *---*)

	(* Otsu's cluster variance maximization method *)
	bin=Binarize@image;
	data=PixelValuePositions[bin,1];
	L=Length@data;

	(* Option: Choose method *)
	method=OptionValue[Method];
	Which[
	method=="Auto",method="Median",
	method=="Median",L=50000,
	method=="Mean",L=50000,
	method=="Cluster",L=50000,
	method=="HighestFraction",L=50001,
	method=="BinariseOnly",Goto["BinarisationDone"],
	True,Message[FindPixelClusters::method,method];Abort[]];

	(* Check if further refinement is necessary *)
	Which[
	L<=20000,Null,
	L<=50000,bin=DeleteSmallComponents[bin,Method->method],
	True,
	(* Special procedure for very noisy images *)
		fraction=1.00;
		check=True;

		While[check,
		fraction=fraction-0.005;
		bin=Binarize[image,Method->{"BlackFraction", fraction}];
		check=PixelValuePositions[bin,1]=={}];

		bin=DeleteSmallComponents[bin,Method->"Mean"]
	];

	data=PixelValuePositions[bin,1];
	
	(* Option: Return binary image and data length for inspection *)
		Label["BinarisationDone"];
		If[OptionValue["ReturnBinaryImage"],
		Message[FindPixelClusters::pixels,
		ToString@NumberForm[Length@data,DigitBlock->3]];
		Return@bin];


(*---* Cluster determination *---*)

	(* List of all pixels *)
	P={};
	update=N@data;
	start=First@update;
	r=N@OptionValue["ClusterRange"];
	near=N@DeleteCases[
	Flatten[Table[{i,j},{i,-r,r},{j,-r,r}],1],
	{0,0}];
	total=Length@data;
	progress=total;

	(* Dynamic status *)
	status=PrintTemporary[
	Row[
	{Text[Style["Determining pixel clusters:",FontFamily->"Avenir Next",14]],
	Spacer[20],
	Dynamic@ProgressIndicator[1-progress/total]
	},
	Alignment->Center
	]];

(* Single pixel *)
P=Reap@While[update!={},

(* First iteration *)
p={};

neighbours=start+#&/@near;
new=Intersection[update,neighbours];

	(* Avoid looping over the same single pixel *)
	If[new=={},update=Rest@update];

p=Join[p,new];
update=Complement[update,p];

	(* The next iterations *)
	While[new!={},
	
	(* Current and rest *)
	n=First@new;
	new=Rest@new;

		neighbours=n+#&/@near;
	
	(* Actual new elements *)
	new2=Intersection[update,neighbours];
	p=Join[p,new2];

	update=Complement[update,p];
	new=Join[new,new2];
	];

	(* One pixel done *)
	Sow[p];
	progress=Length@update;
	If[update!={},start=First@update]
];
	If[OptionValue["ClearStatus"],NotebookDelete@status];
	P=P[[2,1]];
	clusters=DeleteCases[P,{}];


(*---* Merge pixel clusters *---*)
	P=Reap@Do[
	k=Round[
	{
	Total@clusters[[i,All,1]],
	Total@clusters[[i,All,2]]
	}
	/Length@clusters[[i]]
	];
	Sow[k],
	{i,Length@clusters}
	];
	
	P[[2,1]]
]


(* ::Input::Initialization:: *)
FindPixelClusters[images_List,output_String,OptionsPattern@FindPixelClusters]:=Module[{progress,L,outputfile,step1,step2},

(* Check and prepare input *)
	If[AnyTrue[images,!FileExistsQ[#]&],
	Message[FindPixelClusters::files];Abort[]];
	If[!DirectoryQ@DirectoryName@output,
	Message[FindPixelClusters::dir];Abort[]];
	
	progress=0;
	L=Length@images;

(* Clear current $PixelData *)
	$PixelData=<||>;

(* Dynamic status *)
	PrintTemporary[
	Row[
	{Text[Style["Progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Images done: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

(* Preparing output file *)
	outputfile=output;
	Quiet@Close@outputfile;
	WriteString[outputfile,"<|"];

(* Loop *)
	Do[
	step1=IntegerString[FileHash[images[[i]],"MD5"],16,32];
	step2=FindPixelClusters[Import@images[[i]],
	Method->OptionValue[Method],
	"ClearStatus"->True];
	WriteString[outputfile,"\""<>step1<>"\""->step2];
	If[i!=Length@images,WriteString[outputfile,","]];
	progress++,
	{i,Length@images}];

(* End *)
	WriteString[outputfile,"|>"];
	Close@outputfile;
	AbsoluteFileName@outputfile
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ImgScript::None="No \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) files were found.";
ImgScript::InvalidFormat="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";
ImgScript::String="\!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) file paths must be strings.";
ImgScript::span="The setting of \"SelectAdjust\" must be a Span.";
ImgScript::integers="The span in \"SelectAdjust\" must be comprised of integers.";
ImgScript::InvalidRange="Range for \"SelectAdjust\" is not compatible with the number of \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"img\", \"Program\"]\) files.";
ImgScript::na="\"SelectAdjust\" cannot be used without a brightness factor.";

Options[ImgScript]={
"WriteDirectory"->False,
"OutputFormat"->"bmp",
"SelectAdjust"->All};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ImgScript[input_,Optional[m_?NumericQ,1],OptionsPattern@ImgScript]:=Module[{
type,outdir,
imgfiles,name,ext,end,i,writedir,adjust,
fcode,entry},

(* Analysing input *)
	type=ToString[Head@input];
	Which[
	type=="String",
		(* Finding .img files in the given directory *)
		imgfiles=FileNames["*.img",input];
		outdir=input;
		(* Check *)
		If[imgfiles=={},Message[ImgScript::None];Abort[]],
	type=="List",
		imgfiles=input;
		outdir=DirectoryName@First@input;
		(* Check if empty *)
		If[imgfiles=={},Message[ImgScript::None];Abort[]];
		(* Check if list contains strings only *)
		If[!AllTrue[imgfiles,StringQ],Message[ImgScript::String];Abort[]]
	];

(* Determining .mac file name *)
	If[StringContainsQ[FileNameTake@First@imgfiles,"_"],
	(* Truncated name *)
	name=StringDrop[First@StringCases[FileNameTake@First@imgfiles,__~~"_"],-1],
	(* Base name *)
	name=StringDrop[First@StringCases[FileNameTake@
First@imgfiles,Shortest[__~~DigitCharacter]],-1]];

(* Function that sets new extension *)
	ext=OptionValue["OutputFormat"];
	end[i_]:=StringDrop[imgfiles[[i]],-3]<>ext;

(* Optional: Write a different directory *)
	writedir=OptionValue["WriteDirectory"];
	If[StringQ@writedir,
	imgfiles=FileNameJoin[{writedir,#}]&/@(FileNameTake/@imgfiles)];

(* Optional: Output format *)
	Which[
	ext=="bmp",fcode="bitmap ",
	ext=="jpg",fcode="jpgbmp ",
	True,Message[ImgScript::InvalidFormat,ext];Abort[]];

(* Optional: Adjust brightness *)
	adjust=OptionValue["SelectAdjust"];
		(* Checks *)
		If[!(adjust===All),
		If[ToString@Head@adjust!="Span",
		Message[ImgScript::span];Abort[]];
		If[!AllTrue[adjust,IntegerQ],
		Message[ImgScript::integers];Abort[]];
		If[!adjust[[1]]>=1||adjust[[2]]>Length@imgfiles,
		Message[ImgScript::InvalidRange];Abort[]];
		If[m==1,
		Message[ImgScript::na];Abort[]]
		];

	If[m!=1,If[adjust==All,
	adjust=Range@Length@imgfiles,Null,
	adjust=Part[Range@Length@imgfiles,adjust]]];

(* Function that writes code for each case *)
	entry[i_]:=
	"rd i \""<>imgfiles[[i]]<>"\"\n"<>
	If[MemberQ[adjust,i],
	"ip multiplydouble i1 i1 "<>ToString[N[m]]<>"\n",
	""]<>
	"wd "<>fcode<>"\""<>end[i]<>"\"";

(* Generating and exporting table *)
	Export[FileNameJoin[{outdir,name<>".mac"}],
	Table[entry[i],{i,Length@imgfiles}],"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ImportReflectionFile[file_?(StringTake[#,-3]=="hkl"&)]:=Module[
{import,end,temp,need0,l,zero},

(* Importing and trimming .hkl file *)
	import=Check[Import[file,"Table"],Abort[]];
	import=ToString/@import;
	end=Position[StringCases[import,"0, 0, 0"],{"0, 0, 0"}];
	(* Not ending with {0,0,0} *)
		If[end=={},
		end=Length@import;need0=True,
		end=First@Flatten@end;need0=False];
	temp=import[[;;end]];

(* Fixing clustered entries *)
	temp=StringReplace[temp,
	a:DigitCharacter~~"-"~~b:DigitCharacter:>a<>" , "<>b];
	temp=ToExpression/@StringTrim/@temp;

(* Appending zero element if needed *)
	l=Length@RandomChoice@temp;
	zero={0,0,0,0.00,0.00,0};
	zero=zero[[;;l]];
	If[need0,AppendTo[temp,zero]];
	temp
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@IntensityTable={
"Sort"->-2
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
IntensityTable[group_String,file_?FileExistsQ,OptionsPattern@IntensityTable]:=
Module[{
import,sgHM,hkl,data,
gathered,wmean,
tally,minmax,min,max,range,span,
values,sort,table,
temp},

(*---* Importing data and reorganising *---*)
	import=Flatten@Check[Import[file,"CSV"],Abort[]];
	sgHM=SymmetryData[group,"HermannMauguinFull"];

	(* Removing the metadata appended in newer versions *)
		temp=Position[import,"   0   0   0    0.00    0.00   0"];
		If[temp!={},import=import[[;;temp[[1,1]]-1]]];		

	(* Fixing squeezed entries *)
	import=StringReplace[import,
	"  "~~p:{"-",""}~~a:DigitCharacter..~~"-"~~b:DigitCharacter:>
	"  "~~p~~a~~" -"~~b];
	import=ToExpression@StringSplit[import,Whitespace];

	(* Reorganising *)
	data=import/.{h_,k_,l_,F2_,\[Sigma]2_,batch_}:>{{h,k,l},F2,\[Sigma]2};
	
	(* Deleting extinct reflections *)
	hkl=data[[All,1]];
	temp=SystematicAbsentQ[sgHM,hkl];
	data=Pick[data,temp,False];

(*---* Gathering data by Laue class *---*)
	(* Gather by symmetry equivalence *)
	gathered=GatherBy[data,Sort@SymmetryEquivalentReflections[
sgHM,First@#]&];

	(* Calculating a weighted mean for each type *)
	temp=gathered[[All,All,{2,3}]];
	wmean=(WeightedMean@#)[[{1,3}]]&/@temp;

(*---* Extracting useful information for each group *---*)
	tally=Length/@gathered;
	minmax=Reap[
	Do[Sow[
	temp=f/@gathered[[All,All,2]];
	NumberForm[#,{6,0},
	DigitBlock->3,
	NumberSeparator->",",
	NumberPoint->""]&/@temp],
	{f,{Min,Max}}]
	];
	{min,max}=minmax[[2,1]];
	
	range=MapThread["("<>ToString[#1]<>"; "<>ToString[#2]<>")"&,{min,max}];
	span=MapThread[(#1-#2)/(2*#3)*100.0&,Map[First,{max,min,wmean},{2}]];

	(* Assigning a representative for each type of equivalent reflections *)
	temp=ToStandardSetting[sgHM,#]&/@
	(First/@First/@gathered);
	hkl=ToMiller/@temp;
	
	(* Merging the representatives with the corresponding values *)
	values=Transpose[{
	hkl,wmean[[All,1]],wmean[[All,2]],
	Length/@gathered,range,span}];

		(* Optional: Sorting option *)
		sort=OptionValue["Sort"];
		(* No preferance *)
		If[!MemberQ[Range@Last@Dimensions@values,Abs@sort],Goto["SortingDone"]];
		(* Sorting by a specific column *)			
		values=Sort[values,#1[[Abs@sort]]<#2[[Abs@sort]]&];
		(* Reversing if negative *)
		If[sort<0,values=Reverse@values];

(*---* Rounding off numbers *---*)
	Label["SortingDone"];
	temp=NumberForm[#,{6,0},
	DigitBlock->3,
	NumberSeparator->",",
	NumberPoint->""]&/@(Flatten@values);
	values=Partition[temp,Last@Dimensions@values];
	
	(* Inserting percentage signs to the 'relative span' *)
	values[[All,6]]=ToString[#]<>"%"&/@values[[All,6]];

(*---* Table construction *---*)
	table=PrependTo[values,
	{"(hkl)","[counts]","[counts]",Null,"(min; max)","from middle"}];
	table=PrependTo[table,
	{Null,"Intensity","Uncertainty","Tally","Range","Relative span"}];

	Grid[table,
	Dividers->{{None,{True},None},{None,None,True}},
	Background->{{None},{None,{None,GrayLevel[0.90]}}},
	Alignment->{Center,Center},
	Spacings->{1.5,2->0.25},
	ItemStyle->
	{Automatic,
	Automatic,
	{
	{{1,1},{1,Last@Dimensions@values}}->{FontFamily->"Times New Roman",FontSize->15},
	{{2,2},{1,Last@Dimensions@values}}->{FontFamily->"Times New Roman",FontSize->13,Gray},
	{{3,Length@table},{1,6}}->FontFamily->"Courier"
	}
	}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
MergeLogs::failed="Failed to interpret input. No log files with the prefix \[LeftGuillemet]crysalispro_red\[RightGuillemet] were found in \[LeftGuillemet]`1`\[RightGuillemet].";
MergeLogs::files="One or more log files were missing.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MergeLogs[input_?(StringQ[#]||AllTrue[#,StringQ]&),out_:" "]:=Module[{logs,sorted,imported,joined,output,name,file},
(*---* Processing input *---*)
(* A. Already merged log given *)
Quiet@If[
StringTake[input,27]=="Your current setup file is:",
Return@input];

(* B. Project or log directory given *)
Quiet@If[DirectoryQ@input,
logs=FileNames["crysalispro_red*",input,3];
Goto["InputCheck"]];

(* C. Single log file given *)
If[TrueQ[FileFormat[input]=="Text"],
Return@Import[input,"String"]];

(* D. Log files given as a list of paths *)
If[ListQ@input,
(* Check file existence *)
If[!AllTrue[input,FileExistsQ],
	Message[MergeLogs::files];Abort[]];
logs=input];

	(* Check input *)
	Label["InputCheck"];
	If[logs=={}||!ValueQ@logs,
	Message[MergeLogs::failed,input];Abort[]];

	(* Special case: Only one matching log file *)
	If[Length[logs]==1,
		joined=Import[First@logs,"Data"];
		If[Depth[joined]>2,joined=Flatten@joined];
		Goto["MergingDone"]
	];

(*---* Sorting chronologically and merging *---*)
	sorted=SortBy[logs,UnixTime@FileDate[#]&];
	imported=Map[Flatten,Import[#,"Data"]&/@sorted];
	joined=imported/.x_/;Depth[x]>2:>Flatten[x];

(*---* Returning merged log *---*)
	Label["MergingDone"];
	Which[
	(* A. Exporting to output directory *)
	Quiet@AllTrue[{input,ToString@out},DirectoryQ],
		name=FileNameTake[input,{-2}]<>"_log.txt";
		Export[FileNameJoin[{out,name}],joined],

	(* B. Returning merged log *)
	True,
		output=ToString/@joined;
		(* Export and import for correct formatting *)
		file=FileNameJoin[{$TemporaryDirectory,"temp.txt"}];
		Export[file,output];
		Import[file,"String"]
	]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
MonitorIni::InvInput="The length og the custom input does not match that of the \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"ini\", \"Program\"]\) file (or invalid range).";
MonitorIni::InvFlux="The flux file does not match the (length) of data.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MonitorIni[file_?(FileExtension[#]=="ini"&),input_]:=
Module[{flux,Flux,linFrom,linTo,method,import,end,prefix,L,seq,newvalues,i,newdata,filename},
(* Basic operations *)
	import=Check[Import@file,Abort[]];
	end=StringExtract[import[[2]],"_"->-1];
	prefix=StringTrim[import[[2,1]],end];
	L=Length@import-1;
	seq=ToString/@Range@L;

(* Checking if input is a flux file *)
	If[ToString@Head[input]=="String",
		flux=Check[Import[input,"Data"],Abort[]];
		Flux=Rest@flux;
		If[First[flux]=={"Flux"},
		newvalues=ToString/@(Flatten[Flux]/N[Max[Flux]]);
		(* Checking if the flux file is correct *)
		If[Length@newvalues!=L,Message[MonitorIni::InvFlux];
		Abort[]];
		Goto["ToNewData"];
		]
	];

(* Checking input for method *)
	method="LinearDecay";
	If[
	Length@Flatten@input==2,linFrom=input[[1]];linTo=input[[2]],
	method="CustomInput"
	];

(* Writing new data *)
	If[method=="CustomInput",
	newvalues=ToString/@input;
		(* Checking the custom input *)
		If[Length@newvalues!=L,Message[MonitorIni::InvInput];Abort[]],
	newvalues=ToString/@Reverse@Check[
Table[i,{i,linTo,linFrom,N[(linFrom-linTo)/(L-1)]}],Abort[]]];
	
	Label["ToNewData"];
	newdata=MapThread[prefix<>#1<>".img="<>#2&,{seq,newvalues}];
	PrependTo[newdata,"[Monitor]"];

(* Writing new file *)
	filename=StringDrop[file,-4];
	Export[filename<>"_new"<>".ini",newdata,"Table"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
NonlinearLeastSquares::check="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised check method.";
NonlinearLeastSquares::stop="Procedure stopped at iteration `1`.";

Options@NonlinearLeastSquares={
"ConvergenceCheck"->"Shift",
"ConvergenceLimit"->0.0001,
"IterationStop"->10,
"Iterations"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
NonlinearLeastSquares[f_Symbol,data_List,\[Beta]_List,OptionsPattern@NonlinearLeastSquares]:=Module[{
X,m,v,n,
dummyV,dummy\[Beta],
p,i,\[CapitalDelta],R,
c,l,stop,test,
j,subst\[Beta],substV,J,
S,S0},

(* Number of data variables, unknown parameters and data points *)
X=Transpose@data;
m=Length@data;
v=Length@X;
n=Length@\[Beta];

(* Dummy variables *)
dummyV=Table[Unique["dummyV"],{i,v}];
dummy\[Beta]=Table[Unique["dummy\[Beta]"],{i,n}];

(* Initial setting of parameters and partial derivatives *)
p=\[Beta];
R={0};S=1000;(* Initial sum of squares *)
\[CapitalDelta]=1000;(* Inital shift in parameters *)
i=0;(* Iteration count *)

(* Convergence check method and limit *)
c=OptionValue["ConvergenceCheck"];
l=OptionValue["ConvergenceLimit"];
stop=OptionValue["IterationStop"];
Which[
c=="Shift",test:=\[CapitalDelta],
c=="Squares",test:=S,
True,Message[NonlinearLeastSquares::check,c];Abort[]
];

(** Iteration start **)
While[test>l,
i++;

j=Table[D[
f[dummyV,dummy\[Beta]/.List->Sequence],
dummy\[Beta][[i]]],{i,n}];

(* Substituting in parameter values *)
subst\[Beta]=Thread[dummy\[Beta]->p];
j=j/.subst\[Beta];

(* Preparing list of data points *)
substV=Table[
Thread[dummyV->X[[All,i]]],{i,m}];

(* Jacobian *)
J=N@Table[j/.substV[[i]],{i,m}];

(* Sum of squares (and difference from last iteration) *)
S0=Total[R^2];
R=N@Table[
f[X[[All,i]],p/.List->Sequence],
{i,m}];
S=Total[R^2];

(* New parameters *)
p=p-Inverse[Transpose[J].J].Transpose[J].R;

\[CapitalDelta]=Abs[S0-S];

(* Stop? *)
If[i==stop,
Message[NonlinearLeastSquares::stop,i];Break[]]
];

If[OptionValue["Iterations"],
{i,p},p]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
LeastSquaresFit::numeric="Numeric input only.";
LeastSquaresFit::invalid="Invalid input form.";
LeastSquaresFit::data="More data required.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LeastSquaresFit[data_List]:=Module[{
n,x,y,X,Y,
sumx2,sumy2,sumxy,s2y,
a,b,\[Delta]a,\[Delta]b,r,
\[Delta]y,\[CapitalDelta],w,sumx,sumy,sumw,wsumx2,wsumy2,wsumxy},

(*---* Check input *---*)
	If[!AllTrue[Flatten@data,NumericQ],
	Message[LeastSquaresFit::numeric];Abort[]];

	Which[
	MatchQ[Dimensions[data],{_,2}],Goto["WithoutWeights"],
	MatchQ[Dimensions[data],{_,3}],Goto["WithWeights"],
	True,Message[LeastSquaresFit::invalid];Abort[]];

	If[Length@data<3,Message[LeastSquaresFit::data];Abort[]];

(*---* Data without weights *---*)
	Label["WithoutWeights"];

	(* Useful variables *)
	n=Length@data;
	{x,y}=Transpose@data;
	{X,Y}=Mean/@{x,y};
	sumx2=Total[(x-X)^2];
	sumy2=Total[(y-Y)^2];
	sumxy=Total[(x-X)*(y-Y)];
	s2y=1/(n-2)*(sumx2*sumy2-sumxy^2)/sumx2;	

	(* Coefficients *)
	b=sumxy/sumx2;
	a=Y-b*X;	

	(* Uncertainties *)
	\[Delta]a=Sqrt[s2y*Total[x^2]/(n*sumx2)];
	\[Delta]b=Sqrt[s2y/sumx2];

	(* Correlation coefficient *)	
	If[sumx2==0||sumy2==0,
	r=1,
	r=sumxy/Sqrt[sumx2*sumy2]];

Return[{{a,\[Delta]a},{b,\[Delta]b},{r,s2y}}];


(*---* Data with weights *---*)
	Label["WithWeights"];

	(* Useful variables *)
	n=Length@data;
	{x,y,\[Delta]y}=N@Transpose@data;
	w=1/\[Delta]y^2;

	(* Sum of weighted lists and weighted means *)
	{sumx,sumy,sumw}={w.x,w.y,Total[w]};
	{X,Y}={sumx,sumy}/sumw;
	{sumx2,sumy2,sumxy}={w.x^2,w.y^2,Total[w*x*y]};
	\[CapitalDelta]=sumw*sumx2-sumx^2;

	(* Coefficients *)
	a=(sumx2*sumy-sumx*sumxy)/\[CapitalDelta];
	b=(sumw*sumxy-sumx*sumy)/\[CapitalDelta];

	(* Uncertainties *)
	wsumx2=Total[w*(x-X)^2];
	wsumy2=Total[w*(y-Y)^2];
	wsumxy=Total[w*(x-X)*(y-Y)];

	\[Delta]a=Sqrt[sumx2/\[CapitalDelta]];
	\[Delta]b=Sqrt[sumw/\[CapitalDelta]];

	(* Correclation coefficient *)
	If[wsumx2==0||wsumy2==0,
	r=1,
	r=wsumxy/Sqrt[wsumx2*wsumy2]];

Return[{{a,\[Delta]a},{b,\[Delta]b},{r}}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PeakTableInspection::cutoff="The cutoff intensity is relative to the maximum intensity and must be a number between 0 and 1.";
PeakTableInspection::width="The group width must be a positive number.";
PeakTableInspection::goniometer="Invalid goniometer data in \[LeftGuillemet]`1`\[RightGuillemet].";
PeakTableInspection::tab="\[LeftGuillemet]`1`\[RightGuillemet] is an invalid \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"tab\", \"Program\"]\) file.";

Options@PeakTableInspection={
"Cutoff"->0.85,
"GroupWidth"->5
};


(* ::Input::Initialization:: *)
PeakTableInspection[set_,OptionsPattern@PeakTableInspection]:=Module[{
cutoff,width,
lim,top,groups,newset,sort,\[Phi]max,\[Phi],j,keep},
(* Input check *)
	cutoff=OptionValue["Cutoff"];
	If[!0<=cutoff<=1,
	Message[PeakTableInspection::cutoff];Abort[]];
	
	width=OptionValue["GroupWidth"];
	If[!NumericQ[width]||Negative[width],
	Message[PeakTableInspection::width];Abort[]];

(* Keeping the top part of the registrations *)
	lim=Ceiling[cutoff*Max@set[[All,6]]];
	top=DeleteCases[set,i_/;i[[6]]<lim];

(* Groping registrated reflections *)
	groups={};newset={};
	Do[
	While[top!={},
	(* Finding the value of \[Phi] at maximum *)
		sort=Sort[top,#1[[6]]>#2[[6]]&];
		\[Phi]max=sort[[1,5]];

	(* Group reflections that are within 5\[Degree] of \[Phi]max *)
		Do[
		\[Phi]=top[[j,5]];
		If[IntervalMemberQ[
		Interval[{\[Phi]max-#,\[Phi]max+#}&[width]],\[Phi]],
		AppendTo[groups,top[[j]]]],
		{j,Length@top}];

	(* Clear group from the set and repeat *)
		top=Complement[top,groups];
		AppendTo[newset,{groups}];
		groups={}
	],
	{j,Length@top}
	];

(* Keeping only the peak from each group *)
	keep=TakeLargestBy[(First@Transpose@newset)[[#]],#[[6]]&,1]&/@(Range@Length@newset);
	(First@Transpose@keep)[[All,1]]
]


(* ::Input::Initialization:: *)
PeakTableInspection[goniometerfile_?(FileExtension[#]=="dat"&)]:=Module[{
import,data,gathered,multi,
inspected,keepsingles,keep,in,delete},
(* Check input *)
	If[!FileExistsQ@goniometerfile,
	Message[PeakTableInspection::goniometer,
	FileNameTake@goniometerfile];
	Abort[]];

(* Extracting the necessary data *)
	import=Check[Import[goniometerfile,"Data"],Abort[]];
	data=import[[All,{1,2,3,4,8,10}]];
	(* Gather by 'hkl' values *)
		gathered=GatherBy[data,#[[2;;4]]&];
	(* Delete cases with only one registration *)
		multi=DeleteCases[gathered,L_/;Length[L]==1];

(* Finding which registrations to delete *)
	(* Analysed *)
	inspected=Flatten[PeakTableInspection/@multi];
	(* Single reflections *)
	keepsingles=DeleteCases[gathered,L_/;Length[L]!=1];
	keepsingles=keepsingles[[All,1,1]];
	keep=Union[inspected,keepsingles];
	in=import[[All,1]];	

	delete=Complement[in,keep]
]


(* ::Input::Initialization:: *)
(* Pending *)
PeakTableInspection[goniometerfile_?(FileExtension[#]=="dat"&),tabfile_?(FileExtension[#]=="tab"&)]:=Module[{
delete,tab,head,n,nn,newfile},
(* Check input *)
	If[!FileExistsQ@goniometerfile,
	Message[PeakTableInspection::goniometer,
	FileNameTake@goniometerfile];
	Abort[]];

	If[!FileExistsQ@tabfile,
	Message[PeakTableInspection::tab,
	FileNameTake@tabfile];
	Abort[]];

(* Finding which registrations to delete *)
	delete=PeakTableInspection[goniometerfile];

(* Loading .tab file *)	
	tab=Import[tabfile,"TSV"];

	(* New header *)
	head=tab[[1,1]];
	n=First@StringSplit@head;
	nn=ToExpression[n]-Length@delete;
	tab[[1,1]]=StringReplace[head,n->ToString[nn]];

	(* Delete entries *)
	tab=Delete[tab,Map[{#}&,delete]];

	(* Export modiefied .tab file *)
	newfile=StringInsert[tabfile,"_modified",-5];
	Export[newfile,tab,"Table"]	
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ReciprocalImageCheck::file="Input file was not found.";
ReciprocalImageCheck::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
ReciprocalImageCheck::system="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid lattice system.";
ReciprocalImageCheck::angles="Invalid angle input for the given system.";
ReciprocalImageCheck::load="\[LeftGuillemet]`1`\[RightGuillemet] cannot be loaded.";
ReciprocalImageCheck::form="The file does not appear to be on the correct Association form.";
ReciprocalImageCheck::asn="\[LeftGuillemet]$PixelData\[RightGuillemet] does not appear to be an Association.";
ReciprocalImageCheck::threshold="`1` reflection`2` outside the threshold for integer determination.";
ReciprocalImageCheck::all="All reflections were inside the threshold for integer determination.";
ReciprocalImageCheck::ambiguous="Ambiguous image orientation. Use different correspondence points.";
ReciprocalImageCheck::data="At least two data points are required.";
ReciprocalImageCheck::grid="The option \[LeftGuillemet]ShowLattice\[RightGuillemet] must either be set to \[LeftGuillemet]True\[RightGuillemet] or a non-negative integer.";

Options@ReciprocalImageCheck={
(* FindPixelClusters options *)
"ClearStatus"->False,
"ClusterRange"->3,
Method->"Auto",
"ReturnBinaryImage"->False,
(* ReciprocalImageCheck options *)
"Threshold"->0.15,
"RoundPixels"->True,
"LoadPixelData"->False,
"RetrieveData"->True,
"CountNonInteger"->False,
"StoreData"->False,
"ShowLattice"->False,
"Colours"->{ColorData[97,2],ColorData[97,1],LightGray},
"TooltipStyle"->{FontFamily->"Inconsolata",FontSize->14},
(* Plot options *)
Frame->True,
ImageSize->Large,
PlotRange->"ImageDimension",
PointSize->Large
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$PixelData=<||>;


(* ::Input::Initialization:: *)
ReciprocalImageCheck[
input_String,
system_,
data_List,
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],OptionsPattern@ReciprocalImageCheck]:=
Module[
{systems,sys,\[Alpha],\[Beta],\[Gamma],
image,imgdim,adjust,tx,ty,load,hash,pixlist,
hkls,sub,s,sel,normhkl,normorder,L,X,P,Pinv,method,
(* Lattice *)
L1x,L2x,L1y,L2y,
(* Conversion functions *)
\[CapitalLambda],\[CapitalGamma],\[Xi],convert,residue,threshold,result,i,\[Chi],
meddist,xy,rest,neighbour,distance,median,
selection,range,nearest,
clusters,off,groupfix,tooltip,
nodes,l,hkl,count,selection2D,pos,matching,pr,colourmatch,colourrest,colouroff,
temp,temp1,temp2,temp3,temp4,temp5,
(* Overalying grid *)
colours,V,c,L1,L2,t,tt,
gz,showgrid,del,grid,u,
(* Other *)
test,r,\[Lambda]1,\[Lambda]2,data2D,
plot,plotdata,plotoptions,
SD,grids},

(** Input check **)
	If[!FileExistsQ@input,
	Message[ReciprocalImageCheck::file];
	Abort[]];

	systems={
	"Triclinic","Monoclinic","Orthorhombic","Tetragonal",
	"Rhombohedral","Hexagonal","Cubic"};
	sys=If[ListQ@system,First@system,system];

	(* Check if valid lattice system *)
	If[!MemberQ[systems,sys],
	Message[ReciprocalImageCheck::system,system];
	Abort[]];

	(* Check if angles are required *)
	If[StringQ@system,	
	If[MemberQ[{"Triclinic","Monoclinic","Rhombohedral"},sys],
	Message[ReciprocalImageCheck::angles];Abort[]]
	];

	(* If angles given, check if form is valid *)
	If[ListQ@system,
	Which[
	sys=="Triclinic",
	If[MatchQ[Rest@system,
	{_?NumericQ,_?NumericQ,_?NumericQ}],
	{\[Alpha],\[Beta],\[Gamma]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]],

	sys=="Monoclinic",
	If[MatchQ[Rest@system,
	{_?NumericQ}],
	{\[Beta]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]],

	sys=="Rhombohedral",
	If[MatchQ[Rest@system,
	{_?NumericQ}],
	{\[Alpha]}=Rest@system*Degree,
	Message[ReciprocalImageCheck::angles];Abort[]]
	]
	];

	(* Check for sufficient data *)
	If[Length@data<2,
	Message[ReciprocalImageCheck::data];
	Abort[]];

	(* Check for 'ShowLattice' and 'StoreData' option *)
	SD=OptionValue["StoreData"];
	gz=OptionValue["ShowLattice"];

	If[SD,gz=0];
	If[gz==True||(IntegerQ[gz]&&NonNegative[gz]),
	showgrid=True,showgrid=False,showgrid=False];
	If[gz==True,gz=0];


(** Preparations for extracting two dimensions (image plane) **)
	hkls=data[[All,{3,4,5}]];

		(* Test: Check for any column with the same element *)
		temp=DeleteDuplicates/@Transpose@hkls;
		test=Boole[Length[#]!=1&/@temp];
			If[Count[test,0]!=1,
			Message[ReciprocalImageCheck::ambiguous];
			Abort[]];

	(* Values describing the plane *)
	normorder=First@Flatten@Position[test,0];
	normhkl=data[[1,normorder+2]];
	sel=DeleteCases[{1,2,3},normorder];

	(* Planar data *)
	data2D=Transpose@Drop[Transpose@data,{2+normorder}];


(** Check if image is known **)
	image=Check[Import@input,Abort[]];
	imgdim=ImageDimensions@image;
	adjust={tx,ty}=imgdim/2;


	If[OptionValue["ReturnBinaryImage"],Goto["FindPixelClusters"]];

	(* Optional: Load file containing pixel data *)
	load=OptionValue["LoadPixelData"];
	If[StringQ@load,
	If[FileExistsQ@load,
	$PixelData=
	Check[ToExpression@Import[load,"String"],
	Message[ReciprocalImageCheck::form];Abort[]],
	Message[ReciprocalImageCheck::load,load];Abort[]
	]];
	If[!AssociationQ@$PixelData,
	Message[ReciprocalImageCheck::asn];Abort[]];

	(* Hash procedure *)
	hash=IntegerString[FileHash[input,"MD5"],16,32];	
	If[
	KeyExistsQ[$PixelData,hash]
	&&OptionValue["RetrieveData"],
	pixlist=$PixelData[hash];
	Goto["PixelDone"]];

(* Converting image to a list of pixels *)
	Label["FindPixelClusters"];
	pixlist=FindPixelClusters[image,
	#->OptionValue[#]&/@
{"ReturnBinaryImage",Method,"ClusterRange","ClearStatus"}];

	(* Option for returning binarised image *)
		If[OptionValue["ReturnBinaryImage"],Return@pixlist];

	(* Storing image hash along with pixel data *)
		AppendTo[$PixelData,hash->pixlist];


(** Setting up lattice **)
	Label["PixelDone"];

	(* Determining reciprocal lattice used in CrysAlis *)	
	Which[
	sys=="Triclinic",
		L=N[{
	{1,
	-Cot[\[Gamma]]/Sqrt[Cot[\[Gamma]]^2+Csc[\[Gamma]]^2],
	(Csc[\[Gamma]] (Cos[\[Alpha]] Cot[\[Gamma]]-Cos[\[Beta]] Csc[\[Gamma]]))/(\[Sqrt]((1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]))},
	{0,
	Csc[\[Gamma]]/Sqrt[Cot[\[Gamma]]^2+Csc[\[Gamma]]^2],
	(Csc[\[Gamma]] (Cos[\[Beta]] Cot[\[Gamma]]-Cos[\[Alpha]] Csc[\[Gamma]]))/(\[Sqrt]((1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]))},
	{0,
	0,
	1/Sqrt[
	(1+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Cot[\[Gamma]]^2 Csc[\[Gamma]]^2-4 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]^3+(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^4) Sign[1+2 Cos[\[Alpha]] Cos[\[Beta]] Cot[\[Gamma]] Csc[\[Gamma]]-(Cos[\[Alpha]]^2+Cos[\[Beta]]^2) Csc[\[Gamma]]^2]]
	}}],

	sys=="Monoclinic",
		L=N[{
	{1,0,-Cos[\[Beta]]/Sqrt[1+Cos[\[Beta]]^2]},
	{0,1,0},
	{0,0,1/Sqrt[1+Cos[\[Beta]]^2]}}],

	sys=="Hexagonal",
		L=N[{{1,1/2,0},{0,Sqrt[3]/2,0},{0,0,1}}],

	True,L=IdentityMatrix[3]
	];

	(* Extracting two dimensions (image plane) *)
	L=L[[sel,sel]];

	(* Lattice components *)
	{{L1x,L2x},{L1y,L2y}}=L;

	(* Function for calculating residue *)
	r[{x_,y_,h1_,h2_},\[Lambda]1_,\[Lambda]2_]:=N[
	Sqrt[x^2+y^2]-
	Sqrt[(tx+h1*L1x*\[Lambda]1+h2*L2x*\[Lambda]2)^2+
	(ty+h1*L1y*\[Lambda]1+h2*L2y*\[Lambda]2)^2]];

	(* Determining scaling factors by iteration *)
	{\[Lambda]1,\[Lambda]2}=NonlinearLeastSquares[
	r,data2D,{50,50}];

	(* Scaled lattice *)
	\[CapitalLambda]=Transpose[Transpose[L]*{\[Lambda]1,\[Lambda]2}];
	\[CapitalGamma]=Inverse[\[CapitalLambda]];

	(* Conversion functions *)
	\[Xi][x_,y_]:=\[CapitalGamma].{x-tx,y-ty};
	\[Chi][h_,k_]:=\[CapitalLambda].{h,k}+{tx,ty};


(** Conversion functions **)
	
	(* Pixel to node *)
	\[Xi][{x_,y_}]:=(
	(* Calculation and discrepancy check *)
	convert=\[CapitalGamma].{x-tx,y-ty};
	residue=Abs/@FractionalPart/@N[convert];

	(* Decide whether to round to integer *)
	threshold=OptionValue["Threshold"];
	result={};
	
	Do[
	Which[
	residue[[i]]<=threshold,
		AppendTo[result,Round@convert[[i]]],
	1-residue[[i]]<=threshold,
		AppendTo[result,Round@convert[[i]]],
	True,
		AppendTo[result,N@convert[[i]]]
	],
	{i,2}];

	result);

	(* Node to pixel *)
	\[Chi][H_,round_:OptionValue["RoundPixels"]]:=(
	(* Calculation *)
	convert=\[CapitalLambda].H+adjust;
	
	(* Decide whether to round to integer *)
	If[round,Round@convert,convert]);


(** Optional: Overlaying grid/lattice **)
	If[!showgrid,Goto["LatticeDone"]];

	(* Preparations *)
	colours=<|1->Red,2->Green,3->Blue|>;
	c=Values@colours[[sel]];
	{L1,L2}=Transpose[\[CapitalLambda]];

	(* Lattice setup *)
	V[x0_,y0_]:=(
	t=\[CapitalLambda].{x0,y0}+adjust;
	tt={t,t};
	If[x0==y0==0,
	(* Origin arrows *)
	{
	{c[[1]],Arrow[{adjust,adjust+L1}]},
	{c[[2]],Arrow[{adjust,adjust+L2}]}
	},
	(* Translated arrows *)
	{
	{c[[1]],Dashed,Line[{{0,0},L1}+tt]},
	{c[[2]],Dashed,Line[{{0,0},L2}+tt]}
	}]
	);

	(* Lattice generation *)
	grids={};
	
	Label["StartGrid"];
	temp=Table[V[i,j],{i,-gz,Max[1,gz]},{j,-gz,Max[1,gz]}];
	temp=Flatten[temp,2];
	If[gz==0,
	temp=Delete[temp,{{3},{4},{5},{6},{7},{8}}];
	Goto["One"]
	];
	temp2=4gz+2;
	u=2*(2gz+1)^2;
	x1=Table[i,{i,temp2,u,temp2}];
		x1=Replace[x1,x_:>{x},{1}];
	x2=Table[j,{j,u-(4gz+1),u-1,2}];
		x2=Replace[x2,x_:>{x},{1}];
	del=DeleteDuplicates@Join[x1,x2];
	temp=Delete[temp,del];
	Label["One"];
	PrependTo[temp,Arrowheads[Medium]];

	grid=Graphics[temp,
	ImageSize->Small,
	AspectRatio->1,
	Axes->False
	];

	(* Optional: Generate several grids *)
		If[SD&&gz<8,
		AppendTo[grids,grid];gz++;Goto["StartGrid"]];

	Label["LatticeDone"];
	
	(* Consider relfections outside threshold to be wrong/off *)
	off=Select[pixlist,!AllTrue[\[Xi][#],IntegerQ]&];


(** Selecting nodes that match the pattern **)
	(* Setup *)
	nodes=\[Xi]/@pixlist;
	hkl=Partition[Riffle[
	Flatten@nodes,normhkl,{normorder,-1,3}],3];
	
	(* Check for non-integer cases *)
	If[OptionValue["CountNonInteger"],
		If[!FreeQ[hkl,_Real],
		Message[ReciprocalImageCheck::threshold,
		count=Count[FreeQ[#,_Real]&/@hkl,False],
		If[count>1,"s were"," was"]],
		Message[ReciprocalImageCheck::all]
		]];

	selection=Quiet@Cases[hkl,pattern];

	(* Backtracking *)
	selection2D=selection[[All,sel]];
	pos=Flatten[Position[nodes,#]&/@selection2D];
	matching=Part[pixlist,pos];

	(* Selection managment *)
	matching=Complement[matching,off];
	rest=Complement[pixlist,matching,off];

	(* Tooltip styling and managment *)
	groupfix[x_]:=Quiet[{x,ToMiller@
	Insert[\[Xi][x],normhkl,{normorder}]}];
	tooltip=Tooltip[#1,#2,TooltipStyle->
	OptionValue["TooltipStyle"]]&;

		(* Special case: Empty selections *)
		If[off=={},off={Null,Null}];
		If[rest=={},rest={Null,Null}];
		If[matching=={},matching={Null,Null};
		Goto["SkipMatching"]];

	(* Adding tooltip *)
	matching=MapThread[tooltip,
	Transpose[{
	pixlist[[#]],
	ToMiller@hkl[[#]]
	}&/@pos]
	];
	Label["SkipMatching"];

	rest=MapThread[tooltip,Transpose[groupfix/@rest]];
	off=MapThread[tooltip,Transpose[groupfix/@off]];


(** Plot **)
	(* Option: Custom PlotRange *)
	pr=OptionValue["PlotRange"];
	If[!MatchQ[pr,{{#,#},{#,#}}&[_Integer]],
	pr={0,#}&/@imgdim];

	{colourmatch,colourrest,colouroff}=OptionValue["Colours"];
	plotoptions={Frame->OptionValue[Frame],
	ImageSize->OptionValue[ImageSize],
	PlotRange->pr,
	AspectRatio->1/Divide@@imgdim,
	Axes->False,
	PlotStyle->{
{PointSize->OptionValue[PointSize],Automatic,colouroff},
{PointSize->OptionValue[PointSize],Automatic,colourrest},
{PointSize->OptionValue[PointSize],Automatic,colourmatch}}
	};
	plotdata={off,rest,matching};
	plot=ListPlot[plotdata,plotoptions];

(** End **)
	(* Optional: Store data *)
	If[OptionValue["StoreData"],
	Return[<|
	"Image"->image,
		"ImageGrayscale"->ColorConvert[image,"Grayscale"],
		"ImageNegative"->ColorNegate[image],
		"ImageGrayscaleNegative"->
		ColorConvert[ColorNegate[image],"Grayscale"],
		"ImageBinarised"->Binarize[image],
	"Lattice"->\[CapitalLambda],
	"LatticeBasic"->L,
	"Adjust"->adjust,
	"Plotdata"->rest,
		"PlotdataMatch"->matching,
		"PlotdataWrong"->off,
	"Grids"->grids
	|>
	]];

	(* Plot *)
	If[showgrid,
	Show[grid,plot,plotoptions],
	plot]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@ReciprocalSpaceTool={
"TooltipStyle"->{FontFamily->"Inconsolata",FontSize->14}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReciprocalSpaceTool[
input_String,
system_,
data_List,
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],
OptionsPattern@ReciprocalSpaceTool
]:=Manipulate[
Module[{
xraytemp,lastinput,
adjust,
img,imgN,imgG,imgNG,imgB,
L,pd,pdMatch,pdOff,grids,
sim1,tooltip,SIM1,data2D,
\[CapitalLambda],\[CapitalGamma],\[Xi],\[Chi],r,\[CapitalLambda]1x,\[CapitalLambda]1y,\[CapitalLambda]2x,\[CapitalLambda]2y,p,\[Lambda]1,\[Lambda]2,tx,ty,h1h2,xy,
\[Sigma],\[Tau]x,\[Tau]y,xysim1,hksim1,sim1data,
plots,
plotbackground,
N1,N2,N3,plotoptions,plotaxes,plotgrid},

(** Input check **)
	(* Check temporary variables *)
	Label["CollectData"];
	xraytemp=$XrayTemp;
	lastinput=$XrayTempLast;

	If[update,lastinput="False";update=False];
	If[lastinput===input&&AssociationQ@$XrayTemp,
	(* Use stored data *)
	{img,imgN,imgG,imgNG,imgB,
	\[CapitalLambda],L,adjust,
	pd,pdMatch,pdOff,
	grids}=
	Values@xraytemp[[{
	"Image","ImageNegative","ImageGrayscale",
	"ImageGrayscaleNegative","ImageBinarised",
	"Lattice","LatticeBasic","Adjust",
	"Plotdata","PlotdataMatch","PlotdataWrong",
	"Grids"
	}]],
	(* Collect new data *)
		(* Update temporary variables *)
		$XrayTemp=ReciprocalImageCheck[
		input,system,data,pattern,
		"StoreData"->True];
		(* Update  *)
		$XrayTempLast=input;
		(* Go back and load data *)
		Goto["CollectData"]
	];


(** Plot layers **)
	plots={};

	(* Background image processing *)
	plotbackground=Which[
	LAimage=="Original",img,
	LAimage=="Negative",imgN,
	LAimage=="Grayscale",imgG,
	LAimage=="Negative + Grayscale",imgNG,
	LAimage=="Binarised",imgB,
	True,False
	];

	If[ImageQ@plotbackground,
	AppendTo[plots,plotbackground]];

	(* Grid *)
	If[IntegerQ@LAsize,
	plotgrid=grids[[LAsize]];
	AppendTo[plots,plotgrid]];

	(* Extracted nodes *)
	If[pd!={Null,Null},
	N1enable=True,
	N1enable=False];
	N1=ListPlot[pd,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N1colour,
	Opacity[N1opacity]}}];
	If[N1show,AppendTo[plots,N1]];

	(* Nodes matching condition *)
	If[pdMatch!={Null,Null},
	N2enable=True,
	N2enable=False];
	N2=ListPlot[pdMatch,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N2colour,
	Opacity[N2opacity]}}];
	If[N2show,AppendTo[plots,N2]];

	(* Wrong nodes *)
	If[pdOff!={Null,Null},
	N3enable=True,
	N3enable=False];
	N3=ListPlot[pdOff,Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	N3colour,
	Opacity[N3opacity]}}];
	If[N3show,AppendTo[plots,N3]];


(** Simulated nodes **)
	If[SIM1calc,
	(* Generate simulated nodes *)
	sim1=ReciprocalSpaceSimulation[
	SIM1name,SIM1plane,
	Total[SIM1plane]-1/.-1->SIM1level,
	SIM1res,
	"ReturnData"->True];

	(* Lattice components and misc *)
	{{\[CapitalLambda]1x,\[CapitalLambda]2x},{\[CapitalLambda]1y,\[CapitalLambda]2y}}=\[CapitalLambda];
	{tx,ty}=adjust;
	p=First@Flatten@Position[Total[SIM1plane],0];
	sim1=Delete[sim1,Table[{i,2,p},{i,Length@sim1}]];
	data2D=Partition[Flatten@sim1,4];

	(* Function for calculating residue *)
	r[{x_,y_,h1_,h2_},\[Sigma]_,\[Tau]x_,\[Tau]y_]:=N[
	Sqrt[(\[Sigma]*x+\[Tau]x)^2+(\[Sigma]*y+\[Tau]y)^2]-
	Sqrt[(tx+h1*\[CapitalLambda]1x+h2*\[CapitalLambda]2x)^2+(ty+h1*\[CapitalLambda]1y+h2*\[CapitalLambda]2y)^2]];

	(* Determining scaling factors by iteration *)
	{\[Sigma],\[Tau]x,\[Tau]y}=NonlinearLeastSquares[
	r,data2D,{1000,tx,ty}];
	
	(* Scaling and preparing simulated nodes *)
	xysim1=data2D[[All,{1,2}]];
		xysim1=Round[{\[Tau]x,\[Tau]y}+#&/@(\[Sigma]*xysim1)];
	hksim1=data2D[[All,{3,4}]];
		hksim1=Map[ToMiller,
		Insert[#,SIM1level,{3}]&/@hksim1];

	(* Add tooltip and prepare plot *)
	sim1data=MapThread[Tooltip[#1,#2,
	TooltipStyle->OptionValue["TooltipStyle"]]&,{xysim1,hksim1}];
	
	SIM1=ListPlot[
	sim1data,
	Axes->False,
	PlotStyle->{
	{PointSize->Large,
	Automatic,
	SIM1colour,
	Opacity[SIM1opacity]}}]
	];

	If[SIM1add,
	AppendTo[plots,SIM1]];

(** Plot **)
	plotoptions={
	ImageSize->{OUTx,Floor[1475/1679*OUTx]},
	PlotRange->{{0,1679},{0,1475}},
	AspectRatio->1475/1679,
	ToExpression@OUTframe
	};

	plotaxes=ListPlot[{},plotoptions];
	PrependTo[plots,plotaxes];
	output=Show[plots,plotoptions]
],



(** Manipulation controls **)

	(* Misc initial parameters *)
	{update,False,ControlType->None},

	{OUTx,520,ControlType->None},
	{OUTframe,{"Frame->True"},ControlType->None},

	{LAswitch,False,ControlType->None},
	{LAsize,"Off",ControlType->None},
	{LAimage,"Off",ControlType->None},

	{N1enable,False,ControlType->None},
	{N1switch,False,ControlType->None},
	{N1show,True,ControlType->None},
	{N1colour,ColorData[97,1],ControlType->None},
	{N1opacity,1,ControlType->None},

	{N2enable,False,ControlType->None},
	{N2switch,False,ControlType->None},
	{N2show,True,ControlType->None},
	{N2colour,ColorData[97,2],ControlType->None},
	{N2opacity,1,ControlType->None},

	{N3enable,False,ControlType->None},
	{N3switch,False,ControlType->None},
	{N3show,True,ControlType->None},
	{N3colour,LightGray,ControlType->None},
	{N3opacity,1,ControlType->None},

	{SIM1switch,False,ControlType->None},
	{SIM1colour,ColorData[97,3],ControlType->None},
	{SIM1opacity,1,ControlType->None},
	{SIM1name,"",ControlType->None},
	{SIM1plane,"None",ControlType->None},
	{SIM1level,0,ControlType->None},
	{SIM1res,0.8,ControlType->None},
	{SIM1calc,False,ControlType->None},
	{SIM1add,False,ControlType->None},

	{POswitch,False,ControlType->None},

	{EPswitch,False,ControlType->None},
	{EPformat,"pdf",ControlType->None},
	{EPname,"",ControlType->None},
	{output,True,ControlType->None},


	(* Extracted data *)
	Row[{
	Style["Extracted data",Bold,Medium,16],
	Spacer[160],
	Button["Update",update=True,ImageSize->{65,Automatic}]
	}],
	Delimiter,

		(* Lattice and background *)
		Row[{
		Toggler[Dynamic@LAswitch,{True->#,False->#}&
		@Style["Lattice and background",14]],
		Spacer[5],
		Opener@Dynamic@LAswitch
		}],

		Dynamic@If[LAswitch,
		Panel@Column[{
		Row[{
		Text["Lattice"],
		Spacer[50],
		SetterBar[Dynamic@LAsize,{
		"Off"->"Off",
		1->"Unit vectors",
		2->"1",3->"2",4->"3",5->"4",6->"5",7->"6"}]
		}],

		Row[{
		Text["Background"],
		Spacer[25],
		PopupMenu[Dynamic@LAimage,{
		"Off","Original","Negative","Grayscale",
		"Negative + Grayscale","Binarised"}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Extracted nodes *)
		Dynamic@If[N1enable,
		Row[{
		Toggler[Dynamic@N1switch,{True->#,False->#}&
		@Style["Extracted nodes",14]],
		Spacer[5],
		Opener@Dynamic@N1switch
		}],

		Style["Extracted nodes",14,Gray]
		],

		Dynamic@If[N1switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N1show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N1colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N1opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N1colour=ColorData[97,1];
		N1opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Conditional selection *)
		Dynamic@If[N2enable,
		Row[{
		Toggler[Dynamic@N2switch,{True->#,False->#}&
		@Style["Conditional selection",14]],
		Spacer[5],
		Opener@Dynamic@N2switch
		}],

		Style["Conditional selection",14,Gray]
		],

		Dynamic@If[N2switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N2show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N2colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N2opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N2colour=ColorData[97,2];
		N2opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

		(* Wrong nodes *)		
		Dynamic@If[N3enable,
		Row[{
		Toggler[Dynamic@N3switch,{True->#,False->#}&
		@Style["Wrong nodes",14]],
		Spacer[5],
		Opener@Dynamic@N3switch
		}],

		Style["Wrong nodes",14,Gray]
		],

		Dynamic@If[N3switch,
		Panel@Column[{
		Row[{
		Text["Show"],
		Spacer[77],
		Checkbox@Dynamic@N3show
		}],

		Row[{
		Text["Node colour"],
		Spacer[50],
		ColorSlider[Dynamic@N3colour,ImageSize->{190,30}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[28],
		Slider[Dynamic@N3opacity,{0,1},
		ImageSize->190,
		Appearance->Medium]
		}],

		Row[{
		Spacer[150],
		Button["Reset colour",
		N3colour=LightGray;
		N3opacity=1,
		ImageSize->{100,Automatic}]
		}]
		
		}],
		Row[{}]
		],
	Delimiter,

Spacer[{15,15}],


	(* Simulated data *)	
	Style["Simulated data",Bold,Medium,16],
	Delimiter,

		(* Simulation input 1 *)
		Row[{
		Toggler[Dynamic@SIM1switch,{True->#,False->#}&
		@Style["Simulation input",14]],
		Spacer[5],
		Opener@Dynamic@SIM1switch
		}],

		Dynamic@If[SIM1switch,
		Panel@Column[{

		Row[{
		Text["Input data"],
		Spacer[7],
		InputField[
		Dynamic[SIM1name],
		String,
		FieldHint->"Crystal name",
		FieldSize->14]
		}],
		
		Row[{
		Text["Image plane normal"],
		Spacer[3],
		SetterBar[Dynamic@SIM1plane,{
		{{0,1,0},{0,0,1}}->"\!\(\*SuperscriptBox[\(a\), \(*\)]\)",
		{{1,0,0},{0,0,1}}->"\!\(\*SuperscriptBox[\(b\), \(*\)]\)",
		{{1,0,0},{0,1,0}}->"\!\(\*SuperscriptBox[\(c\), \(*\)]\)"
		}],
		Spacer[5],
		Text["intersecting the plane at"],
		Spacer[5],
		PopupMenu[Dynamic@SIM1level,Reverse@Range[-5,5]]
		}],

		Row[{
		Text["Resolution"],
		Spacer[5],
		Slider[Dynamic@SIM1res,{0.1,5.0,0.05}],
		Spacer[5],
		Dynamic[Row[{
		NumberForm[SIM1res,{3,2}],
		" \!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-1\)]\)"}]]
		}],

		Row[{
		Text["Node colour"],
		Spacer[60],
		ColorSlider[Dynamic@SIM1colour,ImageSize->{192,31}]
		}],

		Row[{
		Text["Opacity of nodes"],
		Spacer[5],
		Slider[Dynamic@SIM1opacity,{0,1}]
		}],

		Row[{
		Button["Add",SIM1calc=SIM1add=True,
		If[SIM1plane==="None"||SIM1name==="",
		Enabled->False,Enabled->True]],
		Spacer[5],
		Button["Remove",SIM1calc=SIM1add=False]
		}]
		}],
		
			Row[{}]
		],


Spacer[{15,15}],


	(* Image controls *)
	Style["Image controls",Bold,Medium,16],
	Delimiter,

		(* Plot options *)
		Row[{
		Toggler[Dynamic@POswitch,{True->#,False->#}&
		@Style["Plot options",14]],
		Spacer[5],
		Opener@Dynamic@POswitch
		}],

		Dynamic@If[POswitch,
		Panel@Column[{

		Row[{
		Text["Plot size"],
		Spacer[10],
		Slider[Dynamic@OUTx,{320,1024,1}]
		}],

		Row[{
		Text["Pixel dimensions"],
		Spacer[10],
		InputField[Dynamic@OUTx,Number,
		ImageSize->30],
		" \[Times] ",
		Dynamic@Floor[1475/1679*OUTx]
		}],

		Row[{
		Text["Plot frame"],
		Spacer[10],
		SetterBar[Dynamic@OUTframe,{
		{"Frame->True"}->"Frame",
		{"Axes->True"}->"Axes",
		{"Axes->False"}->"None"}]
		}]

	}],

		Row[{}]
		],

		(* Export plot *)
		Row[{
		Toggler[Dynamic@EPswitch,{True->#,False->#}&
		@Style["Export plot",14]],
		Spacer[5],
		Opener@Dynamic@EPswitch
		}],

		Dynamic@If[EPswitch,
		Panel@Column[{

		Row[{
		Text["Filename"],
		Spacer[10],
		InputField[Dynamic@EPname,String,FieldHint->"Name"]
		}],

		Row[{
		Text["File format"],
		Spacer[10],
		SetterBar[Dynamic@EPformat,{"jpg","png","pdf"}]
		}],

		Row[{
		Text["Output directory"],
		Spacer[10],
		Button["Desktop",
		Export[FileNameJoin[{
		$HomeDirectory,"Desktop",
		EPname<>"."<>EPformat}],
		output]
		]
		}]

	}],

		Row[{}]
		],




ControlPlacement->Left,
Paneled->False
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
RefinedValues::label="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised label.";
RefinedValues::log="Search for log files has failed.";
RefinedValues::residue="No residue value found.";
RefinedValues::matrix="No `1` matrix was found.";
RefinedValues::mosaicity="No mosaicity values found in \[LeftGuillemet]`1`\[RightGuillemet].";
RefinedValues::wavelength="No wavelength found in \[LeftGuillemet]`1`\[RightGuillemet].";

Options[RefinedValues]={
"ConstrainedCell"->True,
"Uncertainties"->False,
"Units"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RefinedValues[input_String,label_String,OptionsPattern@RefinedValues]:=Module[{
(* Setup *)
files,import,
constrained,uncertainties,units,
allvalues,take,
(* 'Refinement' *)
n0,n,r,
(* 'Wavelength' *)
\[Lambda],c,cInverse,
(* 'InstrumentModel' *)
lattice,latticeU,X,x,\[Delta],
goniometer,detector,rotation,instrument,parameters,
(* 'UB', 'U' and 'B' *)
UB,
(* 'Angles' *)
num,angles,\[Alpha]\[Beta],\[Omega],\[Theta],\[Kappa],\[Phi],
(* 'CorrelationMatrix' *)
m,tags,
(* Miscellaneous *)
temp
},
(*---* Setup *---*)
	(* Label check *)
	If[!MemberQ[{
	"Refinement","UnitCell","Wavelength",
	"InstrumentModel","UB","U","B","Mosaicity",
	"Angles","CorrelationMatrix"},label],
	Message[RefinedValues::label,label];Abort[]];

	(* Input check *)
		(* Scenario 1: Log information given directly *)
		Quiet@If[
		StringTake[input,27]=="Your current setup file is:",
		import=input;
		Goto["ImportDone"]];

		(* Scenario 2: Single log file given *)
		If[FileExistsQ[input]&&StringTake[input,-3]=="txt",
		import=Import[input,"String"];
		Goto["ImportDone"]];

		(* Scenario 3: Log- or project directory given *)
		files=FileNames["*.txt",{input},3];
		If[DirectoryQ[input]&&files!={},
		import=MergeLogs[input];
		Goto["ImportDone"]];		

		(* Finding log failed *)
			Message[RefinedValues::log];
			Goto["End"];

	(* Preparations common for all tasks *)
	Label["ImportDone"];

		(* Options *)
		constrained=OptionValue["ConstrainedCell"];
		uncertainties=OptionValue["Uncertainties"];
		units=OptionValue["Units"];

		(* Making a list to store all the values in *)
		allvalues=<||>;

	Goto[label];


(*---* 'Refinement' *---*)
Label["Refinement"];

	(* Extracting the number of reflections, initially and finally *)
	n0=First@StringCases[import,
	Shortest["UB fit with "~~__~~"out of "~~n0:DigitCharacter..~~" "]:>n0];
	n=Last@StringCases[import,
	Shortest["UB fit with "~~n:DigitCharacter..~~" "]:>n];
	{n0,n}=ToExpression[{n0,n}];
	AppendTo[allvalues,{"ReflectionsInitial"->n0,"ReflectionsFinal"->n}];

	(* Extracting the latest residue parameter *)
	r=StringCases[import,
	"Resid:"~~" "..~~r:{DigitCharacter,"-","."}..:>r];
	If[r=={},Message[RefinedValues::residue];Abort[]];
	r=ToExpression@Last@r;

	(* Optional: Units *)
	If[units,r=100*r;r=Quantity[r,"Percent"]];

	AppendTo[allvalues,"Rint"->r];

Return@allvalues;


(*---* 'UnitCell' *---*)
Label["UnitCell"];

	(* Finding and extracting the lattice parameters *)
	Quiet[
	lattice=StringCases[import,
	Shortest["unit cell:"~~__~~"V"~~__~~EndOfLine]];

		(* Constrained or non-constrained cell *)
		If[constrained,take=-1,take=-2];
		lattice=StringCases[lattice[[take]],
		{DigitCharacter,"-",".","(",")"}..][[;;6]];

		latticeU={};
		Do[
		X=StringCases[lattice[[i]],{DigitCharacter,"-","."}..];
		If[Length[X]==2,
			(* Uncertainty given *)
			x=X[[1]];
			\[Delta]=ToExpression@X[[2]];
			temp=StringLength@First@
			StringCases[x,"."~~n:(DigitCharacter..):>n];
			X={x,N[\[Delta]*10^(-temp)]},

			(* No uncertainty *)
			X=Flatten[{X,0.}]
			];
		AppendTo[latticeU,X],
		{i,Length@lattice}
		];

	(* Optional: Units *)
	temp=<|Thread[{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}->latticeU]|>;
	If[units,
	lattice=Quantity[#,"Angstroms"]&/@temp[[{"a","b","c"}]];
	angles=Quantity[#,"Degrees"]&/@temp[[{"\[Alpha]","\[Beta]","\[Gamma]"}]];
	temp=Join[lattice,angles]];

	(* Optional: Uncertainties *)
	If[!uncertainties,temp=temp[[All,1]]];	

Return@temp];


(*---* 'Wavelength' *---*)
Label["Wavelength"];

	temp=StringCases[import,
	"wavelength: "~~\[Lambda]:{DigitCharacter,"."}..:>\[Lambda]];
	temp=DeleteCases[temp,{}];
	(* Check *)
	If[temp=={},
	(* Exploit that UB is scaled by wavelength *)
	UB=RefinedValues[input,"UB"];
	cInverse=(QRDecomposition@UB)[[-1,-1,-1]];
	c=ToExpression@RefinedValues[input,"UnitCell"]["c"];
	\[Lambda]=Abs[c*cInverse],

	(* Extract directly *)
	\[Lambda]=ToExpression@First@Flatten@temp
	];	

	(* Optional: Units *)
	If[units,\[Lambda]=Quantity[\[Lambda],"Angstroms"]];

Return@\[Lambda];


(*---* 'InstrumentModel' *---*)
Label["InstrumentModel"];

	(* Finding and extracting goniometer and detector data *)
		rotation={
		"Cryst. Rot. X","Cryst. Rot. Y","Cryst. Rot. Z",
		"Cryst. Dance X","Cryst. Dance Y","Cryst. Dance Z"};
		goniometer={
		"Beam. Rot. Y","Beam. Rot. Z",
		"Alpha Value","Beta Value",
		"Omega Offset","Theta Offset","Kappa Offset","Phi Offset"};
		detector={
		"Det. Rot. X","Det. Rot. Y","Det. Rot. Z",
		"Det. Offset X","Det. Offset Y","Det. D. Scale"};
		instrument={rotation,goniometer,detector};
	
		Quiet[
		parameters=Last@DeleteCases[StringCases[import,
#~~" "..~~
v1:{DigitCharacter,"-","."}..~~" "..~~
v2:{DigitCharacter,"-","."}..:>v2],
	x_/;StringLength[x]<=5]&/@#&/@instrument;

		AppendTo[allvalues,
		"Rotation"->Association@
		Thread[{"r1","r2","r3","w1","w2","w3"}->
		parameters[[1]]
	]];
		AppendTo[allvalues,
		"Goniometer"->Association@
		Thread[{"b2","b3","al","be","o0","t0","k0","p0"}->
		parameters[[2]]
	]];
		AppendTo[allvalues,
		"Detector"->Association@
		Thread[{"d1","d2","d3","x0","y0","dd"}->
		parameters[[3]]
	]];

Return@ToExpression@allvalues];


(*---* 'UB' *---*)
Label["UB"];

	(* Extracting the UB matrix *)
	If[StringContainsQ[import,"UM S "~~{"-",DigitCharacter}],
	(* Preferred pattern *)
		UB=AlignUB@Last@
	StringCases[import,Shortest[
	"UM S "~~{"-",DigitCharacter}~~__~~EndOfLine]],

	(* Other method *)
		(* Check *)
		If[!StringContainsQ[import,"UB - matrix:"],
		Message[RefinedValues::matrix,"UB"];Goto["End"]];

		UB=Partition[StringCases[Last@
	StringCases[import,Shortest["UB - matrix:"~~
m:(__~~Repeated[EndOfLine~~__,{3}])]:>m],{DigitCharacter,".","-"}..][[{1,2,3,7,8,9,13,14,15}]],3]
	];

Return@ToExpression@Chop[ToExpression@UB,10^-5];


(*---* 'U' or 'B' *---*)
Label["U"];Label["B"];
x=label;

	(* Check *)
	If[!StringContainsQ[import," "~~x~~" - matrix"],
	Message[RefinedValues::matrix,x];
	Goto["End"]];

	(* Extracting the matrix *)
	temp=StringCases[import,
	Shortest[" "~~x~~" - matrix:"~~
	m:(__~~Repeated[EndOfLine~~__,{4}])]:>m];
	temp=StringCases[Last@temp,
	{DigitCharacter,".","-"}..];
	temp=ToExpression@Partition[temp,3];
	temp=Chop[temp,10^-5];

Return@temp;


(*---* 'Mosaicity' *---*)
Label["Mosaicity"];

	(* Extracting the mosaicities *)
		(* Check *)
		If[!StringContainsQ[import,"Profile size analysis"],
		Message[RefinedValues::mosaicity,FileNameTake@input];
		Goto["End"]];
	
	temp=Last@StringCases[import,
	Shortest["Profile size analysis"~~__~~"|\n\n"]];
	temp=StringExtract[temp,-13;;];
	temp=StringCases[temp,
	DigitCharacter..~~"."~~DigitCharacter..];
	temp=ToExpression@Partition[Flatten@temp,2];

	(* Optional: Units *)
	temp=Quantity[temp,"Degrees"];
	temp=Association@Thread[{"e1","e2","e3"}->temp];
	
	(* Optional: Uncertainties *)
	If[!OptionValue["Uncertainties"],temp=temp[[All,1]]];

Return@temp;


(*---* 'Angles' *---*)
Label["Angles"];

	(* Extracting the diffractometer angles *)
	temp=ToExpression@Last@DeleteCases[StringCases[import,
#~~" "..~~
v1:{DigitCharacter,"-","."}..~~" "..~~
v2:{DigitCharacter,"-","."}..:>v2],
	x_/;StringLength[x]<=5]&/@
	{"Alpha Value","Beta Value"};

	(* Extracting the goniometer angles *)
	num={DigitCharacter,".","-"}..;
	AppendTo[temp,ToExpression@First@StringCases[import,
"om="~~Whitespace~~\[Omega]:num~~WhitespaceCharacter...
~~"th="~~Whitespace~~\[Theta]:num~~WhitespaceCharacter...
~~"ka="~~Whitespace~~\[Kappa]:num~~WhitespaceCharacter...
~~"ph="~~Whitespace~~\[Phi]:num~~WhitespaceCharacter...
:>{\[Omega],\[Theta],\[Kappa],\[Phi]}]];
	temp=Flatten@temp;

	(* Optional: Units *)
	If[units,temp=Quantity[temp,"Degrees"]];

	temp=Association@
	Thread[{"\[Alpha]","\[Beta]","\[Omega]","\[Theta]","\[Kappa]","\[Phi]"}->temp];

Return@temp;


(*---* 'CorrelationMatrix' *---*)
Label["CorrelationMatrix"];

	temp=Last@StringTrim@StringCases[import,
Shortest["Correlation matrix:"~~x__
	~~"                 "]:>x];

	tags=StringTrim@StringCases[temp,
	x:(LetterCharacter~~{LetterCharacter," ",".","*"}..):>x];
	tags=StringReplace[tags,{
	"Det. D. Scale"->"dd",
	"Det. Offset X"->"x0",
	"Det. Offset Y"->"y0",
	"Det. Rot. X"->"d1",
	"Det. Rot. Y"->"d2",
	"Det. Rot. Z"->"d3",
	"Beam. Rot. Y"->"b2",
	"Beam. Rot. Z"->"b3",
	"Cryst. Rot. X"->"r1",
	"Cryst. Rot. Y"->"r2",
	"Cryst. Rot. Z"->"r3",
	"Rec. latt. "~~x__:>x
	}];

	temp=StringTrim@StringCases[temp,Shortest[
{"-",DigitCharacter}~~__~~EndOfLine]];
	temp=ToExpression/@StringSplit[temp,Whitespace];
	m=PadRight[temp,{#,#}]&@Length@tags;

Return[{tags,m}];


(*---* Return message and end procedure *---*)
Label["End"];
]


(* ::Input::Initialization:: *)
RefinedValues[input_String,OptionsPattern@RefinedValues]:=Module[{log},
log=MergeLogs@input;

Association[Quiet[#->RefinedValues[log,#,
"ConstrainedCell"->OptionValue["ConstrainedCell"],
"Uncertainties"->OptionValue["Uncertainties"],
"Units"->OptionValue["Units"]
]]&/@{
	"Refinement","UnitCell","Wavelength",
	"InstrumentModel","UB","U","B","Mosaicity",
	"Angles","CorrelationMatrix"}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@RoundSignificantFigures={
"Prefix"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RoundSignificantFigures[{x_?NumericQ,\[Delta]x_?NumericQ},
OptionsPattern@RoundSignificantFigures]:=Module[{
a,\[Delta],\[Delta]1,\[Delta]2,p1,p2,d,X,\[Delta]X,postfix,output,temp},

(* Extract first two signigicant figures of uncertainty *)
\[Delta]=SetPrecision[\[Delta]x,2];
{\[Delta]1,\[Delta]2}=First@RealDigits@\[Delta];

(* Determining difference in order of magnitude *)
{p1,p2}=(RealDigits[#][[2]]-1)&/@{x,\[Delta]x};
d=p1-p2+1;

Which[
(* Rounding to one digit + zero *)
\[Delta]1==9&&MemberQ[Range[5,9],\[Delta]2],
	X=SetPrecision[x,d];
	\[Delta]X=SetPrecision[Round[\[Delta]x,10^p2],2],

(* Rounding to two digits *)
\[Delta]1==1&&MemberQ[Range[0,5],\[Delta]2],
	X=SetPrecision[x,d+1];
	\[Delta]X=\[Delta],

(* Rounding to one digit *)
True,
	X=SetPrecision[x,d];
	\[Delta]X=SetPrecision[\[Delta]x,1]
];

(* Chopping result *)
output={X,\[Delta]X};

(* Optional: Replace powers with appropriate SI prefix *)
If[OptionValue["Prefix"],
If[Divisible[p1,3]&&p1!=0&&d<=6,
postfix=Which[
p1==-12,"pico",
p1==-9,"nano",
p1==-6,"mikro",
p1==-3,"milli",
p1==3,"kilo",
p1==6,"mega",
p1==9,"giga",
p1==12,"tera"
];

X=X/10^p1;
\[Delta]X=\[Delta]X/10^p1;
output="("<>ToString@X<>" \[PlusMinus] "<>ToString@\[Delta]X<>") "<>postfix
]
];

output
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
UnwarpLayerList::dir="The direction vector must be three-dimensional and numeric.";
UnwarpLayerList::dep="The layer vectors are not linearly independent.";
UnwarpLayerList::dim="One or both of the layer vectors are not three dimensional.";
UnwarpLayerList::extended="\[LeftGuillemet]`1`\[RightGuillemet] has been extended.";
UnwarpLayerList::jobs="Some unwarping jobs are identical. Try increasing the range or step size.";
UnwarpLayerList::steps="\!\(\*
StyleBox[\"CrysAlis\",\nFontSlant->\"Italic\"]\) will only queue 500 jobs at a time.";
UnwarpLayerList::small="Some values are smaller than \!\(\*SuperscriptBox[\(10\), \(-6\)]\).";
UnwarpLayerList::path="\[LeftGuillemet]`1`\[RightGuillemet] is an invalid path.";
UnwarpLayerList::notfound="No existing \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"dcunwarp\", \"Program\"]\) file was found in the export directory.";

Options[UnwarpLayerList]={"ExportDirectory"->FileNameJoin[{$HomeDirectory,"Desktop"}],"AppendToExisting"->False,
"SeparationCommas"->True};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
UnwarpLayerList[
prefix_String,L1_List,L2_List,
{dir_List,start_,end_,stepinput_?NumericQ},
Res_,OptionsPattern[UnwarpLayerList]]:=Module[
{steps,path,output,
len,replacerule,\[Delta],
MakeValue,OriginVector,
const,MakeName,
newL1,newL2,res,line,original,old,new,j,valuestest,
temp},
(* Checking input vectors *)
	If[Length/@Flatten/@{L1,L2}!={3,3},Message[UnwarpLayerList::dim];Abort[]];

(* Ascertaining steps or stepsize *)
	If[stepinput>1,
	steps=stepinput,
	steps=Round[Abs[end-start]/stepinput+1]];

(* Check resolution of the range *)
	If[Abs[end-start]/steps<10^-6-10^-12,Message[UnwarpLayerList::jobs]];
	If[steps>500,Message[UnwarpLayerList::steps]];

(* Path check and setup *)
	path=OptionValue["ExportDirectory"];
	If[!DirectoryQ@path,Message[UnwarpLayerList::path,path];Abort[];];
	output=FileNameJoin[{path,prefix<>".dcunwarp"}];


(* Useful variables *)
	len=StringLength@ToString@steps;
	replacerule={","->"  ",{"{","}"}->""};
	\[Delta]=Min[6,StringLength@ToString@N[(end-start)/(steps-1)]-2];

(* Check if vectors are linearly independent *)
	If[Det[{{L1.L1,L1.L2},{L2.L1,L2.L2}}]==0,
	Message[UnwarpLayerList::dep];Abort[]];

(*---* Making the origin vectors *---*)
	(* Check input form *)
	If[!MatchQ[dir,{_?NumericQ,_?NumericQ,_?NumericQ}],
	Message[UnwarpLayerList::dir]Abort[]];

	MakeValue[i_]:=start+(end-start)/(steps-1)*(i-1);

	OriginVector[i_]:=(
	temp=dir*MakeValue[i];
	temp=AccountingForm@NumberForm[N[temp],{Infinity,6}];
	temp=StringReplace[ToString@temp,replacerule]
	);

	(* Check for duplicates and values smaller than 10^-6 *)
	valuestest=ToString/@Table[MakeValue[j],{j,steps}];
	If[!DuplicateFreeQ@valuestest,Message[UnwarpLayerList::small]];


(*---* Generating names *---*)
	(* Integer Miller indices *)
	const=dir+{"h","k","l"}/.a_+b_->0;

	(* Procedure *)
	MakeName[i_]:=(
	temp=ToExpression@StringSplit@OriginVector[i];
	If[\[Delta]==0,(* Integers only? *)
	temp=Rationalize@temp,
	temp=NumberForm[
	#,{Infinity,\[Delta]},
	ExponentFunction->(Null&)]&/@temp];
	temp=const+temp/.x_String+y_:>x;
	If[OptionValue["SeparationCommas"],
	(* Remove separating commas? *)
	temp=StringRiffle[ToString/@temp,","],
	temp=ToString/@temp];
	StringJoin["\"",prefix,"_(",temp,")\""]
	);

(* The L1 and L2 vectors *)
	newL1=StringReplace[ToString@NumberForm[L1,{Infinity,6}],replacerule];
	newL2=StringReplace[ToString@NumberForm[L2,{Infinity,6}],replacerule];

(* The resolution *)
	res=ToString@NumberForm[Res,{Infinity,6}];

(* Function that writes a single line *)
	line[i_]:=StringJoin[MakeName[i],"   ",OriginVector[i],"     ",newL1,"     ",newL2,"        ",res,"       ","0","       ","0"];

(* Generating and exporting table *)
	If[OptionValue["AppendToExisting"],
	original=FileNames[OptionValue["ExportDirectory"]<>"/*.dcunwarp"];
	If[original=={},Message[UnwarpLayerList::notfound];Abort[]];
	old=Import[First@original,"String"];
	new=Table[line[i]<>If[i<steps,"\n",""],{i,steps}];
	Export[original,old<>If[StringTake[old,-1]=="0","\n",""]<>new,"String"];
	Message[UnwarpLayerList::extended,FileNameTake@First@original],	

	Export[output,Table[line[i],{i,steps}],"Table"]]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
WeightedMean::numeric="Numeric input only.";
WeightedMean::invalid="Invalid input form.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
WeightedMean[data_List]:=Module[{
n,sum,x,d,\[Sigma],m,
w,sumw,sumxw,wx,sumxn,\[Sigma]i,\[Sigma]e},

(** Check input **)
	If[!AllTrue[Flatten@data,NumericQ],
	Message[WeightedMean::numeric];Abort[]];

	Which[
	Depth[data]==2,Goto["WithoutWeights"],
	MatchQ[Dimensions[data],{_,2}],Goto["WithWeights"],
	True,Message[WeightedMean::invalid];Abort[]];

(** Data without weights **)
	Label["WithoutWeights"];

	(* Useful variables *)
	n=Length@data;
		If[n==1,
		Return[{First@data,Indeterminate,Indeterminate}]];
	sum=N@Total@data;
	x=sum/n;
	d=data-x;

	(* Standard deviations *)
	\[Sigma]=Sqrt[Total[d^2]/(n-1)];
	m=\[Sigma]/Sqrt[n];

	Return[{x,\[Sigma],m}];

(** Data with weights **)
	Label["WithWeights"];

	(* Useful variables *)
	n=Length@data;
		If[n==1,
		Return[{data[[1,1]],Indeterminate,data[[1,2]]}]];
	{x,\[Sigma]}=N@Transpose@data;
	w=1/\[Sigma]^2;
	sumw=Total[w];
	sumxw=x.w;

	wx=sumxw/sumw;

	(* Standard deviation (internal) *)
	\[Sigma]i=1/Sqrt[sumw];

	(* Standard deviation (external) *)
	d=x-wx;
	sumxn=w.d^2;
	\[Sigma]e=Sqrt[sumxn/((n-1)*sumw)];

	Return[{wx,\[Sigma]i,\[Sigma]e}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* End previous subcontext and Stians` package *)
End[];
EndPackage[];
