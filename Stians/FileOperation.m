(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["Stians`FileOperation`"];


(* ::Input::Initialization:: *)
(* Import usage messages from file *)


(* ::Input::Initialization:: *)
<< "Stians/Messages/StiansFileOperation.txt"


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ChangeExtension[input_,newext_String]:=
Module[{path,file,extension,name,output},
(* Input metadata *)
	path=DirectoryName@input;
	file=FileNameTake@input;

(* Extracting extension and preparing output *)	extension=First@StringReverse@StringCases[StringReverse@file,__~~".",1];
	name=StringDrop[file,-StringLength@extension];
	output=StringJoin[path<>name<>"."<>newext];

RenameFile[input,output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
SyncSpellings::one="Input consists of only one dictionary.";
SyncSpellings::missing="File \[LeftGuillemet]`1`\[RightGuillemet] was not found.";
SyncSpellings::done="Update`1` completed.";
SyncSpellings::inv="Invalid input format.";

Options[SyncSpellings]={"Remove"->{}};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SyncSpellings[input__String,OptionsPattern[SyncSpellings]]:=Module[{checked,new,remove,afterfilter},
(* Checking input *)
	If[checked,Goto["checked"]];
	If[Length[{input}]==1,Message[SyncSpellings::one];Abort[]];
	If[!FileExistsQ[#],Message[SyncSpellings::missing,#];Abort[]]&/@{input};

(* Merging dictionaries *)
	Label["checked"];
	new=Sort@DeleteDuplicates@Flatten[StringSplit@Import[#,"Text"]&/@{input}];

(* Optional: Remove word(s) from the dictionary *)
	If[Depth[#]==1,remove={#},remove=#]&@OptionValue["Remove"];
	afterfilter=DeleteCases[new,x_/;MemberQ[remove,x]];

(* Rewriting the old files with the new version *)
	Export[#,afterfilter,"Text"]&/@{input};

Message[SyncSpellings::done,""]
]


(* ::Input::Initialization:: *)
SyncSpellings[input__List]:=Module[{all,depthcheck,checked},
(* Checking input *)
	all={input};
	depthcheck=DeleteCases[all,"Remove"->_List,{2}];
	If[Depth[depthcheck]!=3,Message[SyncSpellings::inv];Abort[]];
	If[!FileExistsQ[#],Message[SyncSpellings::missing,#];Abort[]]&/@Flatten@depthcheck;

(* Processing each dictionary batch *)
	Off[SyncSpellings::done];
	checked=True;
	Do[SyncSpellings@@all[[i]],{i,Length@all}];
	On[SyncSpellings::done];

Message[SyncSpellings::done,"s"]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
SyncTexitEasy::done="TexitEasy configuration files were copied successfully from `1` to `2`.";
SyncTexitEasy::uptodate="Nothing to update.";

Options@SyncTexitEasy={
"LocalPaths"-><|
"MacOSX"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud"|>,
"ShowDialogue"->True,
"ForceCopyFrom"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SyncTexitEasy[OptionsPattern@SyncTexitEasy]:=Module[{
cloudDir,dialogueQ,
configDirSystem,libraryDirSystem,configDirCloud,libraryDirCloud,
dirs,configDir,libraryDir,
forceOpt,files,top,newest,newestSource,copyFrom,
buttonRow,
temp
},
(* Check local paths *)
cloudDir=OptionValue["LocalPaths"][$OperatingSystem];
dialogueQ=OptionValue["ShowDialogue"];

(* Directories *)
configDirSystem="/Users/Stian/.config/texiteasy.com";
libraryDirSystem="/Users/Stian/Library/Application Support/TexitEasy/TexitEasy";
configDirCloud=FileNameJoin[{
cloudDir,"Prosjekter/Programoppsett/TexitEasy-oppsett"}];
libraryDirCloud=FileNameJoin[{
cloudDir,"Prosjekter/Programoppsett/TexitEasy-oppsett/Bibliotek-mappe"}];

dirs={
configDirSystem,libraryDirSystem,
configDirCloud,libraryDirCloud
};

configDir=FileNameJoin[{configDirCloud,"Config-mappe"}];
libraryDir=FileNameJoin[{configDirCloud,"Bibliotek-mappe"}];

	(* Option: Force copy *)
	forceOpt=OptionValue["ForceCopyFrom"];
	Which[
	forceOpt==="System",copyFrom="System";Goto["Copy"],
	forceOpt==="Cloud",copyFrom="Cloud";Goto["Copy"]];

	(* Any directories missing? *)
	If[!AllTrue[dirs[[{1,2}]],DirectoryQ],
	copyFrom="Cloud";
	If[dialogueQ,Goto["Dialogue"],Goto["Copy"]]];
	If[!AllTrue[dirs[[{3,4}]],DirectoryQ],
	copyFrom="System";
	If[dialogueQ,Goto["Dialogue"],Goto["Copy"]]];

(* Find newest; 'push' to cloud or 'pull' from cloud *)
files=FileNames["*",{#},Infinity]&/@dirs;
	(*files=DeleteCases[files,x_/;StringTake[#,1]==="."&,Infinity];*)
top=Check[
	Flatten[TakeLargestBy[#,(FileDate[#,"Modification"]&),1]&/@files],
	Abort[]];
	(* Nothing new? *)
	If[!dialogueQ&&Abs[Subtract@@(
UnixTime@FileDate[top[[#]],"Modification"]&/@{2,4}
)]<30,
	Message[SyncTexitEasy::uptodate];Goto["End"]];
newest=First@TakeLargestBy[top,(FileDate[#,"Modification"]&),1];
newestSource=Select[dirs,StringContainsQ[DirectoryName@newest,#]&];
copyFrom=If[SubsetQ[{configDirSystem,libraryDirSystem},newestSource],"System","Cloud"];

(* Dialogue *)
Label["Dialogue"];
temp=If[copyFrom==="System",{"System","Cloud"},{"Cloud","System"}];

buttonRow={Spacer[200],
DefaultButton[#1,DialogReturn[#1]],
Spacer[5],
Button[#2,DialogReturn[#2]]}&@@temp;

copyFrom=DialogInput[
Column[{Style[
"Choose where to copy from.\nMost recently modified: "<>copyFrom,13],
Spacer[20],
Row[buttonRow]
}],
WindowTitle->"Sync TexitEasy settings"];

If[copyFrom===$Failed,Abort[]];

(* Delete and copy *)
Label["Copy"];
If[
copyFrom==="System",
(* 'System' --> 'Cloud' *)
DeleteDirectory[configDirCloud,DeleteContents->True];
CreateDirectory[configDirCloud];
CopyDirectory[configDirSystem,configDir];
CopyDirectory[libraryDirSystem,libraryDir],

(* 'Cloud' --> 'System' *)
DeleteDirectory[configDirSystem,DeleteContents->True];
CopyDirectory[configDir,configDirSystem];
DeleteDirectory[libraryDirSystem,DeleteContents->True];
CopyDirectory[libraryDir,libraryDirSystem]
];

(* Report *)
temp={"system","cloud"};
If[copyFrom==="Cloud",temp=Reverse@temp];

Message[SyncTexitEasy::done,temp[[1]],temp[[2]]];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
GetWallpapers::noNew="No new images found.";
GetWallpapers::invURL="Invalid URL.";

Options@GetWallpapers={
"DownloadDirectory"->"/Users/Stian/Pictures/InterfaceLIFT (2560x1440)",
"Resolution"->"2560x1440",
"PageIndex"->1
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetWallpapers[OptionsPattern@GetWallpapers]:=Module[{
url,resolution=OptionValue["Resolution"],htmlData,itemData,
downloadDir=OptionValue["DownloadDirectory"],
imageIDs,archivedIDs,newIDs,
archived,newTitles,
commentData,thumbnailData,downloadURLdata,data,
userSelected,
n,k,
temp},

(*---* A. Organising archived images and URL data *---*)
(* A.1. Fetching latest wallpapers from InterfaceLift.com *)
url="https://interfacelift.com/wallpaper/downloads/date/wide_16:9/"<>resolution<>"/index"<>ToString@OptionValue["PageIndex"]<>".html";
htmlData=Check[
URLRead[url,"Content"],
Return@url];
If[Head@htmlData===Failure,Return@htmlData];

itemData=Association@StringCases[htmlData,Shortest[
"<div id=\"list_"~~Longest[idNumber:DigitCharacter..]~~__~~
		"High-resolution desktop wallpaper "~~
title__~~" by"
]:>{ToExpression@idNumber->StringDelete[title,{"!","..."}]}];

imageIDs=Keys@itemData;

(* A.2. Check with storage directory to see if already downloaded *)
archived=FileNames["*.jpg"~~{"",".icloud"},{downloadDir}];
archived=FileNameTake/@archived;

archivedIDs=Flatten@StringCases[archived,
Shortest["("~~idNumber:DigitCharacter..~~")"
]:>ToExpression@idNumber];

newIDs=Complement[imageIDs,archivedIDs];

	(* End if no new images *)
	If[newIDs==={},Message[GetWallpapers::noNew];
	Goto["End"]];

itemData=KeySelect[itemData,MemberQ[newIDs,#]&];
itemData=StringReplace[#,{"/","\\"}->"-"]&/@itemData;
newTitles=Values@itemData;

(* A.3. Photographers' comments *)
commentData=Association@StringCases[
htmlData,Shortest[
"<div class=\"details\""~~__~~
"/wallpaper/details/"~~idNumber:(ToString/@newIDs)~~__~~
"<"~~__~~"<p>"~~comment___~~"</p>"]
:>{ToExpression@idNumber->StringTrim@comment},
IgnoreCase->True];

(* A.4 Thumbnails of new images *)
thumbnailData=Association@StringCases[htmlData,Shortest[
"<div id=\"list_"~~Longest[idNumber:DigitCharacter..]~~__~~
		url:("http://interfacelift.com/wallpaper/previews/"~~__~~"672x420.jpg")]
:>{ToExpression@idNumber->url}];
thumbnailData=KeySelect[thumbnailData,MemberQ[newIDs,#]&];
thumbnailData=URLExecute/@thumbnailData;

(* A.5 URL preparations *)
downloadURLdata=StringCases[htmlData,Shortest[
url:("href=\"/wallpaper/"~~Except[WhitespaceCharacter]..~~
"/"~~IntegerString[newIDs,10,5]~~__~~resolution<>".jpg")
]:>StringReplace[url,"href=\""->"https://interfacelift.com"]];
temp=Flatten@StringCases[downloadURLdata,
Shortest["/wallpaper/"~~__~~"/0"~~id:DigitCharacter..~~"_"]:>id];
downloadURLdata=Association@Thread[
ToExpression@temp->downloadURLdata];

(* A.6. Merging data associations *)
data=Merge[{itemData,thumbnailData,commentData,downloadURLdata},Identity];
data=SortBy[data,#0&];


(*---* B. Selection and download of images *---*)
(* B.1. Function for displaying thumbnails *)
i=1;
L=Length@data;
userSelected={};
f[i_]:=ChoiceDialog[Column[{
Style[data[[i,1]],24,FontFamily->"Avenir Next"],
Show[data[[i,2]],ImageSize->750],
Style[data[[i,3]],14,FontFamily->"Avenir Next",LineIndent->0]
}],
{
"Queue"->True,
"Skip"->False},
WindowTitle->"Wallpaper selection",
WindowSize->{750,All}
];
Label["Return"];
AppendTo[userSelected,f[i]];i++;
If[i<=L,Goto["Return"]];

userSelected=Pick[data,userSelected,True];

	(* None selected? *)
	If[userSelected===<||>,
	Message[GetWallpapers::noNew];Goto["End"]];

temp=Check[userSelected[[All,{1,4}]],Abort[]];

(* B.2 Download *)
(* Dynamic status *)
n=0;
k=Length@temp;

PrintTemporary[
Row[
{Text[Style["Wallpaper download progress:",FontFamily->"Avenir Next",16]],
Spacer[20],
Dynamic@ProgressIndicator[n/k],
Spacer[20],

Dynamic[Text[Style["Downloaded: "<>ToString[n]<>" of "<>ToString[k],FontFamily->"Avenir Next",12]]]
},
Alignment->Center
]];

(* Actual download *)
Do[
URLSave[temp[[i,2]],FileNameJoin[{downloadDir,
"("<>ToString[(Keys@temp)[[i]]]<>") "<>
temp[[i,1]]<>".jpg"}]
];
n++,
{i,Length@temp}];

(* Messages *)
If[temp==={},
Print[Text[Style["All images already downloaded",FontFamily->"Avenir Next",16]]],
Print[Text[Style["Download completed",FontFamily->"Avenir Next",16]]]
];

Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
GifGenerator::names="Invalid dimensions of custom name list.";
GifGenerator::namestring="Some of the names are not strings.";
GifGenerator::invalid="Invalid \[LeftGuillemet]Names\[RightGuillemet] option.";
GifGenerator::format="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";

Options[GifGenerator]={
"Time"->0.1,
"GifName"->False,
"OutputDirectory"->False,
"Format"->"gif",
"BackwardsLoop"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GifGenerator[input_List,OptionsPattern@GifGenerator]:=Module[{
L,autoimport,format,
data,progress,image,
data1,data2,
gifname,dir,random,temp},

(* Checking input form *)
	L=Length@input;
		Off[FileExistsQ::fstr];
	If[Check[FileExistsQ@First@input,Abort[]],
	autoimport=True,
	autoimport=False,
	autoimport=False];
		On[FileExistsQ::fstr];

	format=OptionValue["Format"];
	If[!MemberQ[{"gif","mp4"},format],
	Message[GifGenerator::format,format]];

(* Importing data if necessary *)
	If[autoimport,
	(* Dynamic status *)
	data={};
	progress=0;
	PrintTemporary[
	Row[
	{Text[Style["Image import progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Imported: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

	Do[
	image=Import@input[[i]];
	AppendTo[data,image];
	progress++,
	{i,L}],	

	(* No import *)
	data=input];

(* Optional: Backwards loop *)
	If[OptionValue["BackwardsLoop"],
	data1=data;
	data2=Rest@Reverse@data;
	data=Join[data1,data2]
	];

(* Making the name of the gif *)
	If[ImageQ[First@input],
	gifname="output",
	If[StringContainsQ[FileNameTake@First@input,"_"],
	gifname=StringDrop[First@StringCases[FileNameTake@First@input,__~~"_"],-1],
	gifname="output"]];

	If[StringQ@OptionValue["GifName"],gifname=OptionValue["GifName"]];

(* Checking output directory *)
	If[autoimport,
	(* Use source directory *)
		dir=FileNameTake[First@input,{1,-2}],
	(* Use desktop *)
		dir=FileNameJoin[{$HomeDirectory,"Desktop"}]
	];

	If[OptionValue["OutputDirectory"],Null,Null,dir=OptionValue["OutputDirectory"]];

(* Optional: Exporting to a .mp4 video *)
	If[format==="mp4",
	random=ToString@RandomInteger[10^10];
	temp=FileNameJoin[{dir,"tempname"<>random<>".mov"}];
	Export[
	temp,
	data,
	"VideoEncoding"->"MPEG-4 Video",
	"FrameRate"->1/OptionValue["Time"]];
	
	Return@RenameFile[
	temp,
	FileNameJoin[{dir,gifname<>".mp4"}],
	OverwriteTarget->True]
	];

(* Exporting gif *)
	If[format==="gif",
	Return@Export[
	FileNameJoin[{dir,gifname<>".gif"}],
	data,
	"DisplayDurations"->OptionValue["Time"]]
	];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
TagImages::images="Some of the images or file paths were invalid.";
TagImages::tags="Invalid dimensions of tag list.";
TagImages::tagstrings="Some of the tags are not strings.";
TagImages::format="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid output format.";

Options@TagImages={
"ExportTo"->"InputDirectory",
"Style"->{White,"Inconsolata",54},
"ImageFormat"->"png",
"NewName"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
TagImages[input_,tags_List,OptionsPattern@TagImages]:=
Module[{
images,type,L,
tagsLB,tagsRB,progress,i,firstimage,dim,Lspace,Rspace,Bspace,
oldbasename,newnamesf,newnames,nnOption,
inputdir,outputdir,format,
s1,s2,s3,image,new1,new2},

(* Checking input form *)
	images=Flatten[{input}];
	Which[
	AllTrue[images,ImageQ],
		type="image",
	AllTrue[images,FileExistsQ],
		type="string",	
	True,Message[TagImages::images];Abort[]
	];
	
	L=Length@images;

	(* Check format of tags *)
	If[Not[Dimensions[tags]=={L,2}],
	Message[TagImages::tags];Abort[]];

	If[!AllTrue[Flatten@tags,StringQ],
	Message[TagImages::tagstrings];Abort[]];

	(* Check image output format *)
	format=ToLowerCase@OptionValue["ImageFormat"];
	format=StringReplace[format,"jpeg"->"jpg"];
	If[!MemberQ[{"jpg","png"},format],
	Message[TagImages::format,format];Abort[]];

(* Preparing *)
	tagsLB=tags[[All,1]];
	tagsRB=tags[[All,2]];
	progress=0;
	i=1;

	firstimage=Which[
	type=="string",Import@First@images,
	type=="image",First@images];
	dim=ImageDimensions@firstimage;

	Lspace=Round[0.015*First@dim];
	Rspace=Round[0.985*First@dim];
	Bspace=Round[0.03*Last@dim];

(* Dynamic status *)
	PrintTemporary[
	Row[
	{Text[Style["Image conversion progress:",FontFamily->"Avenir Next",16]],
	Spacer[20],
	Dynamic@ProgressIndicator[progress/L],
	Spacer[20],
	Dynamic[Text[Style["Converted: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Avenir Next",12]]]
	},
	Alignment->Center
	]];

(* New names *)
	newnamesf[old_]:=old<>"_"<>
	IntegerString[#,10,StringLength@ToString@L]&/@Range@L;
	nnOption=OptionValue["NewName"];

	Which[
	type=="string",
	Which[
	(* File name input, use numeric names *)
	TrueQ@nnOption,
	oldbasename=First@StringCases[StringTake
	[FileNameTake@First@images,{1,-5}],__~~LetterCharacter];
	newnames=newnamesf@oldbasename,

	!TrueQ@nnOption,
	(* File name input, keep old names *)
	newnames=FileBaseName/@FileNameTake/@images,

	StringQ@nnOption,
	(* File name input, custom base name *)
	newnames=newnamesf@nnOption
	],

	type=="image",
	Which[
	StringQ@nnOption,
	(* Image intput, custom base name *)
	newnames=newnamesf@nnOption,

	(* Image input, defualt 'Output' name *)
	True,
	newnames=newnamesf["Output"]
	]
	];

(* Export directory *)
	Which[
	DirectoryQ@OptionValue["ExportTo"],
	(* Option: Custom output directory *)
	outputdir=OptionValue["ExportTo"],

	type=="image",
	(* If images, export to desktop *)
	outputdir=FileNameJoin[{
	$HomeDirectory,"Desktop","Output"}],

	type=="string",
	(* Use input directory *)
	inputdir=DirectoryName@First@images;
	outputdir=FileNameJoin[{inputdir,"Output"}]
	];
	Quiet@CreateDirectory@outputdir;

(*---* Procedure *---*)
	Label["StartProcedure"];

	(* Marking *)
	{s1,s2,s3}=OptionValue["Style"];

	Do[
	image=Which[
	type=="string",
		Import@images[[i]],
	type=="image",
		images[[i]]
	];

	new1=ImageCompose[
	image,
	Graphics[
	Text[
	Style[tagsLB[[i]],s1,FontFamily->s2,s3],
	{0,0},{Left,Center}]],{Lspace,Bspace}];

	new2=ImageCompose[
	new1,
	Graphics[
	Text[
	Style[tagsRB[[i]],s1,FontFamily->s2,s3],
	{0,0},{Right,Center}]],{Rspace,Bspace}];

	(* Export *)
	Export[FileNameJoin[{outputdir,
	newnames[[i]]<>"."<>format}],
	new2];
	
	progress++,
	{i,L}];

Print[
ToString[progress]<>" "<>
If[L==1,"image","images"]<>
" were exported to \[LeftGuillemet]"<>
ToString[outputdir]<>"\[RightGuillemet]."
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
ExtractUsage::mode="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised mode.";
ExtractUsage::link="The function name \[LeftGuillemet]`1`\[RightGuillemet] needs to be a hyperlink.";

Options@ExtractUsage={
"Mode"->"Normal"
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExtractUsage[notebook_String,OptionsPattern@ExtractUsage]:=Module[
{nb,packageName,functionName=FileBaseName@notebook,check,data,
L,starts,intervals,usages,span,
specialStart,specialEnd,wrap,messages,s,arg,info,startSpace,line,
temp},

(* Get main usage cell from (undeployed) documentation notebook *)
nb=Check[NotebookOpen[notebook,Visible->False],Abort[]];
SetSelectedNotebook@nb;
check=False;
While[check===False,
SelectionMove[nb,Next,Cell];
data=NotebookRead[nb];
check=Quiet[(data[[2]]==="Usage")]
];
NotebookClose[nb];

(* Find intervals with usage information *)
temp=data[[1,1]];
L=Length@temp;
starts=starts=1+Position[temp,"ModInfo",Infinity][[All,1]];
If[MatchQ[starts,{_Integer}],
intervals={{starts[[1]],L}},
intervals=Table[{starts[[i]],starts[[i+1]]-2},{i,Length@starts-1}];
intervals=Join[intervals,{{intervals[[-1,2]]+2,L}}]
];

span=Span[#[[1]],#[[2]]]&/@intervals;
usages=Part[temp,#]&/@span;

(* Extraction *)
specialStart="\!\(\*";
specialEnd="\)";
wrap[input_]:=Module[{x=ToString@input},
If[StringContainsQ[x,"Box"],x,"\""<>x<>"\""]];

messages={};
Do[
s=usages[[l]]/.x_ButtonBox:>First@x;
s=ToExpression@StringDelete[ToString@FullForm@s,{"\\[LineSeparator]","\\n"}];

Which[
Cases[s,"[",Infinity]==={},(* Function name only *)
arg=functionName,

MatchQ[s[[1,1,1,1]],{functionName,"[","]"}],(* Void function *)
arg=ToString@RowBox[{"\""<>functionName<>"\"","\""<>"[]"<>"\""}],

True,
arg=s[[1,1,1,1,3;;-2]];
If[Depth@arg<5,
arg=RowBox[{functionName,"[",First@arg,"]"}],
arg=Insert[arg,{functionName,"["},{1,1,1}];
arg=Insert[arg,"]",{1,1,-1}];
arg=FlattenAt[First@arg,{1,1}]];
arg=wrap//@arg
];

info=s[[2;;]]/.s_String:>"\""<>s<>"\"";
info=info/.s_String:>StringDelete[s,{"\[LineSeparator]","\n"}];
startSpace=If[StringTake[info[[1]],{2}]===" ",""," "];
info=ToString@RowBox@info;

line=specialStart<>arg<>specialEnd<>startSpace<>specialStart<>info<>specialEnd;

AppendTo[messages,line],
{l,Length@intervals}];

(* Optional: Include package- and function name *)
If[OptionValue["Mode"]==="Full",
packageName=First@StringCases[
notebook,name:Except["/"]..~~"/Documentation":>name];
messages={packageName,functionName,messages}];

(* Returning information *)
messages
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Attributes *)


(* ::Input::Initialization:: *)
SetAttributes[ExtractUsage,Listable]


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
NeatUsage::error="The usage is neither a string nor a list of strings.";
NeatUsage::dir="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid directory.";

Options[NeatUsage]={
"DocumentationHyperlink"->False,
"Mode"->"Normal",
"OverwriteAutomatically"->True,
"WriteTo"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
NeatUsage[{application_String,symbol_Symbol},usage_,OptionsPattern@NeatUsage]:=
Module[
{mode,L,usagelist,messagelist,
cleared1,cleared2,cleared3,cleared4,
arguments,rules,message,nogap,complete,f,
outputfile,old,windowtext,decision,case},

(** Analysing input **)
	
	(* Message may already be formatted *)
		mode=OptionValue["Mode"];
		If[StringContainsQ[
		ToString[usage,StandardForm],
		"StyleBox"|"SubscriptBox"],
			mode="Formatted"];
		
		If[mode=="Formatted",
		If[ListQ@usage,
		messagelist=usage,
		messagelist={usage}];
		Goto["FormattingDone"]];

	(* Input form *)
	Which[
	ToString[Head@usage]=="String",
		L=1;
		usagelist={usage},
	ToString[Head@usage]=="List",
		If[!AllTrue[usage,StringQ],
		Message[NeatUsage::error];Abort[]];
		L=Length@usage;
		usagelist=usage,
	True,Message[NeatUsage::error];Abort[]];


(** Formatting one or several messages **)
	messagelist={};
	Do[

(* Formatting usage message *)
	(* In case function name contains '$' *)
	cleared1=StringCases[usagelist[[i]],"$"~~LetterCharacter..~~_];
	cleared2=StringTrim@DeleteCases[cleared1,x_/;StringTake[x,-1]=="$"];
	cleared3=StringReplace[cleared2,"$"->"\[Section]"];
	cleared4=StringReplace[usagelist[[i]],Thread[cleared2->cleared3]];
	
	arguments=StringCases[cleared4,Shortest["$"~~__~~"$"]];

	rules=Table[
	arguments[[i]]->"\!\(\*\nStyleBox[\""<>arguments[[i]]<>"\", \"TI\"]\)",
	{i,Length@arguments}];

	message=StringReplace[cleared4,rules];
	message=StringDelete[message,"$"];
	message=StringReplace[message,"\[Section]"->"$"];

(* Processing subscripts *)
	nogap=WordCharacter..|Except[" ",Except[" "]..~~", "~~Except[" "]..]..;

	message=StringReplace[message,
	pre:nogap~~"_"~~sub:nogap:>"\!\(\*SubscriptBox[\("<>pre<>"\), \("<>sub<>"\)]\)"];

(* Correcting ellipses *)
	message=StringReplace[message,"..."->"\[Ellipsis]"];

(* Correcting spaces between arguments *)
	message=StringReplace[message,
	{"\"TI\"]\),\!\(\*\nStyleBox["->"\"TI\"], \*\nStyleBox[",
	"\"TI\"]\),{\!\(\*\nStyleBox["->"\"TI\"]\), {\!\(\*\nStyleBox[",
	"\"TI\"]\)},\!\(\*\nStyleBox["->"\"TI\"]\)}, \!\(\*\nStyleBox["}];

	AppendTo[messagelist,message],
	{i,L}];


(** Preparing the usage layout **)
	Label["FormattingDone"];
	complete=Riffle[messagelist,"\n"];

(* Appending hyperlink to the documentation *)
f=ToString@symbol;
If[TrueQ@OptionValue["DocumentationHyperlink"],
	complete[[-1]]=
	ToString[Row[
	{
	complete[[-1]],
	"   ",
	Hyperlink["\[RightSkeleton]","paclet:"<>application<>"/ref/"<>f,
	ActiveStyle->None]
	}
	],StandardForm]
];

(* Setting the usage *)
	outputfile=ToString@OptionValue["WriteTo"];
	message=StringJoin@complete;

	If[DirectoryName[outputfile]==""||!DirectoryQ@DirectoryName@outputfile,
	symbol::usage=message;
	Return@Information[symbol,LongForm->False]
	];


(** Option: Store usage messages **)

(* Check if output file already exists *)
	If[!FileExistsQ@outputfile,
	Check[Export[outputfile,""],Abort[]];
	old="",
	old=Check[ReadString@outputfile,Abort[]]
	];

(* Check if file already contains the symbol *)
	If[StringContainsQ[old,StartOfLine~~f<>"::usage="],
	If[!OptionValue["OverwriteAutomatically"],
	windowtext=StringJoin[
	{"A usage message for \[LeftGuillemet]",
	f,
	"\[RightGuillemet] already exists in \[LeftGuillemet]",
	FileNameTake@outputfile,
	"\[RightGuillemet].\nWould you like to overwrite the old message?"}];

	decision=ChoiceDialog[windowtext,
	{"No"->False,"Yes"->True},
	WindowTitle->"Overwrite usage message",
	WindowFloating->True];
		
	If[!decision,Abort[]]
	];

	(* Replacing old message *)
		case=StringReplace[old,
		Shortest[f<>"::usage="~~__~~";"]->
		f<>"::usage="<>ToString@FullForm@StringJoin@message<>";"];
		
		Return@Export[outputfile,case]
		];


(* Append new usage *)
	WriteString[outputfile,
	old,
	f<>"::usage="<>ToString@FullForm@StringJoin@message,
	";\n\n\n"];

	Close@outputfile
]


(* ::Input::Initialization:: *)
NeatUsage[notebook_String,output_String,OptionsPattern@NeatUsage]:=
Module[{info},
(* Extract information from notebook *)
	info=ExtractUsage[notebook,"Mode"->"Full"];

(* Check output directory *)
	If[DirectoryName[output]==""||!DirectoryQ@DirectoryName@output,
	Message[NeatUsage::dir,DirectoryName@output];Abort[]];

(* Write information to output file *)
	NeatUsage[{info[[1]],ToExpression@info[[2]]},info[[3]],
	"Mode"->"Formatted",
	"WriteTo"->output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation::missingFile="Cannot find the file for \[LeftGuillemet]`1`\[RightGuillemet].";
CopyDefinitionCodeToDocumentation::nbEditor="\[LeftGuillemet]`1`\[RightGuillemet] does not appear to be open. Recall that this function has to be run in the 'Notebook Editor' front end.";
CopyDefinitionCodeToDocumentation::missingDocTools="Missing \[LeftGuillemet]DocumentationTools\[RightGuillemet] from Applications.";

Options@CopyDefinitionCodeToDocumentation={
"DocumentationSymbolsDir"->"/Users/Stian/Jottacloud/UiS/Mathematica project/GitHub/MaXrd/Documentation/English/ReferencePages/Symbols",
"DefinitionFile"->"/Users/Stian/Jottacloud/UiS/Mathematica project/GitHub/MaXrd/Core/Definitions.nb",
"ShowNotebooks"->False,
"TestRun"->False,
"OpenedWindowsMode"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation[symbol_String,OptionsPattern@CopyDefinitionCodeToDocumentation]:=
Module[
{symbolsDocDir,definitionsFile,targetFile,
showQ,testRunQ,windowModeQ,
nb,check,data,cells,
temp},

(*---* File and directory setup *---*)
symbolsDocDir=OptionValue["DocumentationSymbolsDir"];
definitionsFile=OptionValue["DefinitionFile"];
Check[targetFile=First@FileNames[symbol<>".nb",symbolsDocDir],
Message[CopyDefinitionCodeToDocumentation::missingFile,symbol];
Abort[]];
showQ=OptionValue["ShowNotebooks"];
testRunQ=OptionValue["TestRun"];
windowModeQ=OptionValue["OpenedWindowsMode"];

(*---* Copy cell(s) from source *---*)
nb=NotebookOpen[definitionsFile,Visible->False];
SetSelectedNotebook@nb;
check=False;
While[check===False,
NotebookFind[definitionsFile,symbol];
SelectionMove[nb,Next,Cell];
data=NotebookRead[nb];
check=(data[[1]]===symbol&&data[[2]]==="Subchapter")
];
SelectionMove[nb,Next,CellGroup];
cells=NotebookRead[nb];
NotebookClose[nb];
temp=Flatten[Position[cells,Background->#,Infinity]&/@{RGBColor[0.87, 0.94, 1],RGBColor[1, 0.9, 0.8]},1];
temp=Join[{{1,1,1}},temp[[All,;;3]]];
cells=Delete[cells,temp[[All,;;3]]];
cells=Replace[cells,(InitializationCell->True)->InitializationCell -> False,Infinity];

(*---* Copy to target (documentation notebook) *---*)
If[windowModeQ,
(* a. 'OpenedWindows' mode: execute copying on window opened in notebook editior *)
nb=Check[SetSelectedNotebook@@Notebooks@symbol,
Message[CopyDefinitionCodeToDocumentation::nbEditor,symbol];Abort[]],

(* b. Assume notebook editor front-end is running and open notebook *)
(* Check if 'DocumentationTools' are present *)
If[!FileExistsQ@FileNameJoin[{
$UserBaseDirectory,"Applications","DocumentationTools",
"Kernel","init.m"}],
Message[CopyDefinitionCodeToDocumentation::missingDocTools];
Abort[]];

nb=NotebookOpen[
FileNameJoin[{symbolsDocDir,symbol<>".nb"}],Visible->showQ];
];

(* Common copying procedure *)
SelectionMove[nb,After,Notebook];
NotebookFind[nb,"Mathematica code",Previous];
While[
True,
SelectionMove[nb,Next,Cell];
check=NotebookRead[nb];
If[check==={},Break[]];
NotebookDelete[nb]
];
NotebookFind[nb,"Mathematica code",Previous];
SelectionMove[nb,Next,Cell];
NotebookWrite[nb,cells];
If[!testRunQ,NotebookSave@nb];
If[!testRunQ,NotebookClose@nb];

Label["End"];
]


(* ::Input::Initialization:: *)
CopyDefinitionCodeToDocumentation[OptionsPattern@CopyDefinitionCodeToDocumentation]:=
Module[{symbolsDocDir,definitionsFile,functionNames,options},

(*---* Find all symbols automatically *---*)
symbolsDocDir=OptionValue["DocumentationSymbolsDir"];
definitionsFile=OptionValue["DefinitionFile"];
functionNames=NotebookImport[definitionsFile,"Subchapter"];

(* Options *)
options=Keys@Options@CopyDefinitionCodeToDocumentation;
options=#->OptionValue[#]&/@options;

Do[
CopyDefinitionCodeToDocumentation[
functionNames[[i]],options/.List->Sequence],
{i,Length@functionNames}];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
RenamePackageFunction::notfound="\[LeftGuillemet]`1`\[RightGuillemet] was not found in the definitions file.";
RenamePackageFunction::nbNotFound="No notebook \[LeftGuillemet]`1`.nb\[RightGuillemet] was found in \[LeftGuillemet]`2`\[RightGuillemet].";
RenamePackageFunction::missingDocTools="Missing \[LeftGuillemet]DocumentationTools\[RightGuillemet] from Applications.";

Options@RenamePackageFunction={
"DocumentationDir"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud/Utdanning/(2016-2020) Universitetet i Stavanger (PhD)/Mathematica project/GitHub/MaXrd/Documentation",
"DefinitionFile"->"/Users/Stian/Library/Mobile Documents/com~apple~CloudDocs/Stians iCloud/Utdanning/(2016-2020) Universitetet i Stavanger (PhD)/Mathematica project/GitHub/MaXrd/Core/Definitions.nb",
"ShowNotebooks"->False,
"TestRun"->False,
"ReturnContainedOnly"->False
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RenamePackageFunction[oldName_String,newName_String,OptionsPattern@RenamePackageFunction]:=
Module[
{docDir,symbolsDocDir,definitionsFile,showQ,testRunQ,
import,L,nb,
allDocPages,contained={},exc,oldNamePattern,
checkAndReplace,searchAndReplace,saveProcedure,
read,write,oldFile,newFile},

(*---* File and directory setup *---*)
docDir=OptionValue["DocumentationDir"];
symbolsDocDir=FileNameJoin[{docDir,"English","ReferencePages","Symbols"}];
definitionsFile=OptionValue["DefinitionFile"];
showQ=OptionValue["ShowNotebooks"];
testRunQ=OptionValue["TestRun"];

(* Pattern recognition *)
exc=Except[{LetterCharacter|"\""}];
oldNamePattern={StartOfString,exc}~~oldName~~{exc,EndOfString};

(* Symbol notebooks *)
allDocPages=FileNames["*.nb",symbolsDocDir];
oldFile=Select[allDocPages,
StringContainsQ[#,$PathnameSeparator~~oldName~~".nb"~~EndOfString]&];
	(* Check: Does '<oldName>.nb' exist? *)
	If[oldFile==={},Message[RenamePackageFunction::nbNotFound,
	oldName,symbolsDocDir];Abort[],
	oldFile=First@oldFile];
contained=Select[allDocPages,StringContainsQ[Import[#,"Text"],oldName]&];
If[OptionValue["ReturnContainedOnly"],Return[FileBaseName/@contained]];

(*---* check-and-replace procedures *---*)
(* Check-and-replace *)
checkAndReplace[nb_NotebookObject]:=(
SelectionMove[nb,All,Expression];
read=NotebookRead[nb];
	If[Head@read==TemplateBox,
	SelectionMove[nb,Next,Cell];Continue[]];
If[StringContainsQ[ToString@read,oldNamePattern],
write=read/.s_String:>StringReplace[s,oldName->newName];
NotebookWrite[nb,write]];
SelectionMove[nb,Next,Word]);

(* Search-and-replace *)
searchAndReplace[nb_NotebookObject]:=While[
NotebookFind[nb,oldName,WordSearch->True]=!=$Failed,
checkAndReplace[nb]];

(* Saving *)
saveProcedure[nb_NotebookObject]:=If[testRunQ,
If[showQ,DialogInput[Column[{"Click OK to close this (unsaved) and continue.",DefaultButton["OK",DialogReturn[]]}]]],
NotebookSave[nb]];

(*---* Replacements *---*)
(* 1. Scan through definitions notebook *)
import=Import[definitionsFile,"Text"];
	(* Check if old function exists *)
	If[!StringContainsQ[import,oldName],
	Message[RenamePackageFunction::notfound,oldName];Abort[]];
L=Total@Flatten@List@StringCount[import,oldName];
nb=NotebookOpen[definitionsFile,Visible->showQ];
searchAndReplace[nb];
saveProcedure[nb];
NotebookClose[nb];

(* 2. Scan through documentation pages *)
(* Check if 'DocumentationTools' are present *)
If[!FileExistsQ@FileNameJoin[{
$UserBaseDirectory,"Applications","DocumentationTools",
"Kernel","init.m"}],
Message[RenamePackageFunction::missingDocTools];Goto["End"]];

Do[(* Execution *)
nb=NotebookOpen[contained[[i]],Visible->showQ];
searchAndReplace[nb];
saveProcedure[nb];
NotebookClose@nb,
{i,Length@contained}];

(* Rename corresponding documentation page *)
If[!testRunQ,newFile=FileNameJoin@ReplacePart[
FileNameSplit@oldFile,newName<>".nb",-1];
RenameFile[oldFile,newFile]];

(*---* Print information *---*)
Label["End"];
Print[
"Changed: "<>oldName<>" \[LongRightArrow] "<>newName<>"\n"<>
"Replacements in definitions file: "<>ToString@L<>"\n"
<>"Documentation pages considered:"];
Print[FileBaseName/@contained];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
