(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["Stians`Miscellaneous`"];


(* ::Input::Initialization:: *)
(* Import usage messages from file *)


(* ::Input::Initialization:: *)
<< "Stians/Messages/StiansMiscellaneous.txt"


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PolygonArea[input_List]:=Module[{n,i,s,dets},
n=Length[input];
For[i=1;s=0,
i<Length[input],
i++,
s=s+Det[{input[[i]],input[[i+1]]}]];
dets=s+Det[{input[[n]],input[[1]]}];
Abs[dets/2]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Colour::invRGB="RGB colours should be a list of three integers.";
Colour::invHTMLlength="HTML colours should be six characters long.";
Colour::invHTML="HTML colours should only contain digits or letters a\[Dash]e.";
Colour::inv="Invalid input.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ColourConversion[{R_Integer,G_Integer,B_Integer}]:=Module[{r,g,b,temp1,temp2,temp3,i},
r=IntegerString[R,16];
g=IntegerString[G,16];
b=IntegerString[B,16];
temp1={r,g,b};
temp2={};
For[i=1,i<4,i++,
If[StringLength[Part[temp1,i]]==1,
AppendTo[temp2,StringJoin["0",Part[temp1,i]]],
AppendTo[temp2,Part[temp1,i]]]];
temp3=StringJoin@temp2;
temp3
]


(* ::Input::Initialization:: *)
ColourConversion[HTML_]:=Module[{html,r,g,b,R,G,B},
html=ToString[HTML];
r=StringTake[html,{1,2}];
g=StringTake[html,{3,4}];
b=StringTake[html,{5,6}];
R=FromDigits[r,16];
G=FromDigits[g,16];
B=FromDigits[b,16];
{R,G,B}
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ComplementaryColour[input_]:=Module[{type,c,c1,c2,m1,m2,m3,colour},
(* Interpreting and testing input format *)
	If[!AnyTrue[Head[input]===#&/@{String,List},TrueQ],Message[Colour::inv];Abort[]];

	(* RGB input *)
		If[Head[input]==List,
		If[!Length@Flatten[input]==3,Message[Colour::invRGB];Abort[]];
		c=input;
		type="RGB"];

	(* HTML input *)
		If[Head[input]==String,
		If[!StringLength[input]==6,Message[Colour::invHTMLlength];Abort[]];
		If[!StringLength[StringReplace[input,{DigitCharacter,"a","b","c","d","e","f"}->""]]==0,Message[Colour::invHTML];Abort[]];
		c=ColourConversion[input];
		type="HTML"];


(* Step A: If at least two values are identical, swap them *)
	If[!DuplicateFreeQ[c],
	{c1,c2}=DeleteDuplicates[c][[{1,-1}]];
	colour=c/.{c1->c2,c2->c1}];

(* Step B: If all values are distinct, first swap position of the minimum and maximum values *)
(* The remaining middle position will be filled by 'max - middle + min' *)
	If[DuplicateFreeQ[c],
	{m1,m2,m3}={Min[c],Max[c],Sort[c][[2]]};
	colour=c/.{m1->m2,m2->m1,m3->m2-m3+m1}];

Which[
	type=="RGB",colour,
	type=="HTML",ColourConversion[colour]]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options[ColourTriad]={"Display"->False,"Format"->Null};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ColourTriad[input_,OptionsPattern@ColourTriad]:=Module[{type,c,p,colour,format,output,rgb},
(* Interpreting and testing input format *)
	If[!AnyTrue[Head[input]===#&/@{String,List},TrueQ],Message[Colour::inv];Abort[]];

	(* RGB input *)
		If[Head[input]==List,
		If[!Length@Flatten[input]==3,Message[Colour::invRGB];Abort[]];
		c=input;
		type="RGB"];

	(* HTML input *)
		If[Head[input]==String,
		If[!StringLength[input]==6,Message[Colour::invHTMLlength];Abort[]];
		If[!StringLength[StringReplace[input,{DigitCharacter,"a","b","c","d","e","f"}->""]]==0,Message[Colour::invHTML];Abort[]];
		c=ColourConversion[input];
		type="HTML"];

(* Cycle the values *)
	p=Select[Permutations[Range@3],Signature[#]==1&];
	colour={c[[#1]],c[[#2]],c[[#3]]}&@@p;

(* Option: Output format *)
	format=OptionValue["Format"];
	Which[
	format=="RGB"||format=="rgb",type="RGB",
	format=="HTML"||format=="html",type="HTML",
	True,Null];	

Which[
	type=="RGB",output=colour,
	type=="HTML",output=ColourConversion/@colour];

(* Option: Display colours *)
	If[OptionValue["Display"],
	rgb=RGBColor@@@(colour/255);
	Graphics[
	{
	{rgb[[1]],Rectangle[{0,0}]},
	{rgb[[2]],Rectangle[{1,0}]},
	{rgb[[3]],Rectangle[{2,0}]}
	}
	],
	output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
LaTeXReminderCheck::ok="No duplicates found.";
LaTeXReminderCheck::dup="`1` duplicates were found.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LaTeXReminderCheck[file_String:
"/Users/Stian/Dropbox/Prosjekter/LaTeX/Guider og hjelp/LaTeX reminders.txt"
]:=Module[{temp1,a,b,temp2,temp3,temp4,temp5},

temp1=Import[file,"Data"];

{a,b}=Position[temp1,#][[1,1]]&/@{"Custom shortcuts in TexitEasy:","Custom shortcuts in Texmaker:"};

temp2=StringCases[ToString/@temp1[[a;;b]],{WordCharacter,"[","]"}..~~Repeated[" + "~~{WordCharacter..,_}]]/.{}->Nothing;

temp3=Gather[ToString/@temp2];

If[Evaluate[(Length/@temp3)/.{1->Nothing}]=={},Message[LaTeXReminderCheck::ok];Goto["End"]];

temp4=DeleteDuplicates@Flatten@Select[temp3,Length[#]==2&];

temp5=StringDelete[temp4,{"{","}"}];

Message[LaTeXReminderCheck::dup,Length@temp5];Print@TableForm@temp5;


Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PlagiarismCheck[input_String]:=Module[{temp,temp2,temp3,temp4},
temp=FileNameJoin[
{$TemporaryDirectory,ToString@Unique["temp"]<>".pdf"}];
CopyFile[input,temp];

temp2=ChangeExtension[temp,"txt"];
temp3=Import[temp2,"String"];
temp4=Hash[temp3,"MD5"];
IntegerString[temp4,16]
]


(* ::Input::Initialization:: *)
PlagiarismCheck[input_List]:=Module[{list,found,n,h,i},
list=<||>;
found={};

Do[
n=input[[i]];
h=PlagiarismCheck@input[[i]];
If[KeyExistsQ[list,h],
AppendTo[found,{list[h],n}]];
AppendTo[list,h->n],
{i,Length@input}];

found
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Default[PokemonTeamTest,2]=({{Null,"normal","fight","flying","poison","ground","rock","bug","ghost","steel","fire","water","grass","electric","psychic","ice","dragon","dark","fairy"},{"normal",1,1,1,1,1,.5,1,0,.5,1,1,1,1,1,1,1,1,1},{"fight",2,1,.5,.5,1,2,.5,0,2,1,1,1,1,.5,2,1,2,.5},{"flying",1,2,1,1,1,.5,2,1,.5,1,1,2,.5,1,1,1,1,1},{"poison",1,1,1,.5,.5,.5,1,.5,0,1,1,2,1,1,1,1,1,2},{"ground",1,1,0,2,1,2,.5,1,2,2,1,.5,2,1,1,1,1,1},{"rock",1,.5,2,1,.5,1,2,1,.5,2,1,1,1,1,2,1,1,1},{"bug",1,.5,.5,.5,1,1,1,.5,.5,.5,1,2,1,2,1,1,2,.5},{"ghost",0,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,.5,1},{"steel",1,1,1,1,1,2,1,1,.5,.5,.5,1,.5,1,2,1,1,2},{"fire",1,1,1,1,1,.5,2,1,2,.5,.5,2,1,1,2,.5,1,1},{"water",1,1,1,1,2,2,1,1,1,2,.5,.5,1,1,1,.5,1,1},{"grass",1,1,.5,.5,2,2,.5,1,.5,.5,2,.5,1,1,1,.5,1,1},{"electric",1,1,2,1,0,1,1,1,1,1,2,.5,.5,1,1,.5,1,1},{"psychic",1,2,1,2,1,1,1,1,.5,1,1,1,1,.5,1,1,0,1},{"ice",1,1,2,1,2,1,1,1,.5,.5,.5,2,1,1,.5,2,1,1},{"dragon",1,1,1,1,1,1,1,1,.5,1,1,1,1,1,1,2,1,0},{"dark",1,.5,1,1,1,1,1,2,1,1,1,1,1,2,1,1,.5,.5},{"fairy",1,2,1,.5,1,1,1,1,.5,.5,1,1,1,1,1,2,2,1}});

PokemonTeamTest::InvType="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid Pok\[EAcute]mon type.";
PokemonTeamTest::InvTypes="\[LeftGuillemet]`1`\[RightGuillemet] are not a valid Pok\[EAcute]mon types.";
PokemonTeamTest::NotString="Pok\[EAcute]mon types must be strings.";
PokemonTeamTest::OK="Pok\[EAcute]mon team OK.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
PokemonTeamTest[pokemon_,typetable_.]:=Module[
{alltypes,notpokemon,ttable,pkmn,str,goodagainst,good,missing},
(* Basic information *)
	alltypes=typetable[[1,2;;]];
	notpokemon=Complement[pokemon,alltypes];

(* Input check *)
	If[notpokemon!={},
	If[Length[notpokemon]==1,
	Message[PokemonTeamTest::InvType,First@notpokemon];Abort[],
	Message[PokemonTeamTest::InvTypes,notpokemon]
	]];

	If[!AllTrue[pokemon,StringQ],Message[PokemonTeamTest::NotString];Abort[]];

(* Keeping rows with given types *)
	ttable=typetable[[2;;]];
	pkmn=Select[ttable,MemberQ[pokemon,First[#]]&];

(* Finding which types the team is effective against *)
	str=Last/@Position[pkmn,2];
	goodagainst=typetable[[1,#]]&/@str;
	good=DeleteDuplicates@goodagainst;

(* Missing types effective against... *)
	missing=Complement[alltypes,good];

(* Returning result *)
	If[missing=={},Message[PokemonTeamTest::OK],Return@missing];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
GradeCalculation::invalid="Invalid input.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GradeCalculation[input__]:=(
(* Gather numbers in a list *)
	GradeCalculation[{input}]
)


(* ::Input::Initialization:: *)
GradeCalculation[input_]:=Module[{L,Letter,Number,sum,averagegrade},
(* Input check *)
	L=Length[input];
	If[!MemberQ[{5,6},L],Message[GradeCalculation::invalid];Abort[]];

(* Conversion functions *)
	Letter[number_]:=Which[
	number<0.5,           "F",
	0.5<=number<1.5,"E",
	1.5<=number<2.5,"D",
	2.5<=number<3.5,"C",
	3.5<=number<4.5,"B",
	number>=4.5,           "A"];

	Number[letter_]:=Which[
	letter=="F",0,
	letter=="E",1,
	letter=="D",2,
	letter=="C",3,
	letter=="B",4,
	letter=="A",5,
	NumericQ[letter],letter];

(* Average grade of an exam *)
	Which[
	L==5,sum=input.(Number/@{"A","B","C","D","E"}),
	L==6,sum=input.(Number/@{"A","B","C","D","E","F"})];
	
averagegrade=Letter[sum/Total@input]
]


(* ::Input::Initialization:: *)
GradeCalculation[input_?MatrixQ]:=Module[{Letter,Number,grades,weights,gpa},
(* Conversion functions *)
	Letter[number_]:=Which[
	number<0.5,           "F",
	0.5<=number<1.5,"E",
	1.5<=number<2.5,"D",
	2.5<=number<3.5,"C",
	3.5<=number<4.5,"B",
	number>=4.5,           "A"];

	Number[letter_]:=Which[
	letter=="F",0,
	letter=="E",1,
	letter=="D",2,
	letter=="C",3,
	letter=="B",4,
	letter=="A",5,
	NumericQ[letter],letter];

(* Grade point average *)
	grades=Number/@input[[All,1]];
	weights=input[[All,2]];
	gpa=(grades.weights)/Total[weights];

{NumberForm[N[gpa],3],Letter@gpa}
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
Options[GridToLaTeX]={"WrapNumbers"->False};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GridToLaTeX[grid_Grid,OptionsPattern@GridToLaTeX]:=Module[{
dim,content,
greek,rule1,rule2,extrarules,rules,extranonmath,
temp
},

(* Table dimensions and content *)
	If[Length@grid>1,
	dim={Length@First[#],Length@First@First[#]}&[grid],
	dim=Dimensions@First@grid];
	content=ToString/@Flatten@First@grid;

(* Convert to string and correct empty cells *)
	temp=(ToString/@content)/."Null"->"";

(* Correct subscripts *)
	temp=StringReplace[temp,
	{pre:Except[" "]..~~"\n"~~sub__:>
	"{"<>pre<>"}"<>"_{"<>StringTrim@sub<>"}",
	pre1:Except[" "]..~~" "..|"\\n"~~pre2___~~"\n"~~sub__:>
	"{"<>pre1<>"}"<>"_{"<>StringTrim@sub<>"} "<>pre2}];

(* Correct greek *)
	greek={
{"alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"},
{"Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega"},
{"CapitalAlpha","CapitalBeta","CapitalGamma","CapitalDelta","CapitalEpsilon","CapitalZeta","CapitalEta","CapitalTheta","CapitalIota","CapitalKappa","CapitalLambda","CapitalMu","CapitalNu","CapitalXi","CapitalOmicron","CapitalPi","CapitalRho","CapitalSigma","CapitalTau","CapitalUpsilon","CapitalPhi","CapitalChi","CapitalPsi","CapitalOmega"}};

	rule1=Thread[greek[[3]]->greek[[2]]];
	rule1="\\["<>#[[1]]<>"]"->"\\"<>#[[2]]&/@rule1;

	rule2=Thread[greek[[2]]->greek[[1]]];
	rule2="\\["<>#[[1]]<>"]"->"\\"<>#[[2]]&/@rule2;

	extrarules={
	"\\[Micro]"->"\\mu",
	"\\[Degree]"->"\\si{\\degree}"};

	rules=Join@@{rule1,rule2,extrarules};

	
	temp=ToString/@FullForm/@temp;

	(* Clearing extra quatiation marks *)
	temp=StringReplace[temp,{
	"\"\\\""~~c__~~"\\\"\"":>
	"\""<>c<>"\"","\""->""}];

	temp=StringReplace[temp,rules];

	temp=StringReplace[temp,x:greek~~y:LetterCharacter..:>x<>" "<>y];

	(* Wrapping subscript expressions on the form {...}_{...} with $...$ *)
	temp=StringReplace[temp,G:
	Shortest["{"~~__~~"}_{"~~__~~"}"]:>"$"<>G<>"$"];

	(* Finding unwrapped greek math *)
	temp=StringReplace[temp,
	(q:(
	p__/;(
	StringMatchQ[p,"$"~~___~~"\\"~~greek~~___~~"$"]||
	StringMatchQ[p,"\\"~~greek])
	):>
	StringReplace[q,{
	Shortest["$"~~k__~~"$"]:>"\[Section]"~~k~~"\[Section]",
	g:("\\"~~greek):>"$"<>g<>"$"}])/."\[Section]"->"$"
	];


(* Other corrections *)
	extranonmath={
	"\\[ODoubleDot]"->"\[ODoubleDot]",
	"_"->"\\textunderscore "};

	temp=StringReplace[temp,extranonmath];

(* Option: Wrap numbers *)
	If[StringQ@OptionValue["WrapNumbers"],
	temp=StringReplace[temp,t:{DigitCharacter,".","-"}..:>
	"\\"<>OptionValue["WrapNumbers"]<>"{"<>t<>"}"]];

(* Writing out lines *)
	temp=Partition[temp,Last@dim];
	temp=Riffle[#,{"&"}]&/@temp;
	temp=StringJoin@Riffle[#," "]&/@temp;
	temp=#<>" \\\\\n"&/@temp;

	Print@@Join@@
{{"\\begin{tabular}{"<>StringJoin@ConstantArray["c",Last@dim]<>"}\n"},
temp,
{"\\end{tabular}"}};	
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
