(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["Stians`GroupTheory`"];


(* ::Input::Initialization:: *)
(* Import usage messages from file *)


(* ::Input::Initialization:: *)
<< "Stians/Messages/StiansGroupTheory.txt"


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GroupTable[m_Integer]:=
Module[{table},
table=Table[Mod[i*j,m],{i,0,m-1},{j,0,m-1}];
TableForm[table,
TableHeadings->{#,#}&@Range[0,m]]
]


(* ::Input::Initialization:: *)
GroupTable[set_List,m_Integer]:=Module[{antall,table},
antall=Length@set;
table=Table[Mod[set[[i]]*set[[j]],m],{i,1,antall},{j,1,antall}];
TableForm[table,
TableHeadings->{#,#}&@set]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GroupInverse[t_Integer,m_Integer]:=Module[{k},
k=2;
While[Mod[k*t,m]!=1,k++];
k
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RelativelyPrimeList[t_Integer]:=Module[{liste,i},
liste={};
For[i=1,i<=t-1,i++,
If[GCD[i,t]==1,
AppendTo[liste,i],
(Null)]];
liste]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CommonPrimes[i__Integer]:=Module[{antall,temp1,temp2,felles,j},
antall=Length@{i};
temp1=FactorInteger[#][[All,1]]&/@{i};
temp2=Tally@Flatten@temp1;
felles={};
For[j=1,j<=Length@temp2,j++,
If[temp2[[j,2]]==antall,AppendTo[felles,temp2[[j,1]]],Null]];
felles
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
FindGenerators[m_Integer]:=Module[{generatorer,i},
generatorer={};
For[i=2,
	i<m,
	i++,
	If[Sort@Mod[i^Range@(m-1),m]===Range@(m-1),
	AppendTo[generatorer,i],
	Null]
	];
generatorer
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages and options *)


(* ::Input::Initialization:: *)
LinearCongruenceSolve::nosolution="No solutions.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
LinearCongruenceSolve[\[Alpha]_Integer,\[Beta]_Integer,\[Gamma]_Integer]:=Module[{solutions,a,b,c,k,x,X,n},
(* Checking the number of solutions (if any) *)
	solutions=GCD[\[Alpha],\[Gamma]];
	If[Divisible[\[Beta],solutions],Null,
		Message[LinearCongruenceSolve::nosolution];Goto["End"]];

(* Reducing the congruence *)
	{a,b,c}={\[Alpha],\[Beta],\[Gamma]}/GCD[\[Alpha],\[Beta],\[Gamma]];
	If[a>c,a=a-Quotient[a,c]*c,Null];

(* Finding the inverse in the corresponding cyclic group *)
	k=2;
	While[Mod[k*a,c]!=1,k++]; (* The inverse will be 'k' *)

(* Finding the solutions *) 
	x = Mod[k*b,c];
	X= {};
	For[n=0,x+n<\[Gamma],n=n+c,AppendTo[X,x+n]];
Return[ToString@X<>" + "<>ToString@\[Gamma]<>"\[DoubleStruckCapitalZ]"];
		Label["End"];
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
